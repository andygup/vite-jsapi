import{db as Ot,dX as I,b$ as w,gx as M,ho as Y,gq as Z,hp as bt,e as N,by as f,hq as tt,gp as K,ae as gt,ai as Et,c as Rt,gL as z}from"./index-175d32d0.js";import{v as At,b as Nt,j as St}from"./lineSegment-063fdb57.js";import{s as lt,d as et,q as $,p as ot,k as G,z as S,V as nt,_ as j,Q as it}from"./sphere-df5cc114.js";import{E as st}from"./QueryEngineResult-489114ee.js";import"./vec4f64-aa64c7e9.js";import"./plane-e6502816.js";import{i as rt}from"./InterleavedLayout-1af0d9de.js";import{m as Ft}from"./edgeProcessing-f0998a30.js";import"./ByteSizeUnit-d4757d40.js";import"./mat3f64-221ce671.js";import"./mat4f64-1413b4a7.js";import"./quatf64-3363c48e.js";import"./quantizationUtils-91ef8d14.js";import"./ItemCache-f50dc481.js";import"./MemCache-8e066c91.js";import"./WhereClause-7777bb00.js";import"./executionError-fb3f283a.js";import"./utils-c8d70c65.js";import"./generateRendererUtils-c590da44.js";import"./projectionSupport-5317a1c8.js";import"./json-48e3ea08.js";import"./utils-027313e6.js";import"./normalizeUtils-2391e42c.js";import"./normalizeUtilsCommon-b064c045.js";import"./featureConversionUtils-3787082f.js";import"./OptimizedGeometry-33b2eb0d.js";import"./OptimizedFeatureSet-1d1ac4b9.js";import"./BufferView-ec3ddd48.js";import"./types-1305598a.js";import"./deduplicate-7939838c.js";import"./Indices-e5e41718.js";import"./VertexAttribute-9f2e53ec.js";import"./enums-74e97557.js";import"./VertexElementDescriptor-2925c6af.js";function _t(n){return n?{ray:et(n.ray),c0:n.c0,c1:n.c1}:{ray:et(),c0:0,c1:Number.MAX_VALUE}}new lt(()=>_t());function C(n,t){for(let e=0;e<xt;e++){const o=n[e];if(o[0]*t[0]+o[1]*t[1]+o[2]*t[2]+o[3]>=t[3])return!1}return!0}var ht,c;(function(n){n[n.LEFT=0]="LEFT",n[n.RIGHT=1]="RIGHT",n[n.BOTTOM=2]="BOTTOM",n[n.TOP=3]="TOP",n[n.NEAR=4]="NEAR",n[n.FAR=5]="FAR"})(ht||(ht={})),function(n){n[n.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",n[n.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",n[n.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",n[n.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",n[n.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",n[n.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",n[n.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",n[n.FAR_TOP_LEFT=7]="FAR_TOP_LEFT"}(c||(c={}));c.FAR_BOTTOM_RIGHT,c.NEAR_BOTTOM_RIGHT,c.NEAR_BOTTOM_LEFT,c.FAR_BOTTOM_LEFT,c.NEAR_BOTTOM_LEFT,c.NEAR_BOTTOM_RIGHT,c.NEAR_TOP_RIGHT,c.NEAR_TOP_LEFT,c.FAR_BOTTOM_RIGHT,c.FAR_BOTTOM_LEFT,c.FAR_TOP_LEFT,c.FAR_TOP_RIGHT,c.NEAR_BOTTOM_RIGHT,c.FAR_BOTTOM_RIGHT,c.FAR_TOP_RIGHT,c.NEAR_TOP_RIGHT,c.FAR_BOTTOM_LEFT,c.NEAR_BOTTOM_LEFT,c.NEAR_TOP_LEFT,c.FAR_TOP_LEFT,c.FAR_TOP_LEFT,c.NEAR_TOP_LEFT,c.NEAR_TOP_RIGHT,c.FAR_TOP_RIGHT;const xt=6;new lt(_t);let J=class H{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,e){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new u,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}destroy(){this._degenerateObjects.clear(),u.clearPool(),X[0]=null,F.prune(),x.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const o=u.acquire();for(let i=0;i<e;i++){const s=t[i];this._isDegenerate(s)?this._degenerateObjects.add(s):(o.init(this._root),this._add(s,o))}u.release(o)}remove(t,e=null){this._objectCount-=t.length;const o=u.acquire();for(const i of t){const s=e??$(this.objectToBoundingSphere(i),Lt);L(s[3])?(o.init(this._root),this._remove(i,s,o)):this._degenerateObjects.delete(i)}u.release(o),this._shrink()}update(t,e){if(!L(e[3])&&this._isDegenerate(t))return;const o=Pt(t);this.remove(o,e),this.add(o)}forEachAlongRay(t,e,o){const i=ot(t,e);this._forEachNode(this._root,s=>{if(!this._intersectsNode(i,s))return!1;const h=s.node;return h.terminals.forAll(d=>{this._intersectsObject(i,d)&&o(d)}),h.residents!==null&&h.residents.forAll(d=>{this._intersectsObject(i,d)&&o(d)}),!0})}forEachAlongRayWithVerticalOffset(t,e,o,i){const s=ot(t,e);this._forEachNode(this._root,h=>{if(!this._intersectsNodeWithOffset(s,h,i))return!1;const d=h.node;return d.terminals.forAll(r=>{this._intersectsObjectWithOffset(s,r,i)&&o(r)}),d.residents!==null&&d.residents.forAll(r=>{this._intersectsObjectWithOffset(s,r,i)&&o(r)}),!0})}forEach(t){this._forEachNode(this._root,e=>{const o=e.node;return o.terminals.forAll(t),o.residents!==null&&o.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,o,i=()=>!0,s=1/0){let h=1/0,d=1/0,r=null;const a=q(t,e),_=l=>{if(--s,!i(l))return;const p=this.objectToBoundingSphere(l);if(!C(o,p))return;const g=A(t,e,S(p)),B=g-p[3],m=g+p[3];B<h&&(h=B,d=m,r=l)};return this._forEachNodeDepthOrdered(this._root,l=>{if(s<=0||!C(o,l.bounds)||(w(b,a,l.halfSize),M(b,b,l.bounds),A(t,e,b)>d))return!1;const p=l.node;return p.terminals.forAll(g=>_(g)),p.residents!==null&&p.residents.forAll(g=>_(g)),!0},t,e),r}forEachInDepthRange(t,e,o,i,s,h,d){let r=-1/0,a=1/0;const _={setRange:m=>{o===H.DepthOrder.FRONT_TO_BACK?(r=Math.max(r,m.near),a=Math.min(a,m.far)):(r=Math.max(r,-m.far),a=Math.min(a,-m.near))}};_.setRange(i);const l=A(e,o,t),p=q(e,o),g=q(e,-o),B=m=>{if(!d(m))return;const R=this.objectToBoundingSphere(m),P=S(R),Q=A(e,o,P)-l,pt=Q-R[3],Tt=Q+R[3];pt>a||Tt<r||!C(h,R)||s(m,_)};this._forEachNodeDepthOrdered(this._root,m=>{if(!C(h,m.bounds)||(w(b,p,m.halfSize),M(b,b,m.bounds),A(e,o,b)-l>a)||(w(b,g,m.halfSize),M(b,b,m.bounds),A(e,o,b)-l<r))return!1;const R=m.node;return R.terminals.forAll(P=>B(P)),R.residents!==null&&R.residents.forAll(P=>B(P)),!0},e,o)}forEachNode(t){this._forEachNode(this._root,e=>t(e.node,e.bounds,e.halfSize,e.depth))}forEachNeighbor(t,e){const o=G(e),i=S(e),s=r=>{const a=this.objectToBoundingSphere(r),_=G(a),l=o+_;return!(Y(S(a),i)-l*l<=0)||t(r)};let h=!0;const d=r=>{h&&(h=s(r))};this._forEachNode(this._root,r=>{const a=G(r.bounds),_=o+a;if(Y(S(r.bounds),i)-_*_>0)return!1;const l=r.node;return l.terminals.forAll(d),h&&l.residents!==null&&l.residents.forAll(d),h}),h&&this.forEachDegenerateObject(d)}_intersectsNode(t,e){return v(e.bounds,2*-e.halfSize,T),v(e.bounds,2*e.halfSize,O),rt(t.origin,t.direction,T,O)}_intersectsNodeWithOffset(t,e,o){return v(e.bounds,2*-e.halfSize,T),v(e.bounds,2*e.halfSize,O),o.applyToMinMax(T,O),rt(t.origin,t.direction,T,O)}_intersectsObject(t,e){const o=this.objectToBoundingSphere(e);return!(o[3]>0)||nt(o,t)}_intersectsObjectWithOffset(t,e,o){const i=this.objectToBoundingSphere(e);return!(i[3]>0)||nt(o.applyToBoundingSphere(i),t)}_forEachNode(t,e){let o=u.acquire().init(t);const i=[o];for(;i.length!==0;){if(o=i.pop(),e(o)&&!o.isLeaf())for(let s=0;s<o.node.children.length;s++)o.node.children[s]&&i.push(u.acquire().init(o).advance(s));u.release(o)}}_forEachNodeDepthOrdered(t,e,o,i=H.DepthOrder.FRONT_TO_BACK){let s=u.acquire().init(t);const h=[s];for(Bt(o,i,ct);h.length!==0;){if(s=h.pop(),e(s)&&!s.isLeaf())for(let d=7;d>=0;--d){const r=ct[d];s.node.children[r]&&h.push(u.acquire().init(s).advance(r))}u.release(s)}}_remove(t,e,o){F.clear();const i=o.advanceTo(e,(s,h)=>{F.push(s.node),F.push(h)})?o.node.terminals:o.node.residents;if(i.removeUnordered(t),i.length===0)for(let s=F.length-2;s>=0;s-=2){const h=F.data[s],d=F.data[s+1];if(!this._purge(h,d))break}}_nodeIsEmpty(t){if(t.terminals.length!==0)return!1;if(t.residents!==null)return t.residents.length===0;for(let e=0;e<t.children.length;e++)if(t.children[e])return!1;return!0}_purge(t,e){return e>=0&&(t.children[e]=null),!!this._nodeIsEmpty(t)&&(t.residents===null&&(t.residents=new I({shrink:!0})),!0)}_add(t,e){e.advanceTo(this.objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let o=0;o<e.length;o++){const i=u.acquire().init(t);this._add(e.getItemAt(o),i),u.release(i)}}_grow(t,e){if(e!==0&&(dt(t,e,o=>this.objectToBoundingSphere(o),E),L(E[3])&&!this._fitsInsideTree(E)))if(this._nodeIsEmpty(this._root.node))$(E,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const o=this._rootBoundsForRootAsSubNode(E);this._placingRootViolatesMaxDepth(o)?this._rebuildTree(E,o):this._growRootAsSubNode(o),u.release(o)}}_rebuildTree(t,e){Z(V,e.bounds),V[3]=e.halfSize,dt([t,V],2,i=>i,W);const o=u.acquire().init(this._root);this._root.initFrom(null,W,W[3]),this._root.increaseHalfSize(1.25),this._forEachNode(o,i=>(this.add(i.node.terminals.data,i.node.terminals.length),i.node.residents!==null&&this.add(i.node.residents.data,i.node.residents.length),!0)),u.release(o)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let o=0;return this._forEachNode(this._root,i=>(o=Math.max(o,i.depth),o+e<=this._maximumDepth)),o+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],o=t;let i=-1/0;const s=this._root.bounds,h=this._root.halfSize;for(let r=0;r<3;r++){const a=s[r]-h-(o[r]-e),_=o[r]+e-(s[r]+h),l=Math.max(0,Math.ceil(a/(2*h))),p=Math.max(0,Math.ceil(_/(2*h)))+1,g=2**Math.ceil(Math.log(l+p)*Math.LOG2E);i=Math.max(i,g),D[r].min=l,D[r].max=p}for(let r=0;r<3;r++){let a=D[r].min,_=D[r].max;const l=(i-(a+_))/2;a+=Math.ceil(l),_+=Math.floor(l);const p=s[r]-h-a*h*2;k[r]=p+(_+a)*h}const d=i*h;return k[3]=d*ft,u.acquire().initFrom(null,k,d,0)}_growRootAsSubNode(t){const e=this._root.node;Z(E,this._root.bounds),E[3]=this._root.halfSize,this._root.init(t),t.advanceTo(E,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let o=0,i=0;for(;i<e.length&&t==null;)o=i++,t=e[o];for(;i<e.length;)if(e[i++])return-1;return o}_isDegenerate(t){return!L(this.objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,o=this._root.halfSize;return t[3]<=o&&t[0]>=e[0]-o&&t[0]<=e[0]+o&&t[1]>=e[1]-o&&t[1]<=e[1]+o&&t[2]>=e[2]-o&&t[2]<=e[2]+o}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:e,_objectCount:o}=this,i=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:e,objectCount:o,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:i}}}_nodeToJSON(t){var s,h;const e=t.children.map(d=>d?this._nodeToJSON(d):null),o=(s=t.residents)==null?void 0:s.map(d=>this.objectToBoundingSphere(d)),i=(h=t.terminals)==null?void 0:h.map(d=>this.objectToBoundingSphere(d));return{children:e,residents:o,terminals:i}}static fromJSON(t){const e=new H(o=>o,{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return e._objectCount=t.objectCount,e._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),e}};class u{constructor(){this.bounds=j(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,o,i=this.depth){return this.node=t??u.createEmptyNode(),e!=null&&$(e,this.bounds),this.halfSize=o,this.depth=i,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*ft}advance(t){let e=this.node.children[t];e||(e=u.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const o=mt[t];return this.bounds[0]+=o[0]*this.halfSize,this.bounds[1]+=o[1]*this.halfSize,this.bounds[2]+=o[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,e,o=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!o)return e&&e(this,-1),!1;this.node.residents=null}const i=this._childIndex(t);e&&e(this,i),this.advance(i)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new I({shrink:!0}),residents:new I({shrink:!0})}}static acquire(){return u._pool.acquire()}static release(t){u._pool.release(t)}static clearPool(){u._pool.prune()}}function jt(n,t){n[0]=Math.min(n[0],t[0]-t[3]),n[1]=Math.min(n[1],t[1]-t[3]),n[2]=Math.min(n[2],t[2]-t[3])}function Mt(n,t){n[0]=Math.max(n[0],t[0]+t[3]),n[1]=Math.max(n[1],t[1]+t[3]),n[2]=Math.max(n[2],t[2]+t[3])}function v(n,t,e){e[0]=n[0]+t,e[1]=n[1]+t,e[2]=n[2]+t}function dt(n,t,e,o){if(t===1){const i=e(n[0]);$(i,o)}else{T[0]=1/0,T[1]=1/0,T[2]=1/0,O[0]=-1/0,O[1]=-1/0,O[2]=-1/0;for(let i=0;i<t;i++){const s=e(n[i]);L(s[3])&&(jt(T,s),Mt(O,s))}bt(o,T,O,.5),o[3]=Math.max(O[0]-T[0],O[1]-T[1],O[2]-T[2])/2}}function Bt(n,t,e){if(!x.length)for(let o=0;o<8;++o)x.push({index:0,distance:0});for(let o=0;o<8;++o){const i=mt[o];x.data[o].index=o,x.data[o].distance=A(n,t,i)}x.sort((o,i)=>o.distance-i.distance);for(let o=0;o<8;++o)e[o]=x.data[o].index}function q(n,t){let e,o=1/0;for(let i=0;i<8;++i){const s=A(n,t,at[i]);s<o&&(o=s,e=at[i])}return e}function A(n,t,e){return t*(n[0]*e[0]+n[1]*e[1]+n[2]*e[2])}function L(n){return!isNaN(n)&&n!==-1/0&&n!==1/0&&n>0}u._pool=new Ot(u),function(n){var t;(t=n.DepthOrder||(n.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(J||(J={}));const mt=[f(-1,-1,-1),f(1,-1,-1),f(-1,1,-1),f(1,1,-1),f(-1,-1,1),f(1,-1,1),f(-1,1,1),f(1,1,1)],at=[f(-1,-1,-1),f(-1,-1,1),f(-1,1,-1),f(-1,1,1),f(1,-1,-1),f(1,-1,1),f(1,1,-1),f(1,1,1)],ft=Math.sqrt(3),X=[null];function Pt(n){return X[0]=n,X}const k=j(),b=N(),T=N(),O=N(),F=new I,Lt=j(),E=j(),V=j(),W=j(),D=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],x=new I,ct=[0,0,0,0,0,0,0,0],ut=J,It=1e3;function zt(n,t,e){const o=j(),i=S(o);return tt(i,i,n,.5),tt(i,i,t,.5),o[3]=K(i,n),M(i,i,e),o}let U=class{constructor(){this._idToComponent=new Map,this._components=new ut(n=>n.bounds),this._edges=new ut(n=>n.bounds),this._tmpLineSegment=At(),this._tmpP1=N(),this._tmpP2=N(),this._tmpP3=N(),this.remoteClient=null}async fetchCandidates(n,t){await Promise.resolve(),Rt(t),await this._ensureEdgeLocations(n,t);const e=[];return this._edges.forEachNeighbor(o=>(this._addCandidates(n,o,e),e.length<It),n.bounds),{result:{candidates:e}}}async _ensureEdgeLocations(n,t){const e=[];if(this._components.forEachNeighbor(s=>{if(s.info==null){const{id:h,uid:d}=s;e.push({id:h,uid:d})}return!0},n.bounds),!e.length)return;const o={components:e},i=await this.remoteClient.invoke("fetchAllEdgeLocations",o,t??{});for(const s of i.components)this._setFetchEdgeLocations(s)}async add(n){const t=new y(n.id,n.bounds);return this._idToComponent.set(t.id,t),this._components.add([t]),{result:{}}}async remove(n){const t=this._idToComponent.get(n.id);if(t){const e=[];this._edges.forEachNeighbor(o=>(o.component===t&&e.push(o),!0),t.bounds),this._edges.remove(e),this._components.remove([t]),this._idToComponent.delete(t.id)}return{result:{}}}_setFetchEdgeLocations(n){const t=this._idToComponent.get(n.id);if(t==null||n.uid!==t.uid)return;const e=Ft.createView(n.locations),o=new Array(e.count),i=N(),s=N();for(let r=0;r<e.count;r++){e.position0.getVec(r,i),e.position1.getVec(r,s);const a=zt(i,s,n.origin),_=new Ct(t,r,a);o[r]=_}this._edges.add(o);const{objectIds:h,origin:d}=n;t.info={locations:e,objectIds:h,origin:d}}_addCandidates(n,t,e){const{info:o}=t.component,{origin:i,objectIds:s}=o,h=o.locations,d=h.position0.getVec(t.index,this._tmpP1),r=h.position1.getVec(t.index,this._tmpP2);M(d,d,i),M(r,r,i);const a=s[h.componentIndex.get(t.index)];this._addEdgeCandidate(n,a,d,r,e),this._addVertexCandidate(n,a,d,e),this._addVertexCandidate(n,a,r,e)}_addEdgeCandidate(n,t,e,o,i){if(!(n.types&st.EDGE))return;const s=S(n.bounds),h=Nt(e,o,this._tmpLineSegment),d=St(h,s,this._tmpP3);it(n.bounds,d)&&i.push({type:"edge",objectId:t,target:z(d),distance:K(s,d),start:z(e),end:z(o)})}_addVertexCandidate(n,t,e,o){if(!(n.types&st.VERTEX))return;const i=S(n.bounds);it(n.bounds,e)&&o.push({type:"vertex",objectId:t,target:z(e),distance:K(i,e)})}};U=gt([Et("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],U);const pe=U;class y{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++y.uid}}y.uid=0;class Ct{constructor(t,e,o){this.component=t,this.index=e,this.bounds=o}}export{pe as default};
