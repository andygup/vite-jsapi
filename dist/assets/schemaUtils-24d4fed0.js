import{s as ne,a as c}from"./Error-bd05b442.js";import{h as se}from"./string-3d0ebcd3.js";import{r as h,z as le,e as N,t as H}from"./typedArrayUtil-2bcf3cee.js";import{u as U}from"./screenUtils-7afeb41c.js";import{t as oe}from"./LayerFloorInfo-689deffc.js";import{m as ae}from"./diffUtils-58fbd195.js";import{c as Y}from"./labelingInfo-f1d3ed98.js";import{A as V,S as m}from"./enums-4ca4641f.js";import{r as ue}from"./Utils-c2939f8d.js";import{c as fe}from"./utils-6c2afd8b.js";import{l as de}from"./visualVariablesUtils-b572c1c3.js";import{createSymbolSchema as g}from"./createSymbolSchema-deb469a5.js";import"./ExpandedCIM-f5d9de07.js";import"./Polyline-c56eca9b.js";import"./mathUtils-daf59e84.js";import"./Extent-7f29a1bb.js";import"./MaterialKey-b4e71fc3.js";import"./mat2d-80bd93af.js";import"./vec2-f978aef8.js";import"./vec2f32-461e65a9.js";import"./request-c2b0ab45.js";import"./Portal-ac0dca24.js";import"./persistableUrlUtils-7e525def.js";import"./PortalGroup-f3dee6d8.js";import{g as K,i as pe}from"./rendererUtils-2abcd901.js";import{m as ce,d as ye}from"./FeatureReductionLayer-d7ad3b5e.js";import{e as j}from"./util-7859c103.js";function me(e){if(!e)return V.NONE;let r=0;for(const i of e)if(i.type==="size"){const t=de(i);r|=t,i.target==="outline"&&(r|=t<<4)}else i.type==="color"?r|=V.COLOR:i.type==="opacity"?r|=V.OPACITY:i.type==="rotation"&&(r|=V.ROTATION);return r}function ge(e,r){if(!("visualVariables"in e)||!e.hasVisualVariables("size"))return 0;const i=e.getVisualVariablesForType("size");if(!i[0])return 0;const t=i[0];if(r&&t.field==="cluster_count"&&r.type==="cluster")return r.clusterMaxSize;if(t.target==="outline")return 0;if(t.transformationType==="stops")return t.stops.map(n=>n.size).reduce(M,0);if(t.transformationType==="clamped-linear"){let n=-1/0,s=-1/0;return n=typeof t.maxSize=="number"?t.maxSize:t.maxSize.stops.map(l=>l.size).reduce(M,0),s=typeof t.minSize=="number"?t.minSize:t.minSize.stops.map(l=>l.size).reduce(M,0),Math.max(n,s)}return t.transformationType==="real-world-size"?30:void 0}function M(e,r){return Math.max(e,r)}const v=ne.getLogger("esri.views.2d.layers.features.schemaUtils"),p="ValidationError";function P(e,r){let i=0,t=0,n=m.DEFAULT;if(h(e)){if(t=ge(e,r),"visualVariables"in e&&(i=me(e.visualVariables||[]),e.type==="dot-density"&&(n=m.DOT_DENSITY)),e.type==="heatmap"&&(n=m.HEATMAP),e.type==="dictionary")return{maxVVSize:t,vvFlags:i,symbologyType:m.DEFAULT};if(e.type==="pie-chart")return{maxVVSize:t,vvFlags:i,symbologyType:m.PIE_CHART};if(n!==m.DOT_DENSITY&&n!==m.HEATMAP){const s=e.getSymbols();"backgroundFillSymbol"in e&&e.backgroundFillSymbol&&s.push(e.backgroundFillSymbol);let l=!0,a=!0;for(const o of s)if(o.type==="cim"&&(a=!1),o.type==="simple-fill"||o.type==="picture-fill"){const u=o.outline,f=u&&u.style!=="none"&&u.style!=="solid",d=o.type==="simple-fill"&&o.style!=="none"&&o.style!=="solid",y=o.type==="picture-fill"||d||f;f&&(l=!1),y&&(a=!1)}l?n=a?m.OUTLINE_FILL_SIMPLE:m.OUTLINE_FILL:a&&(n=m.SIMPLE)}}return{vvFlags:i,maxVVSize:t,symbologyType:n}}let _=null;function ot(e){if(se("esri-2d-update-debug")){const r=q(e,!0);console.debug("Created new schema",r),console.debug("Schema diff",ae(_,r)),_=r}return q(e)}function q(e,r=!1){var i,t;try{const n=Te(e,r),s=Ee(e),l={};n.map(u=>be(l,e,u));const a=h(e.subtypeCode)?`${e.subtypeField} = ${e.subtypeCode}`:null;return{source:{definitionExpression:oe(e.definitionExpression,a),fields:e.fields.map(u=>u.toJSON()),gdbVersion:e.gdbVersion,historicMoment:(i=e.historicMoment)==null?void 0:i.getTime(),outFields:e.availableFields,pixelBuffer:e.pixelBuffer,spatialReference:e.spatialReference.toJSON(),timeExtent:(t=e.timeExtent)==null?void 0:t.toJSON(),customParameters:e.customParameters},attributes:{fields:{},indexCount:0},processors:n,tileRenderer:s,targets:l}}catch(n){if(n.fieldName===p)return v.error(n),null;throw n}}function be(e,r,i){switch(i.target){case"feature":return void R(e,L(r),i);case"aggregate":{if(!("featureReduction"in r))return;const t=r.featureReduction;switch(t.type){case"selection":throw new c(p,"Mapview does not support `selection` reduction type",t);case"binning":return R(e,L(r),i),void xe(e,t,r.fields.map(n=>n.toJSON()),i);case"cluster":return R(e,L(r),i),void he(e,t,r.fields.map(n=>n.toJSON()),i)}}}}function k(e,r){for(const i in r){const t=r[i];if(t.target!==e.name)continue;const n=e.attributes[i];n?(n.context.mesh=n.context.mesh||t.context.mesh,n.context.storage=n.context.storage||t.context.storage):e.attributes[i]=t}return e}function L(e){var r,i,t;return[((r=N(e.filter))==null?void 0:r.toJSON())??null,((t=N((i=N(e.featureEffect))==null?void 0:i.filter))==null?void 0:t.toJSON())??null]}function R(e,r,i){return e.feature||(e.feature={name:"feature",input:"source",filters:r,attributes:{}}),k(e.feature,i.attributes.fields),e}function Q(e,r){const{onStatisticExpression:i,onStatisticField:t,statisticType:n}=e;switch(n){case"min":case"max":case"avg":case"avg_angle":case"sum":case"count":return"esriFieldTypeDouble";case"mode":{if(i){const{returnType:l}=i;return l?l==="string"?"esriFieldTypeString":"esriFieldTypeDouble":(v.error(new c(p,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}const s=r.find(l=>l.name===t);return s?s.type:(v.error(new c(p,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}}}function xe(e,r,i,t){return e.aggregate||(e.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:r.fixedBinLevel,fields:(r.fields??[]).map(n=>({...n.toJSON(),type:Q(n,i)}))},attributes:{}}),k(e.aggregate,t.attributes.fields),e}function he(e,r,i,t){var n;return e.aggregate||(e.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:U(r.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(U(r.clusterMaxSize)/64),fields:(n=r.fields??[])==null?void 0:n.map(s=>({...s.toJSON(),type:Q(s,i)}))}}),k(e.aggregate,t.attributes.fields),e}function b(e,r){return r.field?T(e,{...r,type:"field",field:r.field}):r.valueExpression?T(e,{...r,type:"expression",valueExpression:r.valueExpression}):{field:null,fieldIndex:null}}function T(e,r){switch(r.type){case"expression":{const i=r.valueExpression;if(!e.fields[i]){const t=e.indexCount++;e.fields[i]={...r,name:i,fieldIndex:t}}return{fieldIndex:e.fields[i].fieldIndex}}case"label-expression":{const i=JSON.stringify(r.label);if(!e.fields[i]){const t=e.indexCount++;e.fields[i]={...r,name:i,fieldIndex:t}}return{fieldIndex:e.fields[i].fieldIndex}}case"field":{const i=r.field;return r.target==="aggregate"&&e.fields[i]||(e.fields[i]={...r,name:i}),{field:i}}case"statistic":return e.fields[r.name]={...r},{field:r.name}}}function Te(e,r=!1){const i=new Array;let t=0;return i.push(Se(e,t++,r)),i}function A(e,r,i,t,n,s=!1){const l=T(e,{type:"label-expression",target:i,context:{mesh:!0},resultType:"string",label:{labelExpression:r.labelExpression,labelExpressionInfo:r.labelExpressionInfo?{expression:r.labelExpressionInfo.expression}:null,symbol:!!r.symbol,where:r.where}}),{fieldIndex:a}=l;return{...g(r,n,s),fieldIndex:a,target:i,index:t}}function ve(e,r,i){var f;const t="featureReduction"in r&&r.featureReduction;if(!t)return{fields:[],labels:[],matcher:null,rendererOverride:null};const n="aggregate",s=[];let l=null,a=j(r.geometryType),o=[],u=null;if(t)switch(t.type){case"selection":return v.error(new c(p,"Mapview does not support `selection` reduction type",t)),{fields:[],labels:[],matcher:null,rendererOverride:null};case"cluster":case"binning":if(s.push(...t.fields??[]),t.type==="cluster"?a="esriGeometryPoint":t.type==="binning"&&(a="esriGeometryPolygon"),t.renderer&&!((f=t.renderer.authoringInfo)!=null&&f.isAutoGenerated)){if(t.type==="cluster"){const{renderer:y}=ce(t.renderer,t,null);u=y}else u=t.renderer;const d=P(t.renderer,t);l=D(null,n,t.renderer,d,i),o=t&&t.labelsVisible&&t.labelingInfo||[]}else if(t.type==="cluster"){if(u=ye(s,r.renderer,t,null,!0),t.symbol){const d=P(u,t);l={type:"simple",symbol:g(t.symbol,d,i),symbologyType:d.symbologyType}}o=t&&t.labelsVisible&&t.labelingInfo||[]}}return we(e,s),{labels:Y(o,t.type==="binning"?"esriGeometryPolygon":a),matcher:l,fields:s,rendererOverride:u}}function Se(e,r,i=!1){const t={indexCount:0,fields:{}},n="featureReduction"in e&&e.featureReduction,s=n?"aggregate":"feature";if("sublayers"in e){const x={type:"subtype",subtypeField:e.subtypeField,renderers:{},symbologyType:m.DEFAULT},F={type:"subtype",mapping:{},target:"feature"},z={type:"subtype",classes:{}},Z={type:"symbol",target:"feature",aggregateFields:[],attributes:t,storage:F,mesh:{matcher:x,aggregateMatcher:null,labels:z,sortKey:null}},C=new Set;let ee=0;for(const{renderer:S,subtypeCode:E,labelingInfo:te,labelsVisible:ie}of e.sublayers){const J={symbologyType:m.DEFAULT,vvFlags:0,maxVVSize:0},I=D(t,s,S,J,i),w=G(t,s,S),$=ie&&te;if("visualVariables"in S&&S.visualVariables&&S.visualVariables.length)throw new c(p,"Visual variables are currently not supported for subtype layers");if(I.type==="dictionary")throw new c(p,"Dictionary renderer is not supported in subtype layers");if(I.type==="subtype")throw new c(p,"Nested subtype renderers is not supported");if(h(w)&&w.type==="subtype")throw new c(p,"Nested subtype storage is not supported");if(h(w)&&h(w.attributeMapping))throw new c(p,"Non-visual-variable attributes are not supported in subtype layers");if(I.type==="heatmap")throw new c(p,"Heatmaps are not supported in subtype layers");if(I.type==="pie-chart")throw new c(p,"Pie-charts are not supported in subtype layers");if(C.has(E))throw new c(p,"Subtype codes for sublayers must be unique");C.add(E),x.renderers[E]=I,F.mapping[E]=w,$&&(z.classes[E]=$.map(re=>A(t,re,"feature",ee++,J,i)))}return Z}if(e.renderer.type==="heatmap"&&K()==="raster"){const{radius:x,fieldOffset:F,field:z}=e.renderer;return{type:"heatmap",aggregateFields:[],attributes:t,target:s,storage:null,mesh:{radius:x,fieldOffset:F,field:b(t,{target:s,field:z,resultType:"numeric"}).field}}}const l=ve(t,e,i),a=j(e.geometryType),o=l.rendererOverride??e.renderer,u=P(o,n),f=D(t,s,o,u,i),d=G(t,s,o),y=Ie(t,e.orderBy,n),O=e.labelsVisible&&e.labelingInfo||[],W=Y(O,a);let B=0;const X=[...W.map(x=>A(t,x,"feature",B++,u,i)),...l.labels.map(x=>A(t,x,"aggregate",B++,u,i))];return{type:"symbol",target:s,attributes:t,aggregateFields:l.fields,storage:d,mesh:{matcher:f,labels:{type:"simple",classes:X},aggregateMatcher:l.matcher,sortKey:y}}}function Ee(e){var r;return((r=e.renderer)==null?void 0:r.type)==="heatmap"&&K()==="raster"?{type:"heatmap"}:{type:"symbol"}}function Ie(e,r,i){if(h(i)||H(r)||!r.length)return null;r.length>1&&v.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${r.length}. All but the first will be discarded`);const t=r[0],n=t.order==="ascending"?"asc":"desc";return t.field?{field:t.field,order:n}:t.valueExpression?{fieldIndex:T(e,{type:"expression",target:"feature",valueExpression:t.valueExpression,resultType:"numeric"}).fieldIndex,order:n}:(v.error(new c(p,"Expected to find a field or valueExpression for OrderByInfo",t)),null)}function we(e,r){const i={mesh:!0,storage:!0};for(const t of r){const{name:n,onStatisticField:s,onStatisticExpression:l,statisticType:a}=t;let o=null,u=null;const f="numeric",d="feature";l?u=T(e,{type:"expression",target:d,valueExpression:l.expression,resultType:f}).fieldIndex:o=T(e,{type:"field",target:d,field:s,resultType:f}).field,T(e,{type:"statistic",target:"aggregate",name:n,context:i,inField:o,inFieldIndex:u,statisticType:a})}}function G(e,r,i){let t;switch(i.type){case"simple":case"class-breaks":case"unique-value":case"dictionary":t={visualVariables:!0,attributes:null};break;default:t=fe(i).getStorageSpec(i)}return Fe(e,r,t,i)}function Fe(e,r,i,t){if(H(i))return null;const{visualVariables:n,attributes:s}=i;let l=null;n&&"visualVariables"in t&&(l=ze(e,r,t.visualVariables));const a=h(l)?4:0;let o=null;return h(s)&&(o=s.map((u,f)=>{const{field:d,fieldIndex:y}=b(e,{valueExpression:u.valueExpression,field:u.field,resultType:"numeric",target:r});return{binding:f+a,field:d,fieldIndex:y}})),{type:"simple",target:r,attributeMapping:o,vvMapping:l}}function ze(e,r,i){if(!i||!i.length)return[];const t={storage:!0},n="numeric";return pe(i).map(s=>{const l=ue(s.type),{field:a,fieldIndex:o}=b(e,{target:r,valueExpression:s.valueExpression,field:s.field,context:t,resultType:n});switch(s.type){case"size":return s.valueExpression==="$view.scale"?null:{type:"size",binding:l,field:a,fieldIndex:o,normalizationField:b(e,{target:r,field:s.normalizationField,context:t,resultType:n}).field,valueRepresentation:s.valueRepresentation??null};case"color":return{type:"color",binding:l,field:a,fieldIndex:o,normalizationField:b(e,{target:r,field:s.normalizationField,context:t,resultType:n}).field};case"opacity":return{type:"opacity",binding:l,field:a,fieldIndex:o,normalizationField:b(e,{target:r,field:s.normalizationField,context:t,resultType:n}).field};case"rotation":return{type:"rotation",binding:l,field:a,fieldIndex:o}}}).filter(s=>s)}function D(e,r,i,t,n=!1){const s=le(e,{indexCount:0,fields:{}});switch(i.type){case"simple":case"dot-density":return Ve(s,i,t,n);case"class-breaks":return Ne(s,r,i,t,n);case"unique-value":return Me(s,r,i,t,n);case"dictionary":return Le(s,i,t,n);case"heatmap":return Re(s,i,t,n);case"pie-chart":return Oe(s,i,t,n)}}function Ve(e,r,i,t=!1){const n=r.getSymbols(),s=n.length?n[0]:null;return{type:"simple",symbol:g(s,i,t),symbologyType:i.symbologyType}}function Oe(e,r,i,t=!1){const n=r.getSymbols(),s=n[0],l=n.length>1?n[1]:null;return{type:"pie-chart",markerSymbol:g(s,i,t),fillSymbol:g(l,i,t),symbologyType:i.symbologyType}}function Ne(e,r,i,t,n=!1){const s={mesh:!0,use:"renderer.field"},l=i.backgroundFillSymbol,{field:a,fieldIndex:o}=b(e,{target:r,field:i.field,valueExpression:i.valueExpression,resultType:"numeric",context:s}),u=i.normalizationType,f=u==="log"?"esriNormalizeByLog":u==="percent-of-total"?"esriNormalizeByPercentOfTotal":u==="field"?"esriNormalizeByField":null,d=i.classBreakInfos.map(y=>({symbol:g(y.symbol,t,n),min:y.minValue,max:y.maxValue})).sort((y,O)=>y.min-O.min);return{type:"interval",attributes:e.fields,field:a,fieldIndex:o,backgroundFillSymbol:g(l,t,n),defaultSymbol:g(i.defaultSymbol,t,n),intervals:d,normalizationField:i.normalizationField,normalizationTotal:i.normalizationTotal,normalizationType:f,isMaxInclusive:i.isMaxInclusive,symbologyType:t.symbologyType}}function Me(e,r,i,t,n=!1){const s=[],l=i.backgroundFillSymbol,a={target:r,context:{mesh:!0},resultType:"string"};if(i.field&&typeof i.field!="string")throw new c(p,"Expected renderer.field to be a string",i);const{field:o,fieldIndex:u}=b(e,{...a,field:i.field,valueExpression:i.valueExpression});for(const f of i.uniqueValueInfos)s.push({value:""+f.value,symbol:g(f.symbol,t,n)});return{type:"map",attributes:e.fields,field:o,fieldIndex:u,field2:b(e,{...a,field:i.field2}).field,field3:b(e,{...a,field:i.field3}).field,fieldDelimiter:i.fieldDelimiter,backgroundFillSymbol:g(l,t),defaultSymbol:g(i.defaultSymbol,t),map:s,symbologyType:t.symbologyType}}function Le(e,r,i,t=!1){return{type:"dictionary",config:r.config,fieldMap:r.fieldMap,scaleExpression:r.scaleExpression,url:r.url,symbolOptions:i,symbologyType:i.symbologyType}}function Re(e,r,i,t=!1){const n=r.getSymbols(),s=n.length?n[0]:null;return{type:"heatmap",symbol:g(s,i,t),symbologyType:i.symbologyType}}export{D as $,ot as F,P as w};
