import{m as f,cP as c}from"./index-fb3bdf4f.js";class i{constructor(t){if(this.next=null,!Array.isArray(t)){this.data=t;return}this.data=t[0];let e=this;for(let r=1;r<t.length;r++)e.next=new i([t[r]]),e=e.next}*values(){let t=this;for(;t;)yield t.data,t=t.next}forEach(t){let e=this;for(;e;)t(e.data),e=e.next}find(t){var e;return t(this.data)?this:(e=this.next)==null?void 0:e.find(t)}max(t,e=this){const r=t(this.data)>t(e.data)?this:e;return this.next?this.next.max(t,r):r}remove(t,e=null){var r;return this===t?e?(e.next=this.next,e):this.next:((r=this.next)==null?void 0:r.remove(t,this))??null}get last(){return this.next?this.next.last:this}}class g{constructor(t){this._head=null,t!=null&&(this._head=new i(t))}get head(){return this._head}maxAvailableSpace(){if(this._head==null)return 0;const t=this._head.max(e=>e.end-e.start);return t.data.end-t.data.start}firstFit(t){if(this._head==null)return null;let e=null,r=this._head;for(;r;){const a=r.data.end-r.data.start;if(a===t)return e?e.next=r.next:this._head=r.next,r.data.start;if(a>t){const s=r.data.start;return r.data.start+=t,s}e=r,r=r.next}return null}free(t,e){const r=t+e;if(this._head==null){const n=new i({start:t,end:r});this._head=n;return}if(r<=this._head.data.start){if(r===this._head.data.start){this._head.data.start-=e;return}const n=new i({start:t,end:r});n.next=this._head,this._head=n;return}let a=this._head,s=a.next;for(;s;){if(s.data.start>=r){if(a.data.end===t){if(a.data.end+=e,a.data.end===s.data.start){const _=s.data.end-s.data.start;a.data.end+=_,a.next=s.next;return}return}if(s.data.start===r){s.data.start-=e;return}const n=new i({start:t,end:r});n.next=a.next,a.next=n;return}a=s,s=s.next}if(t===a.data.end){a.data.end+=e;return}const o=new i({start:t,end:r});a.next=o}}const d=f("esri-2d-log-allocations");class l{constructor(t,e){this._array=t,this._pool=e}get array(){return this._array}get length(){return this._array.length}static create(t,e){const r=e.acquire(t);return new l(r,e)}expand(t){const e=this._pool.acquire(t);e.set(this._array),this._pool.release(this._array),this._array=e}destroy(){this._pool.release(this._array)}set(t,e){this._array.set(t._array,e)}slice(){const t=this._pool.acquire(this._array.byteLength);return t.set(this._array),new l(t,this._pool)}}class h{constructor(){this._data=new ArrayBuffer(h.BYTE_LENGTH),this._freeList=new g({start:0,end:this._data.byteLength})}static get BYTE_LENGTH(){return 64e6}get buffer(){return this._data}allocate(t){const e=this._freeList.firstFit(t);return e==null?null:new Uint32Array(this._data,e,t/Uint32Array.BYTES_PER_ELEMENT)}free(t){this._freeList.free(t.byteOffset,t.byteLength)}}class y{constructor(){this._bytesAllocated=0,this._pages=[],this._pagesByBuffer=new Map,this._addPage()}destroy(){this._pages=[],this._pagesByBuffer=null}get _bytesTotal(){return this._pages.length*h.BYTE_LENGTH}acquire(t){if(this._bytesAllocated+=t,d&&console.log(`Allocating ${t}, (${this._bytesAllocated} / ${this._bytesTotal})`),t>h.BYTE_LENGTH)return new Uint32Array(t/Uint32Array.BYTES_PER_ELEMENT);for(const e of this._pages){const r=e.allocate(t);if(r!=null)return r}return c(this._addPage().allocate(t),"Expected to allocate page")}release(t){this._bytesAllocated-=t.byteLength,d&&console.log(`Freeing ${t.byteLength}, (${this._bytesAllocated} / ${this._bytesTotal})`);const e=this._pagesByBuffer.get(t.buffer);e&&e.free(t)}_addPage(){const t=new h;return this._pages.push(t),this._pagesByBuffer.set(t.buffer,t),t}}export{y as B,g as F,i as L,l as T};
