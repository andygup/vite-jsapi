import{E as v,dj as lt,b9 as k,ge as H,_ as ut,gf as ct,gb as Y,ce as dt,gg as ht,a9 as ft}from"./index-37fc1c1b.js";import{t as U}from"./quantizationUtils-fa03eddf.js";import{I as X}from"./ItemCache-67dfd71e.js";import{W as gt}from"./WhereClause-fb72a7f9.js";import{p as q,g as mt,i as pt,c as W,a as K,b as yt,d as Ft,e as xt,f as Vt,r as _t,h as It,j as Ct,k as bt}from"./utils-33915929.js";import{p as J}from"./projectionSupport-35bf5dae.js";import{c as B,g as j,t as tt}from"./utils-dd453c99.js";class At{constructor(e,t){this._cache=new X(e),this._invalidCache=new X(t)}get(e,t){const s=`${t.uid}:${e}`,i=this._cache.get(s);if(i)return i;if(this._invalidCache.get(s)!==void 0)return null;try{const a=gt.create(e,t);return this._cache.put(s,a),a}catch{return this._invalidCache.put(s,null),null}}}const L=new At(50,500),T="feature-store:unsupported-query",it=" as ",St=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function qt(u,e){if(!e)return!0;const t=L.get(e,u);if(!t)throw new v(T,"invalid SQL expression",{where:e});if(!t.isStandardized)throw new v(T,"where clause is not standard",{where:e});const s=t.fieldNames;return Q(u,s,"where clause contains missing fields"),!0}function Bt(u,e,t){if(!e)return!0;const s=L.get(e,u);if(!s)throw new v(T,"invalid SQL expression",{having:e});if(!s.isAggregate)throw new v(T,"having does not contain a valid aggregate function",{having:e});const i=s.fieldNames;if(Q(u,i,"having contains missing fields"),!s.getExpressions().every(a=>{var c;const{aggregateType:o,field:r}=a,l=(c=u.get(r))==null?void 0:c.name;return t.some(h=>{var y;const{onStatisticField:f,statisticType:d}=h;return((y=u.get(f))==null?void 0:y.name)===l&&d.toLowerCase().trim()===o})}))throw new v(T,"expressions in having should also exist in outStatistics",{having:e});return!0}function P(u,e){return u?L.get(u,e):null}function Q(u,e,t,s=!0){const i=[];for(const n of e)if(!(n==="*"||u.has(n)))if(!s)i.push(n);else{const a=nt(n);try{const o=P(a,u);if(!o)throw new v(T,"invalid SQL expression",{where:a});if(!o.isStandardized)throw new v(T,"expression is not standard",{clause:o});Q(u,o.fieldNames,"expression contains missing fields")}catch(o){const r=o&&o.details;if(r&&(r.clause||r.where))throw o;r&&r.missingFields?i.push(...r.missingFields):i.push(n)}}if(i.length)throw new v(T,t,{missingFields:i})}function nt(u){return u.split(it)[0]}function Dt(u){return u.split(it)[1]}function jt(u,e){const t=e.get(u);return t?!St.has(t.type):!1}class z{constructor(e,t,s){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=s,this.featureAdapter=t;const i=e.outFields;if(i&&!i.includes("*")){this.outFields=i;let n=0;for(const a of i){const o=nt(a),r=this.fieldsIndex.get(o),l=r?null:P(o,s),c=r?r.name:Dt(a)||`FIELD_EXP_${n++}`;this._fieldDataCache.set(a,{alias:c,clause:l})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,s){var a;const i=s?s.name:t;let n=null;return this._fieldDataCache.has(i)?n=(a=this._fieldDataCache.get(i))==null?void 0:a.clause:s||(n=P(t,this.fieldsIndex),this._fieldDataCache.set(i,{alias:i,clause:n})),s?this.featureAdapter.getAttribute(e,i):n==null?void 0:n.calculateValue(e,this.featureAdapter)}getDataValue(e,t){const s=t.normalizationType,i=t.normalizationTotal;let n=t.field&&this.getFieldValue(e,t.field,this.fieldsIndex.get(t.field));if(t.field2&&(n=`${q(n)}${t.fieldDelimiter}${q(this.getFieldValue(e,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(n=`${n}${t.fieldDelimiter}${q(this.getFieldValue(e,t.field3,this.fieldsIndex.get(t.field3)))}`)),s&&Number.isFinite(n)){const a=s==="field"&&t.normalizationField?this.getFieldValue(e,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;n=mt(n,s,a,i)}return n}getExpressionValue(e,t,s,i){const n={attributes:this.featureAdapter.getAttributes(e),layer:{fields:this.fieldsIndex.fields}},a=i.createExecContext(n,s);return i.executeFunction(t,a)}getExpressionValues(e,t,s,i){const n={fields:this.fieldsIndex.fields};return e.map(a=>{const o={attributes:this.featureAdapter.getAttributes(a),layer:n},r=i.createExecContext(o,s);return i.executeFunction(t,r)})}validateItem(e,t){var s,i;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:P(t,this.fieldsIndex)}),((i=(s=this._fieldDataCache.get(t))==null?void 0:s.clause)==null?void 0:i.testFeature(e,this.featureAdapter))??!1}validateItems(e,t){var s,i;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:P(t,this.fieldsIndex)}),((i=(s=this._fieldDataCache.get(t))==null?void 0:s.clause)==null?void 0:i.testSet(e,this.featureAdapter))??!1}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const s={};for(const i of t){const{alias:n,clause:a}=this._fieldDataCache.get(i);s[n]=a?a.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,n)}return s}_processAttributesForDistinctValues(e){if(e==null||!this.returnDistinctValues)return e;const t=this.outFields,s=[];if(t)for(const a of t){const{alias:o}=this._fieldDataCache.get(a);s.push(e[o])}else for(const a in e)s.push(e[a]);const i=`${(t||["*"]).join(",")}=${s.join(",")}`;let n=this._returnDistinctMap.get(i)||0;return this._returnDistinctMap.set(i,++n),n>1?null:e}}function vt(u,e,t){return{objectId:u,target:e,distance:t,type:"vertex"}}function Tt(u,e,t,s,i,n=!1){return{objectId:u,target:e,distance:t,type:"edge",start:s,end:i,draped:n}}class Lt{constructor(e,t,s){this.items=e,this.query=t,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.fieldsIndex=s.fieldsIndex,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.featureAdapter=s.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new z(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:s,outStatistics:i}=this.query;if(!!!(t==null?void 0:t.length))return 1;const o=new Map,r=new Map,l=new Set;for(const c of i){const{statisticType:h}=c,f=h!=="exceedslimit"?c.onStatisticField:void 0;if(!r.has(f)){const g=[];for(const y of t){const _=this._getAttributeValues(e,y,o);g.push(_)}r.set(f,this._calculateUniqueValues(g,e.returnDistinctValues))}const d=r.get(f);for(const g in d){const{data:y,items:_}=d[g],F=y.join(",");(!s||e.validateItems(_,s))&&l.add(F)}}return l.size}async createQueryResponse(){let e;if(this.query.outStatistics?this.query.outStatistics.some(s=>s.statisticType==="exceedslimit")?e=this._createExceedsLimitQueryResponse(this.query):e=await this._createStatisticsQueryResponse(this.query):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;lt(this.query.outSR)&&!k(t.spatialReference,this.query.outSR)?e.queryGeometry=B({spatialReference:this.query.outSR,...J(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=B({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t){const s=this.featureAdapter,i=et(this.hasZ,this.hasM),{point:n,mode:a}=e,o=typeof e.distance=="number"?e.distance:e.distance.x,r=typeof e.distance=="number"?e.distance:e.distance.y,l={candidates:[]},c=this.geometryType==="esriGeometryPolygon",h=this._getPointCreator(a,this.spatialReference,t),f=new st(null,0),d=new st(null,0),g={x:0,y:0,z:0};for(const y of this.items){const _=s.getGeometry(y);if(_==null)continue;const{coords:F,lengths:I}=_;if(f.coords=F,d.coords=F,e.types&M.EDGE){let x=0;for(let V=0;V<I.length;V++){const p=I[V];for(let m=0;m<p;m++,x+=i){const C=f;if(C.coordsIndex=x,m!==p-1){const b=d;b.coordsIndex=x+i;const N=g;Et(g,n,C,b);const A=(n.x-N.x)/o,S=(n.y-N.y)/r,E=A*A+S*S;E<=1&&l.candidates.push(Tt(s.getObjectId(y),h(N),Math.sqrt(E),h(C),h(b)))}}}}if(e.types&M.VERTEX){const x=c?F.length-i:F.length;for(let V=0;V<x;V+=i){const p=f;p.coordsIndex=V;const m=(n.x-p.x)/o,C=(n.y-p.y)/r,b=m*m+C*C;b<=1&&l.candidates.push(vt(s.getObjectId(y),h(p),Math.sqrt(b)))}}}return l.candidates.sort((y,_)=>y.distance-_.distance),l}_getPointCreator(e,t,s){const i=s!=null&&!k(t,s)?o=>J(o,t,s):o=>o,{hasZ:n}=this,a=0;return e==="3d"?n?({x:o,y:r,z:l})=>i({x:o,y:r,z:l}):({x:o,y:r})=>i({x:o,y:r,z:a}):({x:o,y:r})=>i({x:o,y:r})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:n,normalizationTotal:a,minValue:o,maxValue:r,scale:l}=e,c=this.fieldsIndex.isDateField(t),h=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:n,normalizationTotal:a,scale:l}),f=pt({normalizationType:n,normalizationField:i,minValue:o,maxValue:r}),d=this.fieldsIndex.get(t),g={value:.5,fieldType:d==null?void 0:d.type},y=H(d)?W({values:h,supportsNullCount:f,percentileParams:g}):K({values:h,minValue:o,maxValue:r,useSampleStdDev:!n,supportsNullCount:f,percentileParams:g});return yt(y,c)}async createUniqueValuesResponse(e){const{field:t,valueExpression:s,domains:i,returnAllCodedValues:n,scale:a}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:s,scale:a}),r=Ft(o);return xt(r,i,n,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:n,normalizationTotal:a,classificationMethod:o,standardDeviationInterval:r,minValue:l,maxValue:c,numClasses:h,scale:f}=e,d=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:n,normalizationTotal:a,scale:f}),g=Vt(d,{field:t,normalizationField:i,normalizationType:n,normalizationTotal:a,classificationMethod:o,standardDeviationInterval:r,minValue:l,maxValue:c,numClasses:h});return _t(g,o)}async createHistogramResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:n,normalizationTotal:a,classificationMethod:o,standardDeviationInterval:r,minValue:l,maxValue:c,numBins:h,scale:f}=e,d=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:n,normalizationTotal:a,scale:f});return It(d,{field:t,normalizationField:i,normalizationType:n,normalizationTotal:a,classificationMethod:o,standardDeviationInterval:r,minValue:l,maxValue:c,numBins:h})}_sortFeatures(e,t,s){if(e.length>1&&t&&t.length)for(const i of t.reverse()){const n=i.split(" "),a=n[0],o=this.fieldsIndex.get(a),r=n[1]?n[1].toLowerCase()==="desc":!1,l=Ct(o==null?void 0:o.type,r);e.sort((c,h)=>{const f=s(c,a,o),d=s(h,a,o);return l(f,d)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:s,hasM:i,hasZ:n,objectIdField:a,spatialReference:o}=this,{outFields:r,outSR:l,quantizationParameters:c,resultRecordCount:h,resultOffset:f,returnZ:d,returnM:g}=e,y=h!=null?t.length>(f||0)+h:!1,_=r&&(r.includes("*")?[...this.fieldsIndex.fields]:r.map(F=>this.fieldsIndex.get(F)));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:_,geometryType:s,hasM:i&&g,hasZ:n&&d,objectIdFieldName:a,spatialReference:B(l||o),transform:c&&U(c)||null}}_createFeatures(e,t){const s=new z(e,this.featureAdapter,this.fieldsIndex),{hasM:i,hasZ:n}=this,{orderByFields:a,quantizationParameters:o,returnGeometry:r,returnCentroid:l,maxAllowableOffset:c,resultOffset:h,resultRecordCount:f,returnZ:d=!1,returnM:g=!1}=e,y=n&&d,_=i&&g;let F=[],I=0;const x=[...t];if(this._sortFeatures(x,a,(p,m,C)=>s.getFieldValue(p,m,C)),!r&&!l)for(const p of x){const m=s.getAttributes(p);m&&(F[I++]={attributes:m})}else{const p=U(o)??void 0;if(r&&!l)for(const m of x)F[I++]={attributes:s.getAttributes(m),geometry:j(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(m),c,p,y,_)};else if(!r&&l)for(const m of x)F[I++]={attributes:s.getAttributes(m),centroid:tt(this,this.featureAdapter.getCentroid(m,this),p)};else for(const m of x)F[I++]={attributes:s.getAttributes(m),centroid:tt(this,this.featureAdapter.getCentroid(m,this),p),geometry:j(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(m),c,p,y,_)}}const V=h||0;if(f!=null){const p=V+f;F=F.slice(V,Math.min(F.length,p))}return F}_createExceedsLimitQueryResponse(e){let t=!1,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY;for(const a of e.outStatistics??[])if(a.statisticType==="exceedslimit"){s=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,i=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,n=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>s;else if(this.items.length>i)t=!0;else{const a=et(this.hasZ,this.hasM),o=this.featureAdapter;t=this.items.reduce((l,c)=>{const h=o.getGeometry(c);return l+(h!=null&&h.coords.length||0)},0)/a>n}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},s=[],i=new Map,n=new Map,a=new Map,o=new Map,r=new z(e,this.featureAdapter,this.fieldsIndex),l=e.outStatistics,{groupByFieldsForStatistics:c,having:h,orderByFields:f}=e,d=c&&c.length,g=!!d,y=g?c[0]:null,_=g&&!this.fieldsIndex.get(y);for(const I of l??[]){const{outStatisticFieldName:x,statisticType:V}=I,p=I,m=V!=="exceedslimit"?I.onStatisticField:void 0,C=V==="percentile_disc"||V==="percentile_cont",b=V==="EnvelopeAggregate"||V==="CentroidAggregate"||V==="ConvexHullAggregate",N=g&&d===1&&(m===y||_)&&V==="count";if(g){if(!a.has(m)){const S=[];for(const E of c){const G=this._getAttributeValues(r,E,i);S.push(G)}a.set(m,this._calculateUniqueValues(S,b?!1:r.returnDistinctValues))}const A=a.get(m);for(const S in A){const{count:E,data:G,items:Z,itemPositions:at}=A[S],O=G.join(",");if(!h||r.validateItems(Z,h)){const w=o.get(O)||{attributes:{}};if(b){w.aggregateGeometries||(w.aggregateGeometries={});const{aggregateGeometries:D,outStatisticFieldName:R}=await this._getAggregateGeometry(p,Z);w.aggregateGeometries[R]=D}else{let D=null;if(N)D=E;else{const R=this._getAttributeValues(r,m,i),$=at.map(rt=>R[rt]);D=C&&"statisticParameters"in p?this._getPercentileValue(p,$):this._getStatisticValue(p,$,null,r.returnDistinctValues)}w.attributes[x]=D}let ot=0;c.forEach((D,R)=>w.attributes[this.fieldsIndex.get(D)?D:`EXPR_${++ot}`]=G[R]),o.set(O,w)}}}else if(b){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:A,outStatisticFieldName:S}=await this._getAggregateGeometry(p,this.items);t.aggregateGeometries[S]=A}else{const A=this._getAttributeValues(r,m,i);t.attributes[x]=C&&"statisticParameters"in p?this._getPercentileValue(p,A):this._getStatisticValue(p,A,n,r.returnDistinctValues)}s.push({name:x,alias:x,type:"esriFieldTypeDouble"})}const F=g?Array.from(o.values()):[t];return this._sortFeatures(F,f,(I,x)=>I.attributes[x]),{fields:s,features:F}}async _getAggregateGeometry(e,t){const s=await ut(()=>import("./geometryEngineJSON-cc7c26cb.js"),["assets/geometryEngineJSON-cc7c26cb.js","assets/geometryEngineBase-2fe41455.js","assets/geometryEngineJSON-17d1a0f4.js","assets/json-9ae8d6f8.js"]),{statisticType:i,outStatisticFieldName:n}=e,{featureAdapter:a,spatialReference:o,geometryType:r,hasZ:l,hasM:c}=this,h=t.map(g=>j(r,l,c,a.getGeometry(g))),f=s.convexHull(o,h,!0)[0],d={aggregateGeometries:null,outStatisticFieldName:null};if(i==="EnvelopeAggregate"){const g=f?ct(f):Y(s.union(o,h));d.aggregateGeometries={...g,spatialReference:o},d.outStatisticFieldName=n||"extent"}else if(i==="CentroidAggregate"){const g=f?dt(f):ht(Y(s.union(o,h)));d.aggregateGeometries={x:g[0],y:g[1],spatialReference:o},d.outStatisticFieldName=n||"centroid"}else i==="ConvexHullAggregate"&&(d.aggregateGeometries=f,d.outStatisticFieldName=n||"convexHull");return d}_getStatisticValue(e,t,s,i){const{onStatisticField:n,statisticType:a}=e;let o=null;return s!=null&&s.has(n)?o=s.get(n):o=H(this.fieldsIndex.get(n))?W({values:t,returnDistinct:i}):K({values:i?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(n,o),o[a==="var"?"variance":a]}_getPercentileValue(e,t){const{onStatisticField:s,statisticParameters:i,statisticType:n}=e,{value:a,orderBy:o}=i,r=this.fieldsIndex.get(s),l={value:a,orderBy:o,fieldType:r==null?void 0:r.type,isDiscrete:n==="percentile_disc"};return bt(t,l)}_getAttributeValues(e,t,s){if(s.has(t))return s.get(t);const i=this.fieldsIndex.get(t),n=this.items.map(a=>e.getFieldValue(a,t,i));return s.set(t,n),n}_getAttributeDataValues(e,t){return this.items.map(s=>e.getDataValue(s,{field:t.field,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:t.normalizationField,normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal}))}async _getAttributeExpressionValues(e,t,s){const{arcadeUtils:i}=await ft(),n=i.createFunction(t),a=s&&i.getViewInfo(s);return e.getExpressionValues(this.items,n,a,i)}_calculateUniqueValues(e,t){const s={},i=this.items,n=i.length;for(let a=0;a<n;a++){const o=i[a],r=[];for(const c of e)r.push(c[a]);const l=r.join(",");s[l]==null?s[l]={count:1,data:r,items:[o],itemPositions:[a]}:(t||s[l].count++,s[l].items.push(o),s[l].itemPositions.push(a))}return s}async _getDataValues(e){const t=new z(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:i,normalizationField:n,normalizationType:a,normalizationTotal:o,scale:r}=e,l=s?{viewingMode:"map",scale:r,spatialReference:this.query.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(t,s,l):this._getAttributeDataValues(t,{field:i,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:n,normalizationType:a,normalizationTotal:o})}}function Et(u,e,t,s){const i=s.x-t.x,n=s.y-t.y,a=e.x-t.x,o=e.y-t.y,r=i*i+n*n,l=a*i+o*n,c=Math.min(1,Math.max(0,l/r));u.x=t.x+i*c,u.y=t.y+n*c}function et(u,e){return u?e?4:3:e?3:2}var M;(function(u){u[u.NONE=0]="NONE",u[u.EDGE=1]="EDGE",u[u.VERTEX=2]="VERTEX"})(M||(M={}));class st{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}export{Lt as Q,M as S,qt as a,Bt as b,P as g,jt as h,Q as v};
