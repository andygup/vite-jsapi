import{bw as B,bz as U,L as X,bB as D,dC as F,dM as W,dN as Z,N as E,bZ as G,bR as k,a3 as I,a_ as A,cf as J,dO as H,a as K}from"./index-989909ce.js";import{r as j,o as q,i as R,s as T}from"./normalizeUtilsCommon-8a86e794.js";async function Q(t,s,f,n){const e=B(t),c=s[0].spatialReference,l={...n,query:{...e.query,f:"json",sr:JSON.stringify(c),target:JSON.stringify({geometryType:U(s[0]),geometries:s}),cutter:JSON.stringify(f)}},o=await X(e.path+"/cut",l),{cutIndexes:u,geometries:y=[]}=o.data;return{cutIndexes:u,geometries:y.map(h=>{const d=D(h);return d.spatialReference=c,d})}}async function V(t,s,f){const n=typeof t=="string"?F(t):t,e=s[0].spatialReference,c=U(s[0]),l={...f,query:{...n.query,f:"json",sr:e.wkid??JSON.stringify(e),geometries:JSON.stringify(W(s))}},{data:o}=await X(n.path+"/simplify",l);return Z(o.geometries,c,e)}const _=E.getLogger("esri.geometry.support.normalizeUtils");function Y(t){return t.type==="polygon"}function tt(t){return t[0].type==="polygon"}function et(t){return t[0].type==="polyline"}function st(t,s){if(!(t instanceof I||t instanceof J)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw _.error(e),new K(e)}const f=q(t),n=[];for(const e of f){const c=[];n.push(c),c.push([e[0][0],e[0][1]]);for(let l=0;l<e.length-1;l++){const o=e[l][0],u=e[l][1],y=e[l+1][0],h=e[l+1][1],d=Math.sqrt((y-o)*(y-o)+(h-u)*(h-u)),a=(h-u)/d,m=(y-o)/d,p=d/s;if(p>1){for(let b=1;b<=p-1;b++){const N=b*s,r=m*N+o,i=a*N+u;c.push([r,i])}const w=(d+Math.floor(p-1)*s)/2,L=m*w+o,v=a*w+u;c.push([L,v])}c.push([y,h])}}return Y(t)?new J({rings:n,spatialReference:t.spatialReference}):new I({paths:n,spatialReference:t.spatialReference})}function P(t,s,f){if(s){const n=st(t,1e6);t=H(n,!0)}return f&&(t=T(t,f)),t}function C(t,s,f){if(Array.isArray(t)){const n=t[0];if(n>s){const e=R(n,s);t[0]=n+e*(-2*s)}else if(n<f){const e=R(n,f);t[0]=n+e*(-2*f)}}else{const n=t.x;if(n>s){const e=R(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<f){const e=R(n,f);t=t.clone().offset(e*(-2*f),0)}}return t}function nt(t,s){let f=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],c=s.geometries[n],l=q(c);for(let o=0;o<l.length;o++){const u=l[o];u.some(y=>{if(y[0]<180)return!0;{let h=0;for(let a=0;a<u.length;a++){const m=u[a][0];h=m>h?m:h}h=Number(h.toFixed(9));const d=-360*R(h,180);for(let a=0;a<u.length;a++){const m=c.getPoint(o,a);c.setPoint(o,a,m.clone().offset(d,0))}return!0}})}if(e===f){if(tt(t))for(const o of q(c))t[e]=t[e].addRing(o);else if(et(t))for(const o of q(c))t[e]=t[e].addPath(o)}else f=e,t[e]=c}return t}async function ot(t,s,f){if(!Array.isArray(t))return ot([t],s);s&&typeof s!="string"&&_.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:(s==null?void 0:s.url)??G.geometryServiceUrl;let e,c,l,o,u,y,h,d,a=0;const m=[],p=[];for(const r of t)if(r!=null)if(e||(e=r.spatialReference,c=k(e),l=e.isWebMercator,y=l?102100:4326,o=j[y].maxX,u=j[y].minX,h=j[y].plus180Line,d=j[y].minus180Line),c)if(r.type==="mesh")p.push(r);else if(r.type==="point")p.push(C(r.clone(),o,u));else if(r.type==="multipoint"){const i=r.clone();i.points=i.points.map(g=>C(g,o,u)),p.push(i)}else if(r.type==="extent"){const i=r.clone()._normalize(!1,!1,c);p.push(i.rings?new J(i):i)}else if(r.extent){const i=r.extent,g=R(i.xmin,u)*(2*o);let x=g===0?r.clone():T(r.clone(),g);i.offset(g,0),i.intersects(h)&&i.xmax!==o?(a=i.xmax>a?i.xmax:a,x=P(x,l),m.push(x),p.push("cut")):i.intersects(d)&&i.xmin!==u?(a=i.xmax*(2*o)>a?i.xmax*(2*o):a,x=P(x,l,360),m.push(x),p.push("cut")):p.push(x)}else p.push(r.clone());else p.push(r);else p.push(r);let w=R(a,o),L=-90;const v=w,b=new I;for(;w>0;){const r=360*w-180;b.addPath([[r,L],[r,-1*L]]),L*=-1,w--}if(m.length>0&&v>0){const r=nt(m,await Q(n,m,b,f)),i=[],g=[];for(let $=0;$<p.length;$++){const S=p[$];if(S!=="cut")g.push(S);else{const O=r.shift(),M=t[$];M!=null&&M.type==="polygon"&&M.rings&&M.rings.length>1&&O.rings.length>=M.rings.length?(i.push(O),g.push("simplify")):g.push(l?A(O):O)}}if(!i.length)return g;const x=await V(n,i,f),z=[];for(let $=0;$<g.length;$++){const S=g[$];S!=="simplify"?z.push(S):z.push(l?A(x.shift()):x.shift())}return z}const N=[];for(let r=0;r<p.length;r++){const i=p[r];if(i!=="cut")N.push(i);else{const g=m.shift();N.push(l===!0?A(g):g)}}return N}function ft(t,s){const f=k(s);if(f){const[n,e]=f.valid,c=e-n;if(t<n)for(;t<n;)t+=c;if(t>e)for(;t>e;)t-=c}return t}export{ot as b,ft as v};
