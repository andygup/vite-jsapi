import{h7 as R,aB as S,bt as y,gF as p,h8 as B}from"./index-14eace40.js";import{c as F}from"./quat-8156eb50.js";import{c as P,a as T,d as C,r as U,b as q}from"./I3SBinaryReader-796f456a.js";import{f as z,c as x}from"./vec3f32-ec4c3c20.js";import{P as D,a as O,b as j}from"./PointCloudUniqueValueRenderer-94d5a437.js";import"./vec4-3dd523e8.js";import"./VertexAttribute-8238ac80.js";import"./LegendOptions-9c19f57a.js";import"./ColorStop-7bf697e4.js";function _(c,e,l,o){const{rendererJSON:i,isRGBRenderer:b}=c;let n=null,f=null;if(e&&b)n=e;else if(e&&(i==null?void 0:i.type)==="pointCloudUniqueValueRenderer"){f=D.fromJSON(i);const t=f.colorUniqueValueInfos;n=new Uint8Array(o*3);const a=I(f.fieldTransformType);for(let r=0;r<o;r++){const d=(a?a(e[r]):e[r])+"";for(let s=0;s<t.length;s++)if(t[s].values.includes(d)){n[r*3]=t[s].color.r,n[r*3+1]=t[s].color.g,n[r*3+2]=t[s].color.b;break}}}else if(e&&(i==null?void 0:i.type)==="pointCloudStretchRenderer"){f=O.fromJSON(i);const t=f.stops;n=new Uint8Array(o*3);const a=I(f.fieldTransformType);for(let r=0;r<o;r++){const u=a?a(e[r]):e[r],d=t.length-1;if(u<t[0].value)n[r*3]=t[0].color.r,n[r*3+1]=t[0].color.g,n[r*3+2]=t[0].color.b;else if(u>=t[d].value)n[r*3]=t[d].color.r,n[r*3+1]=t[d].color.g,n[r*3+2]=t[d].color.b;else for(let s=1;s<t.length;s++)if(u<t[s].value){const h=(u-t[s-1].value)/(t[s].value-t[s-1].value);n[r*3]=t[s].color.r*h+t[s-1].color.r*(1-h),n[r*3+1]=t[s].color.g*h+t[s-1].color.g*(1-h),n[r*3+2]=t[s].color.b*h+t[s-1].color.b*(1-h);break}}}else if(e&&(i==null?void 0:i.type)==="pointCloudClassBreaksRenderer"){f=j.fromJSON(i);const t=f.colorClassBreakInfos;n=new Uint8Array(o*3);const a=I(f.fieldTransformType);for(let r=0;r<o;r++){const u=a?a(e[r]):e[r];for(let d=0;d<t.length;d++)if(u>=t[d].minValue&&u<=t[d].maxValue){n[r*3]=t[d].color.r,n[r*3+1]=t[d].color.g,n[r*3+2]=t[d].color.b;break}}}else n=new Uint8Array(o*3).fill(255);if(l&&f&&f.colorModulation){const t=f.colorModulation.minValue,a=f.colorModulation.maxValue,r=.3;for(let u=0;u<o;u++){const d=l[u],s=d>=a?1:d<=t?r:r+(1-r)*(d-t)/(a-t);n[u*3]=s*n[u*3],n[u*3+1]=s*n[u*3+1],n[u*3+2]=s*n[u*3+2]}}return n}function V(c,e){if(c.encoding==null||c.encoding===""){const l=P(e,c);if(l.vertexAttributes.position==null)return;const o=T(e,l.vertexAttributes.position),i=l.header.fields,b=[i.offsetX,i.offsetY,i.offsetZ],n=[i.scaleX,i.scaleY,i.scaleZ],f=o.length/3,t=new Float64Array(f*3);for(let a=0;a<f;a++)t[a*3]=o[a*3]*n[0]+b[0],t[a*3+1]=o[a*3+1]*n[1]+b[1],t[a*3+2]=o[a*3+2]*n[2]+b[2];return t}if(c.encoding==="lepcc-xyz")return C(e).result}function v(c,e,l){return c!=null&&c.attributeInfo.useElevation?e?$(e,l):null:c!=null&&c.attributeInfo.storageInfo?U(c.attributeInfo.storageInfo,c.buffer,l):null}function $(c,e){const l=new Float64Array(e);for(let o=0;o<e;o++)l[o]=c[o*3+2];return l}function E(c,e,l,o,i){const b=c.length/3;let n=0;for(let f=0;f<b;f++){let t=!0;for(let a=0;a<o.length&&t;a++){const{filterJSON:r}=o[a],u=i[a].values[f];switch(r.type){case"pointCloudValueFilter":{const d=r.mode==="exclude";r.values.includes(u)===d&&(t=!1);break}case"pointCloudBitfieldFilter":{const d=k(r.requiredSetBits),s=k(r.requiredClearBits);((u&d)!==d||u&s)&&(t=!1);break}case"pointCloudReturnFilter":{const d=u&15,s=u>>>4&15,h=s>1,w=d===1,g=d===s;let A=!1;for(const m of r.includedReturns)if(m==="last"&&g||m==="firstOfMany"&&w&&h||m==="lastOfMany"&&g&&h||m==="single"&&!h){A=!0;break}A||(t=!1);break}}}t&&(l[n]=f,c[n*3]=c[f*3],c[n*3+1]=c[f*3+1],c[n*3+2]=c[f*3+2],e[n*3]=e[f*3],e[n*3+1]=e[f*3+1],e[n*3+2]=e[f*3+2],n++)}return n}function I(c){switch(c){default:case null:case"none":return e=>e;case"low-four-bit":return e=>e&15;case"high-four-bit":return e=>(e&240)>>4;case"absolute-value":return e=>Math.abs(e);case"modulo-ten":return e=>e%10}}function k(c){let e=0;for(const l of c||[])e|=1<<l;return e}class G{transform(e){const l=this._transform(e),o=[l.points.buffer,l.rgb.buffer];l.pointIdFilterMap!=null&&o.push(l.pointIdFilterMap.buffer);for(const i of l.attributes)"buffer"in i.values&&R(i.values.buffer)&&i.values.buffer!==l.rgb.buffer&&o.push(i.values.buffer);return Promise.resolve({result:l,transferList:o})}_transform(e){const l=V(e.schema,e.geometryBuffer);let o=l.length/3,i=null;const b=new Array,n=v(e.primaryAttributeData,l,o);e.primaryAttributeData!=null&&n&&b.push({attributeInfo:e.primaryAttributeData.attributeInfo,values:n});const f=v(e.modulationAttributeData,l,o);e.modulationAttributeData!=null&&f&&b.push({attributeInfo:e.modulationAttributeData.attributeInfo,values:f});let t=_(e.rendererInfo,n,f,o);if(e.filterInfo&&e.filterInfo.length>0&&e.filterAttributesData!=null){const r=e.filterAttributesData.filter(S).map(u=>{const d=v(u,l,o),s={attributeInfo:u.attributeInfo,values:d};return b.push(s),s});i=new Uint32Array(o),o=E(l,t,i,e.filterInfo,r)}for(const r of e.userAttributesData){const u=v(r,l,o);b.push({attributeInfo:r.attributeInfo,values:u})}o*3<t.length&&(t=new Uint8Array(t.buffer.slice(0,o*3))),this._applyElevationOffsetInPlace(l,o,e.elevationOffset);const a=this._transformCoordinates(l,o,e.obb,y.fromJSON(e.inSR),y.fromJSON(e.outSR));return{obb:e.obb,points:a,rgb:t,attributes:b,pointIdFilterMap:i}}_transformCoordinates(e,l,o,i,b){if(!p(e,i,0,e,b,0,l))throw new Error("Can't reproject");const n=z(o.center[0],o.center[1],o.center[2]),f=x(),t=x();F(M,o.quaternion);const a=new Float32Array(l*3);for(let r=0;r<l;r++)f[0]=e[r*3]-n[0],f[1]=e[r*3+1]-n[1],f[2]=e[r*3+2]-n[2],B(t,f,M),o.halfSize[0]=Math.max(o.halfSize[0],Math.abs(t[0])),o.halfSize[1]=Math.max(o.halfSize[1],Math.abs(t[1])),o.halfSize[2]=Math.max(o.halfSize[2],Math.abs(t[2])),a[r*3]=f[0],a[r*3+1]=f[1],a[r*3+2]=f[2];return a}_applyElevationOffsetInPlace(e,l,o){if(o!==0)for(let i=0;i<l;i++)e[i*3+2]+=o}}const M=q();function K(){return new G}export{K as default};
