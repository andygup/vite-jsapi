import{go as sr,gy as ir,br as lr,fM as k,gx as cr,ae as F,af as T,ai as fr,bD as ur,b as _,by as gr,gz as pr,gA as H,gB as q,gC as O,gD as yr,gE as I,gF as mr,K as hr,gG as Fr,gH as Tr,gI as L,L as Pr,gJ as x,fG as Q,fF as Y,gK as Er,gu as Cr,gL as Mr,gM as dr,gN as Ar,gO as N,gP as X,gQ as wr,Q as jr,fl as _r,dT as Or}from"./index-37fc1c1b.js";import{c as Z}from"./mat3f64-c33d428a.js";import{c as P,I as Nr}from"./mat4f64-06a72c15.js";import{g as d}from"./spatialReferenceEllipsoidUtils-bcd12aca.js";import{s as V,m as Rr,g as vr}from"./quat-f041b3f9.js";import{c as U}from"./quatf64-5b0101cd.js";import{t as C,a as E,n as rr}from"./vec32-0aa8fd11.js";import{b as m,h}from"./BufferView-c905fe92.js";function M(r=Lr){return[r[0],r[1],r[2],r[3]]}function gn(r,n,o=M()){return sr(o,r),o[3]=n,o}function pn(r,n,o=M()){return V(A,r,S(r)),V(W,n,S(n)),Rr(A,W,A),zr(o,ir(vr(o,A)))}function yn(r){return r}function S(r){return lr(r[3])}function zr(r,n){return r[3]=n,r}const Lr=[0,0,1,0],A=U(),W=U();M();function D(r,n=!1){return r<=k?n?new Array(r).fill(0):new Array(r):new Float64Array(r)}function Vr(r){return(cr(r)?r.length:r.byteLength/8)<=k?Array.from(r):new Float64Array(r)}function mn(r,n,o){return Array.isArray(r)?r.slice(n,n+o):r.subarray(n,n+o)}var $;let p=$=class extends ur{constructor(n){super(n),this.origin=_(),this.translation=_(),this.rotation=M(),this.scale=gr(1,1,1),this.geographic=!0}get localMatrix(){const n=P();return V(J,this.rotation,S(this.rotation)),pr(n,J,this.translation,this.scale),n}get localMatrixInverse(){return H(P(),this.localMatrix)}applyLocal(n,o){return q(o,n,this.localMatrix)}applyLocalInverse(n,o){return q(o,n,this.localMatrixInverse)}project(n,o){if(this.geographic){const s=d(o),c=P();O(o,this.origin,c,s),yr(c,c,this.localMatrix);const i=D(n.length);return C(i,n,c),I(i,s,0,i,o,0,i.length/3),i}const{localMatrix:t,origin:e}=this,a=mr(t,Nr)?Vr(n):C(D(n.length),n,t);for(let s=0;s<a.length;s+=3)a[s]+=e[0],a[s+1]+=e[1],a[s+2]+=e[2];return a}getOriginPoint(n){const[o,t,e]=this.origin;return new hr({x:o,y:t,z:e,spatialReference:n})}equals(n){return n!=null&&this.geographic===n.geographic&&Fr(this.origin,n.origin)&&Tr(this.localMatrix,n.localMatrix)}clone(){const n={origin:L(this.origin),translation:L(this.translation),rotation:M(this.rotation),scale:L(this.scale),geographic:this.geographic};return new $(n)}};F([T({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"origin",void 0);F([T({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"translation",void 0);F([T({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"rotation",void 0);F([T({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"scale",void 0);F([T({type:Boolean,nonNullable:!0,json:{write:!0}})],p.prototype,"geographic",void 0);F([T()],p.prototype,"localMatrix",null);F([T()],p.prototype,"localMatrixInverse",null);p=$=F([fr("esri.geometry.support.MeshTransform")],p);const J=U(),Sr=p;function b(r,n){return r.isGeographic||r.isWebMercator&&((n==null?void 0:n.geographic)??!0)}const R=Pr.getLogger("esri.geometry.support.meshUtils.normalProjection");function $r(r,n,o,t,e){return z(t)?(v(y.TO_PCPF,m.fromTypedArray(r),h.fromTypedArray(n),h.fromTypedArray(o),t,m.fromTypedArray(e)),e):(R.error("Cannot convert spatial reference to PCPF"),e)}function Gr(r,n,o,t,e){return z(t)?(v(y.FROM_PCPF,m.fromTypedArray(r),h.fromTypedArray(n),h.fromTypedArray(o),t,m.fromTypedArray(e)),e):(R.error("Cannot convert to spatial reference from PCPF"),e)}function Ir(r,n,o){return I(r,n,0,o,d(n),0,r.length/3),o}function Ur(r,n,o){return I(r,d(o),0,n,o,0,r.length/3),n}function br(r,n,o){return N(f,o),E(n,r,f),X(f)||rr(n,n),n}function Br(r,n,o){if(N(f,o),E(n,r,f,4),X(f)||rr(n,n,4),r!==n)for(let t=3;t<r.length;t+=4)n[t]=r[t];return n}function qr(r,n,o,t,e){if(!z(t))return R.error("Cannot convert spatial reference to PCPF"),e;v(y.TO_PCPF,m.fromTypedArray(r,Float32Array.BYTES_PER_ELEMENT*4),h.fromTypedArray(n),h.fromTypedArray(o),t,m.fromTypedArray(e,Float32Array.BYTES_PER_ELEMENT*4));for(let a=3;a<r.length;a+=4)e[a]=r[a];return e}function xr(r,n,o,t,e){if(!z(t))return R.error("Cannot convert to spatial reference from PCPF"),e;v(y.FROM_PCPF,m.fromTypedArray(r,16),h.fromTypedArray(n),h.fromTypedArray(o),t,m.fromTypedArray(e,16));for(let a=3;a<r.length;a+=4)e[a]=r[a];return e}function v(r,n,o,t,e,a){if(!n)return;const s=o.count,c=d(e);if(nr(e))for(let i=0;i<s;i++)t.getVec(i,w),n.getVec(i,g),O(c,w,j,c),x(f,j),r===y.FROM_PCPF&&Q(f,f),Y(g,g,f),a.setVec(i,g);else for(let i=0;i<s;i++){t.getVec(i,w),n.getVec(i,g),O(c,w,j,c),x(f,j);const u=Er(o.get(i,1));let l=Math.cos(u);r===y.TO_PCPF&&(l=1/l),f[0]*=l,f[1]*=l,f[2]*=l,f[3]*=l,f[4]*=l,f[5]*=l,r===y.FROM_PCPF&&Q(f,f),Y(g,g,f),Cr(g,g),a.setVec(i,g)}return a}function z(r){return nr(r)||Qr(r)}function nr(r){return r.isWGS84||Mr(r)||dr(r)||Ar(r)}function Qr(r){return r.isWebMercator}var y;(function(r){r[r.TO_PCPF=0]="TO_PCPF",r[r.FROM_PCPF=1]="FROM_PCPF"})(y||(y={}));const w=_(),g=_(),j=P(),f=Z();function or(r,n,o){return b(n.spatialReference,o)?Dr(r,n,o):Wr(r,n,o)}function Yr(r,n,o){const{position:t,normal:e,tangent:a}=r;if(n==null)return{position:t,normal:e,tangent:a};const s=n.localMatrix,c=C(new Float64Array(t.length),t,s),i=e!=null?br(e,new Float32Array(e.length),s):null,u=a!=null?Br(a,new Float32Array(a.length),s):null;return or({position:c,normal:i,tangent:u},n.getOriginPoint(o),{geographic:n.geographic})}function Fn(r,n,o){if(o!=null&&o.useTransform){const{position:t,normal:e,tangent:a}=r;return{vertexAttributes:{position:t,normal:e,tangent:a},transform:new Sr({origin:[n.x,n.y,n.z??0],geographic:b(n.spatialReference,o)})}}return{vertexAttributes:or(r,n,o),transform:null}}function K(r,n,o){return b(n.spatialReference,o)?Hr(r,n,o):tr(r,n,o)}function Tn(r,n,o,t){if(n==null)return K(r,o,t);const e=Yr(r,n,o.spatialReference);return o.equals(n.getOriginPoint(o.spatialReference))?tr(e,o,t):K(e,o,t)}function Wr(r,n,o){const t=new Float64Array(r.position.length),e=r.position,a=n.x,s=n.y,c=n.z||0,{horizontal:i,vertical:u}=B(o?o.unit:null,n.spatialReference);for(let l=0;l<e.length;l+=3)t[l]=e[l]*i+a,t[l+1]=e[l+1]*i+s,t[l+2]=e[l+2]*u+c;return{position:t,normal:r.normal,tangent:r.tangent}}function Dr(r,n,o){const t=n.spatialReference,e=er(n,o,G),a=new Float64Array(r.position.length),s=Jr(r.position,e,t,a),c=N(ar,e),i=Kr(s,a,r.normal,c,t),u=kr(s,a,r.tangent,c,t);return{position:s,normal:i,tangent:u}}function Jr(r,n,o,t){C(t,r,n);const e=new Float64Array(r.length);return Ur(t,e,o)}function Kr(r,n,o,t,e){if(o==null)return null;const a=new Float32Array(o.length);return E(a,o,t),Gr(a,r,n,e,a),a}function kr(r,n,o,t,e){if(o==null)return null;const a=new Float32Array(o.length);E(a,o,t,4);for(let s=3;s<a.length;s+=4)a[s]=o[s];return xr(a,r,n,e,a),a}function tr(r,n,o){const t=new Float64Array(r.position.length),e=r.position,a=n.x,s=n.y,c=n.z||0,{horizontal:i,vertical:u}=B(o?o.unit:null,n.spatialReference);for(let l=0;l<e.length;l+=3)t[l]=(e[l]-a)/i,t[l+1]=(e[l+1]-s)/i,t[l+2]=(e[l+2]-c)/u;return{position:t,normal:r.normal,tangent:r.tangent}}function Hr(r,n,o){const t=n.spatialReference;er(n,o,G);const e=H(nn,G),a=new Float64Array(r.position.length),s=Xr(r.position,t,e,a),c=N(ar,e),i=Zr(r.normal,r.position,a,t,c),u=rn(r.tangent,r.position,a,t,c);return{position:s,normal:i,tangent:u}}function er(r,n,o){O(r.spatialReference,[r.x,r.y,r.z||0],o,d(r.spatialReference));const{horizontal:t,vertical:e}=B(n?n.unit:null,r.spatialReference);return wr(o,o,[t,t,e]),o}function Xr(r,n,o,t){const e=Ir(r,n,t),a=new Float64Array(e.length);return C(a,e,o),a}function Zr(r,n,o,t,e){if(r==null)return null;const a=$r(r,n,o,t,new Float32Array(r.length));return E(a,a,e),a}function rn(r,n,o,t,e){if(r==null)return null;const a=qr(r,n,o,t,new Float32Array(r.length));return E(a,a,e,4),a}function B(r,n){if(r==null)return on;const o=n.isGeographic?1:jr(n),t=n.isGeographic?1:_r(n),e=Or(1,r,"meters");return{horizontal:e*o,vertical:e*t}}const G=P(),nn=P(),ar=Z(),on={horizontal:1,vertical:1};export{Sr as M,Vr as a,or as b,$r as c,mn as d,qr as e,Ur as f,Yr as g,Gr as h,b as i,xr as j,Fn as k,M as l,pn as m,D as n,yn as o,Ir as p,S as q,gn as r,Tn as s,K as u};
