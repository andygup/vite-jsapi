import{cF as S,p as g}from"./index-06bb4acc.js";import{w as r,J as m}from"./color-8e5f8af9.js";import{N as E}from"./definitions-3f56d206.js";import{g as y}from"./visualVariablesUtils-6f58ca97.js";const D=8388607,v=8388608,d=254,h=255,G=0,A=1,_=e=>(e&v)>>>23,F=e=>e&D,R=e=>_(e)===A?d:h;function P(e){return _(e)===A}function U(e,t){return((t?v:0)|e)>>>0}const N=(e,t)=>e&&((...s)=>t.warn("DEBUG:",...s))||(()=>null),O=!1;function w(e,t){if(!e||!t)return e;switch(t){case"radius":case"distance":return 2*e;case"diameter":case"width":return e;case"area":return Math.sqrt(e)}return e}function z(e){return{value:e.value,size:S(e.size)}}function a(e){return(e??[]).map(t=>z(t))}function p(e){if(typeof e=="string"||typeof e=="number")return S(e);const t=e;return{type:"size",expression:t.expression,stops:a(t.stops)}}const c=e=>{const t=[],s=[],n=a(e),o=n.length;for(let l=0;l<6;l++){const i=n[Math.min(l,o-1)];t.push(i.value),s.push(i.size==null?E:g(i.size))}return{values:new Float32Array(t),sizes:new Float32Array(s)}};function Y(e){const t=e&&e.length>0?{}:null,s=t?{}:null;if(!t||!s)return{vvFields:t,vvRanges:s};for(const n of e)if(n.field&&(t[n.type]=n.field),n.type==="size"){s.size||(s.size={});const o=n;switch(y(o)){case r.SIZE_MINMAX_VALUE:s.size.minMaxValue={minDataValue:o.minDataValue,maxDataValue:o.maxDataValue,minSize:p(o.minSize),maxSize:p(o.maxSize)};break;case r.SIZE_SCALE_STOPS:s.size.scaleStops={stops:a(o.stops)};break;case r.SIZE_FIELD_STOPS:if(o.levels){const i={};for(const u in o.levels)i[u]=c(o.levels[u]);s.size.fieldStops={type:"level-dependent",levels:i}}else s.size.fieldStops={type:"static",...c(o.stops)};break;case r.SIZE_UNIT_VALUE:s.size.unitValue={unit:o.valueUnit,valueRepresentation:o.valueRepresentation??void 0};break}}else if(n.type==="color")s.color=I(n);else if(n.type==="opacity")s.opacity=T(n);else if(n.type==="rotation"){const o=n;s.rotation={type:o.rotationType}}return{vvFields:t,vvRanges:s}}function T(e){const t={values:[0,0,0,0,0,0,0,0],opacities:[0,0,0,0,0,0,0,0]};if(typeof e.field=="string")if(e.stops){if(e.stops.length>8)return null;const s=e.stops;for(let n=0;n<8;++n){const o=Math.min(n,s.length-1),l=s[o];t.values[n]=l.value,t.opacities[n]=l.opacity}}else return null;else if(e.stops&&e.stops.length>=0){const s=e.stops&&e.stops.length>=0?e.stops[0].opacity:0;for(let n=0;n<8;n++)t.values[n]=1/0,t.opacities[n]=s}else return null;return t}function f(e,t,s){e[4*t]=s.r/255,e[4*t+1]=s.g/255,e[4*t+2]=s.b/255,e[4*t+3]=s.a}function I(e){if(e==null||e.normalizationField)return null;const t={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};if(typeof e.field=="string")if(e.stops){if(e.stops.length>8)return null;t.field=e.field;const s=e.stops;for(let n=0;n<8;++n){const o=Math.min(n,s.length-1),l=s[o];t.values[n]=l.value,f(t.colors,n,l.color)}}else return null;else if(e.stops&&e.stops.length>=0){const s=e.stops&&e.stops.length>=0&&e.stops[0].color;for(let n=0;n<8;n++)t.values[n]=1/0,f(t.colors,n,s)}else return null;for(let s=0;s<32;s+=4)m(t.colors,s,!0);return t}export{A as D,G as a,_ as b,R as c,N as d,O as e,w as f,F as g,U as h,P as i,D as j,Y as k};
