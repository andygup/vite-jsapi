import{d6 as D,bz as $,fa as z,g2 as C,df as v,kT as q,f8 as F,kU as G,aa as O}from"./index-0b6846a6.js";import{u as k}from"./elevationInfoUtils-9f640aef.js";async function A(o,d,p,l,r){const{elevationProvider:h,renderCoordsHelper:c,spatialReference:I}=o,{elevationInfo:y}=d,m=z(y,!0),b=await C(m,I,r);v(r);const i=[],f=new Set,u=new Set;for(const{objectId:e,points:a}of l){const n=p(e);if(n==null){for(const s of a)i.push(s.z??0);f.add(e);continue}n.isDraped&&u.add(e);const t=n.graphic.geometry;w.setFromElevationInfo(k(t,y)),w.updateFeatureExpressionInfoContext(b,n.graphic,d),g.spatialReference=o.spatialReference;for(const{x:s,y:j,z:x}of a)g.x=s,g.y=j,g.z=x??0,q(g,h,w,c,R),i.push(R.z)}return{elevations:i,drapedObjectIds:u,failedObjectIds:f}}const w=new F,g=D(0,0,0,$.WGS84),R=new G;async function B(o,d,p){if(o==null||d.candidates.length===0)return S;const l=o.graphics3DGraphicsByObjectID??o.graphics3DGraphics,r=[],h=[],{renderer:c}=o,I=c!=null&&"arcadeRequired"in c&&c.arcadeRequired?O():null,y=async(e,{graphic:a,graphics3DSymbol:n})=>{const t=await I,s=await o.getRenderingInfoAsync(a,c,t,{signal:p});return s==null?[]:n.queryForSnapping(e,b,s,p)},{candidates:m,spatialReference:b}=d;for(let e=0;e<m.length;++e){const a=m[e],{objectId:n}=a,t=typeof n=="number"?l==null?void 0:l.get(n):void 0;if(t==null)continue;const{graphics3DSymbol:s}=t;s.symbologySnappingSupported&&(r.push(y(a,t)),h.push(e))}if(r.length===0)return S;const i=await Promise.all(r);v(p);const f=[],u=[];for(let e=0;e<i.length;++e){const a=i[e],n=h[e];for(const t of a)f.push(t),u.push(n)}return{candidates:f,sourceCandidateIndices:u}}const S={candidates:[],sourceCandidateIndices:[]};export{A as f,B as r};
