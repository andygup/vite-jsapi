import{hy as ne,hz as ue,hA as C,hB as N,db as Z,hC as $,hD as le,hE as oe,T as x,hF as q,aE as ce,_ as he,hG as fe,hH as de,gC as pe,B as D,a as U,cE as Q,aT as H,aJ as V,C as S,w,cv as ye,cb as me,dh as ge,bh as _e,hI as xe,$ as k,eB as W,e1 as J,d1 as Se,hJ as we,c_ as L,hK as Re,a3 as Fe,a_ as Ie,d6 as Qe}from"./index-df1c7459.js";import{v,f as G,F as E,A as y,D as Ee,g as b,E as Y,z as K,l as Ae,M as be,c as P,o as Pe,a as ve,b as $e}from"./QueryEngineResult-a75eda3b.js";import{t as Te}from"./QueryEngineCapabilities-42e44ded.js";function Ge(n){return n==="mesh"?ne:ue(n)}function te(n,e){return n?e?4:3:e?3:2}function Ce(n,e,t,i){return ie(n,e,t,i.coords[0],i.coords[1])}function qe(n,e,t,i,s,r){const a=te(s,r),{coords:u,lengths:l}=i;if(!l)return!1;for(let o=0,c=0;o<l.length;o++,c+=a)if(!ie(n,e,t,u[c],u[c+1]))return!1;return!0}function ie(n,e,t,i,s){if(!n)return!1;const r=te(e,t),{coords:a,lengths:u}=n;let l=!1,o=0;for(const c of u)l=je(l,a,r,o,c,i,s),o+=c*r;return l}function je(n,e,t,i,s,r,a){let u=n,l=i;for(let o=i,c=i+s*t;o<c;o+=t){l=o+t,l===c&&(l=i);const h=e[o],d=e[o+1],m=e[l],g=e[l+1];(d<a&&g>=a||g<a&&d>=a)&&h+(a-d)/(g-d)*(m-h)<r&&(u=!u)}return u}const M="feature-store:unsupported-query",Be={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},O={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function ke(n){return n!=null&&O.spatialRelationship[n]===!0}function Me(n){return n!=null&&O.queryGeometry[ce(n)]===!0}function Oe(n){return n!=null&&O.layerGeometry[n]===!0}function ze(){return he(()=>import("./geometryEngineJSON-1e940afe.js"),["assets/geometryEngineJSON-1e940afe.js","assets/geometryEngineBase-e1a33b0a.js","assets/geometryEngineJSON-3f330436.js","assets/json-48e3ea08.js"])}function T(n,e,t,i,s){if(C(e)&&t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains")){const r=N(new Z,e,!1,!1);return Promise.resolve(a=>Ce(r,!1,!1,a))}if(C(e)&&t==="esriGeometryMultipoint"){const r=N(new Z,e,!1,!1);if(n==="esriSpatialRelContains")return Promise.resolve(a=>qe(r,!1,!1,a,i,s))}if($(e)&&t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains"))return Promise.resolve(r=>le(e,v(t,i,s,r)));if($(e)&&t==="esriGeometryMultipoint"&&n==="esriSpatialRelContains")return Promise.resolve(r=>oe(e,v(t,i,s,r)));if($(e)&&n==="esriSpatialRelIntersects"){const r=Ge(t);return Promise.resolve(a=>r(e,v(t,i,s,a)))}return ze().then(r=>{const a=r[Be[n]].bind(null,e.spatialReference,e);return u=>a(v(t,i,s,u))})}async function X(n,e,t){const{spatialRel:i,geometry:s}=n;if(s){if(!ke(i))throw new x(M,"Unsupported query spatial relationship",{query:n});if(q(s.spatialReference)&&q(t)){if(!Me(s))throw new x(M,"Unsupported query geometry type",{query:n});if(!Oe(e))throw new x(M,"Unsupported layer geometry type",{query:n});if(n.outSR)return G(n.geometry&&n.geometry.spatialReference,n.outSR)}}}function ee(n){if($(n))return!0;if(C(n)){for(const e of n.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}async function Ne(n,e){if(!n)return null;const t=e.featureAdapter,{startTimeField:i,endTimeField:s}=n;let r=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;if(i&&s)await e.forEach(u=>{const l=t.getAttribute(u,i),o=t.getAttribute(u,s);l==null||isNaN(l)||(r=Math.min(r,l)),o==null||isNaN(o)||(a=Math.max(a,o))});else{const u=i||s;await e.forEach(l=>{const o=t.getAttribute(l,u);o==null||isNaN(o)||(r=Math.min(r,o),a=Math.max(a,o))})}return{start:r,end:a}}function Ze(n,e,t){if(!e||!n)return null;const{startTimeField:i,endTimeField:s}=n;if(!i&&!s)return null;const{start:r,end:a}=e;return r===null&&a===null?null:r===void 0&&a===void 0?He():i&&s?De(t,i,s,r,a):Ue(t,i||s,r,a)}function De(n,e,t,i,s){return i!=null&&s!=null?r=>{const a=n.getAttribute(r,e),u=n.getAttribute(r,t);return(a==null||a<=s)&&(u==null||u>=i)}:i!=null?r=>{const a=n.getAttribute(r,t);return a==null||a>=i}:s!=null?r=>{const a=n.getAttribute(r,e);return a==null||a<=s}:void 0}function Ue(n,e,t,i){return t!=null&&i!=null&&t===i?s=>n.getAttribute(s,e)===t:t!=null&&i!=null?s=>{const r=n.getAttribute(s,e);return r>=t&&r<=i}:t!=null?s=>n.getAttribute(s,e)>=t:i!=null?s=>n.getAttribute(s,e)<=i:void 0}function He(){return()=>!1}function Ve(n){return n!=null&&n.every(e=>e.statisticType!=="exceedslimit")}const F="feature-store:unsupported-query",We=new fe(2e6);let Je=0;class Xe{constructor(e){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:Te},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new de(Je+++"$$",We)),this.fieldsIndex=new pe(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=D(this._frameTask),this.clearCache(),U(this._geometryQueryCache),this._changeHandle=D(this._changeHandle),U(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){var e;(e=this._geometryQueryCache)==null||e.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null}async executeQuery(e,t){try{return(await this._executeQuery(e,{},t)).createQueryResponse()}catch(i){if(i!==E)throw i;return new y([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},t)).createQueryResponseForCount()}catch(i){if(i!==E)throw i;return 0}}async executeQueryForExtent(e,t){const i=e.outSR;try{const s=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),r=s.size;return r?{count:r,extent:await this._getBounds(s.items,s.spatialReference,i||this.spatialReference)}:{count:0,extent:null}}catch(s){if(s===E)return{count:0,extent:null};throw s}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then(i=>Array.from(i))}async executeQueryForIdSet(e,t){try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),s=i.items,r=new Set;return await this._reschedule(()=>{for(const a of s)r.add(i.featureAdapter.getObjectId(a))},t),r}catch(i){if(i===E)return new Set;throw i}}async executeQueryForSnapping(e,t){const{point:i,distance:s,types:r}=e;if(r===Ee.NONE)return{candidates:[]};const a=await this._reschedule(()=>this._checkQuerySupport(e.query),t),u=!Q(i.spatialReference,this.spatialReference);u&&await G(i.spatialReference,this.spatialReference);const l=typeof s=="number"?s:s.x,o=typeof s=="number"?s:s.y,c={xmin:i.x-l,xmax:i.x+l,ymin:i.y-o,ymax:i.y+o,spatialReference:i.spatialReference},h=u?b(c,this.spatialReference):c;if(!h)return{candidates:[]};const d=(await H(V(i),null,{signal:t}))[0],m=(await H(V(h),null,{signal:t}))[0];if(S(d)||S(m))return{candidates:[]};const g=new y(await this._reschedule(()=>this._searchFeatures(this._getQueryBBoxes(m.toJSON())),t),a,this);await this._reschedule(()=>this._executeObjectIdsQuery(g),t),await this._reschedule(()=>this._executeTimeQuery(g),t),await this._reschedule(()=>this._executeAttributesQuery(g),t);const f=d.toJSON(),R=u?b(f,this.spatialReference):f,_=u?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return g.createSnappingResponse({...e,point:R,distance:_},i.spatialReference)}async executeQueryForLatestObservations(e,t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new x(F,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const i=await this._executeQuery(e,{},t);return await this._reschedule(()=>this._filterLatest(i),t),i.createQueryResponse()}catch(i){if(i!==E)throw i;return new y([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const{field:s,field2:r,field3:a,valueExpression:u}=t;return(await this._getQueryEngineResultForStats(e,{field:s,field2:r,field3:a,valueExpression:u},i)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const[t,i]=await Promise.all(["getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getBounds(await this._getAllFeatures(),this.spatialReference,this.spatialReference),w(this._timeExtentPromise)?this._timeExtentPromise:this._timeExtentPromise=Ne(this.timeInfo,this.featureStore)]);return ye(e),{fullExtent:t,timeExtent:i}}async _getBounds(e,t,i){const s=me(_e(),ge);await this.featureStore.forEachBounds(e,u=>xe(s,u));const r={xmin:s[0],ymin:s[1],xmax:s[3],ymax:s[4],spatialReference:Y(this.spatialReference)};this.hasZ&&isFinite(s[2])&&isFinite(s[5])&&(r.zmin=s[2],r.zmax=s[5]);const a=b(r,t,i);if(a.spatialReference=Y(i),a.xmax-a.xmin==0){const u=k(a.spatialReference);a.xmin-=u,a.xmax+=u}if(a.ymax-a.ymin==0){const u=k(a.spatialReference);a.ymin-=u,a.ymax+=u}if(this.hasZ&&a.zmin!=null&&a.zmax!=null&&a.zmax-a.zmin==0){const u=k(a.spatialReference);a.zmin-=u,a.zmax+=u}return a}async _schedule(e,t){return w(this._frameTask)?this._frameTask.schedule(e,t):e(W)}async _reschedule(e,t){return w(this._frameTask)?this._frameTask.reschedule(e,t):e(W)}async _getAllFeaturesQueryEngineResult(e){return new y(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(S(this._allFeaturesPromise)){const i=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach(s=>i.push(s))})().then(()=>i)}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=J(e),e=await this._schedule(()=>K(e,this.definitionExpression,this.spatialReference),i),e=await this._reschedule(()=>this._checkQuerySupport(e),i),e={...e,...t};const s=await this._reschedule(()=>this._executeSceneFilterQuery(e,i),i),r=await this._reschedule(()=>this._executeGeometryQuery(e,s,i),i);return await this._reschedule(()=>this._executeAggregateIdsQuery(r),i),await this._reschedule(()=>this._executeObjectIdsQuery(r),i),await this._reschedule(()=>this._executeTimeQuery(r),i),await this._reschedule(()=>this._executeAttributesQuery(r),i),r}async _executeSceneFilterQuery(e,t){if(S(e.sceneFilter))return null;const{outSR:i,returnGeometry:s,returnCentroid:r}=e,a=this.featureStore.featureSpatialReference,u=e.sceneFilter.geometry,l=S(a)||Q(a,u.spatialReference)?u:b(u,a);if(!l)return null;const o=s||r,c=q(i)&&!Q(this.spatialReference,i)&&o?async f=>this._project(f,i):f=>f,h=this.featureAdapter,d=await this._reschedule(()=>this._searchFeatures(this._getQueryBBoxes(l)),t);if(e.sceneFilter.spatialRelationship==="disjoint"){if(!d.length)return null;const f=new Set;for(const A of d)f.add(h.getObjectId(A));const R=await this._reschedule(()=>this._getAllFeatures(),t),_=await this._reschedule(async()=>{const A=await T("esriSpatialRelDisjoint",l,this.geometryType,this.hasZ,this.hasM),j=I=>!f.has(h.getObjectId(I))||A(h.getGeometry(I)),p=await this._runSpatialFilter(R,j,t);return new y(p,e,this)},t);return c(_)}if(!d.length)return new y([],e,this);if(this._canExecuteSinglePass(l,e))return c(new y(d,e,this));const m=await T("esriSpatialRelContains",l,this.geometryType,this.hasZ,this.hasM),g=await this._runSpatialFilter(d,f=>m(h.getGeometry(f)),t);return c(new y(g,e,this))}async _executeGeometryQuery(e,t,i){if(w(t)&&t.items.length===0)return t;e=w(t)?t.query:e;const{geometry:s,outSR:r,spatialRel:a,returnGeometry:u,returnCentroid:l}=e,o=this.featureStore.featureSpatialReference,c=!s||S(o)||Q(o,s.spatialReference)?s:b(s,o),h=u||l,d=q(r)&&!Q(this.spatialReference,r),m=this._geometryQueryCache&&S(t)?JSON.stringify(d&&h?{originalFilterGeometry:s,spatialRelationship:a,outSpatialReference:r}:{originalFilterGeometry:s,spatialRelationship:a}):null,g=m?this._geometryQueryCache.get(m):null;if(w(g))return new y(g,e,this);const f=async p=>(d&&h&&await this._project(p,r),m&&this._geometryQueryCache.put(m,p.items,p.items.length+1),p);if(!c)return f(w(t)?t:await this._getAllFeaturesQueryEngineResult(e));const R=this.featureAdapter;let _=await this._reschedule(()=>this._searchFeatures(this._getQueryBBoxes(s)),i);if(a==="esriSpatialRelDisjoint"){if(!_.length)return f(w(t)?t:await this._getAllFeaturesQueryEngineResult(e));const p=new Set;for(const B of _)p.add(R.getObjectId(B));const I=w(t)?t.items:await this._reschedule(()=>this._getAllFeatures(),i),se=await this._reschedule(async()=>{const B=await T(a,c,this.geometryType,this.hasZ,this.hasM),re=z=>!p.has(R.getObjectId(z))||B(R.getGeometry(z)),ae=await this._runSpatialFilter(I,re,i);return new y(ae,e,this)},i);return f(se)}if(w(t)){const p=new Qe;_=_.filter(I=>Se(t.items,I,t.items.length,p)>=0)}if(!_.length){const p=new y([],e,this);return m&&this._geometryQueryCache.put(m,p.items,1),p}if(this._canExecuteSinglePass(c,e))return f(new y(_,e,this));const A=await T(a,c,this.geometryType,this.hasZ,this.hasM),j=await this._runSpatialFilter(_,p=>A(R.getGeometry(p)),i);return f(new y(j,e,this))}_executeAggregateIdsQuery(e){if(e.items.length===0||!e.query.aggregateIds||!e.query.aggregateIds.length||S(this.aggregateAdapter))return;const t=new Set;for(const s of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach(r=>t.add(r));const i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}_executeObjectIdsQuery(e){if(e.items.length===0||!e.query.objectIds||!e.query.objectIds.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}_executeTimeQuery(e){if(e.items.length===0)return;const t=Ze(this.timeInfo,e.query.timeExtent,this.featureAdapter);S(t)||(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(e.items.length===0)return;const t=Ae(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(i=>t.testFeature(i,this.featureAdapter))}}async _runSpatialFilter(e,t,i){if(!t)return e;if(S(this._frameTask))return e.filter(u=>t(u));let s=0;const r=new Array,a=async u=>{for(;s<e.length;){const l=e[s++];t(l)&&(r.push(l),u.madeProgress()),u.done&&await this._reschedule(o=>a(o),i)}};return this._reschedule(u=>a(u),i).then(()=>r)}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,r=s||i,a=new Map,u=this.featureAdapter.getAttribute;for(const l of e.items){const o=u(l,t),c=u(l,r),h=a.get(o);(!h||c>u(h,r))&&a.set(o,l)}e.items=Array.from(a.values())}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return ee(e)&&(i==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"||i==="esriSpatialRelWithin"))}async _project(e,t){if(!t||Q(this.spatialReference,t))return e;const i=this.featureAdapter,s=await be(e.items.map(r=>v(this.geometryType,this.hasZ,this.hasM,i.getGeometry(r))),this.spatialReference,t);return e.items=s.map((r,a)=>i.cloneWithGeometry(e.items[a],we(r,this.hasZ,this.hasM))),e}_getQueryBBoxes(e){if(ee(e)){if($(e))return[L(e.xmin,e.ymin,e.xmax,e.ymax)];if(C(e))return e.rings.map(t=>L(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[Re(Fe(),e)]}async _searchFeatures(e){const t=new Set;await Promise.all(e.map(s=>this.featureStore.forEachInBounds(s,r=>t.add(r))));const i=Array.from(t.values());return t.clear(),i}async _checkStatisticsSupport(e,t){if((e.distance??0)<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new x(F,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),Promise.all([this._checkStatisticsParamsSupport(t),X(e,this.geometryType,this.spatialReference),G(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:i}=await Ie();t=i.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.field2&&t.push(e.field2),e.field3&&t.push(e.field3),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new x(F,"params should have at least a field or valueExpression",{params:e});P(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if((e.distance??0)<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new x(F,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Promise.all([X(e,this.geometryType,this.spatialReference),G(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:i,returnDistinctValues:s,outStatistics:r}=e,a=r?r.map(u=>u.outStatisticFieldName&&u.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(i&&i.length>0){const u=" asc",l=" desc",o=i.map(c=>{const h=c.toLowerCase();return h.includes(u)?h.split(u)[0]:h.includes(l)?h.split(l)[0]:c}).filter(c=>!a.includes(c));P(this.fieldsIndex,o,"orderByFields contains missing fields")}if(t&&t.length>0)P(this.fieldsIndex,t,"outFields contains missing fields");else if(s)throw new x(F,"outFields should be specified for returnDistinctValues",{query:e});Pe(this.fieldsIndex,e.where)}_checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:s}=e,r=i&&i.length,a=t&&t.length;if(s){if(!r||!a)throw new x(F,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});ve(this.fieldsIndex,s,t)}if(a){if(!Ve(t))return;const u=t.map(l=>l.onStatisticField).filter(Boolean);P(this.fieldsIndex,u,"onStatisticFields contains missing fields"),r&&P(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const l of t){const{onStatisticField:o,statisticType:c}=l;if((c==="percentile_disc"||c==="percentile_cont")&&"statisticParameters"in l){const{statisticParameters:h}=l;if(!h)throw new x(F,"statisticParamters should be set for percentile type",{definition:l,query:e})}else if(c!=="count"&&o&&$e(o,this.fieldsIndex))throw new x(F,"outStatistics contains non-numeric fields",{definition:l,query:e})}}}async _getQueryEngineResultForStats(e,t,i){e=J(e);try{e=await this._schedule(()=>K(e,this.definitionExpression,this.spatialReference),i),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),i);const s=await this._reschedule(()=>this._executeSceneFilterQuery(e,i),i),r=await this._reschedule(()=>this._executeGeometryQuery(e,s,i),i);return await this._reschedule(()=>this._executeAggregateIdsQuery(r),i),await this._reschedule(()=>this._executeObjectIdsQuery(r),i),await this._reschedule(()=>this._executeTimeQuery(r),i),await this._reschedule(()=>this._executeAttributesQuery(r),i),r}catch(s){if(s!==E)throw s;return new y([],e,this)}}}export{Xe as e,Ze as n,T as v};
