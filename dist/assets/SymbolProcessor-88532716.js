import{i as D,ae as P,ai as k,t as M,bt as K,aR as S,cP as A}from"./index-b51e75d5.js";import{e as L}from"./ExpandedCIM-e8dcd3e7.js";import{d as E,h as v}from"./diffUtils-1090f477.js";import{i as O}from"./visualVariablesUtils-eb7c5ec6.js";import{b as U}from"./color-05b85ffd.js";import{a as B,c as R,b as W,M as z,d as G}from"./Matcher-9ea16ab6.js";import{B as $}from"./BaseProcessor-5076c64b.js";import"./BidiEngine-cdaf024a.js";import"./GeometryUtils-26dde58c.js";import"./enums-eb6e4255.js";import"./MaterialKey-72fa82a6.js";import"./definitions-3f56d206.js";import"./Rect-df8ea165.js";import"./quantizationUtils-57f47ed2.js";import"./floatRGBA-910d7868.js";import"./visualVariablesUtils-033c8494.js";import"./enums-08489827.js";import"./VertexElementDescriptor-24e04d97.js";import"./tileUtils-fdb57ff2.js";import"./TurboLine-4458975d.js";import"./featureConversionUtils-87949e9d.js";import"./OptimizedGeometry-af84d2ad.js";import"./OptimizedFeatureSet-5c82fe5a.js";import"./defaultsJSON-b396ba80.js";import"./GeometryUtils-0ab64fac.js";import"./earcut-db592379.js";import"./LRUCache-3f2a86dd.js";import"./MemCache-467264d5.js";import"./devEnvironmentUtils-e2e22b53.js";import"./styleUtils-10d73057.js";import"./featureFlags-dcf59b6a.js";class N{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,t){const a=this._resourceMap,s=a.get(e);if(s)return s;let r=this._inFlightResourceMap.get(e);if(r)return r;try{r=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...t}),this._inFlightResourceMap.set(e,r),r.then(i=>(this._inFlightResourceMap.delete(e),a.set(e,i),i))}catch(i){return D(i)?null:{width:0,height:0}}return r}getResource(e){return this._resourceMap.get(e)??null}}function C(g,e){return(!g.minScale||g.minScale>=e)&&(!g.maxScale||g.maxScale<=e)}function x(g){const e=g.message,t={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin,version:e.version},transferList:new Array};for(const a in e.data){const s=a,r=e.data[s];if(t.message.data[s]=null,r!=null){const i=r.stride,c=r.indices.slice(0),o=r.vertices.slice(0),h=r.records.slice(0),u=S(r.metrics,l=>l.slice(0)),d={stride:i,indices:c,vertices:o,records:h,metrics:u};t.transferList.push(c,o,h),t.message.data[s]=d}}return t}let w=class extends ${constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new N(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(e){this._bufferIds.forEach(t=>{t.forEach(e)})}async update(e,t){var r;const a=t.schema.processors[0];if(a.type!=="symbol")return;const s=E(this._schema,a);!v(s,"mesh")&&!v(s,"target")||(e.mesh=!0,(r=e.why)==null||r.mesh.push("Symbology changed"),this._schema=a,this._factory=this._createFactory(a),this._factory.update(a,this.tileStore.tileScheme.tileInfo))}onTileMessage(e,t,a,s){return M(s),this._onTileData(e,t,a,s)}onTileClear(e){const t={clear:!0};return this._bufferData.delete(e.key.id),this._bufferIds.delete(e.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t})}onTileError(e,t,a){const s=a.signal,r={tileKey:e.id,error:t};return this.remoteClient.invoke("tileRenderer.onTileError",r,{signal:s})}onTileUpdate(e){for(const t of e.removed)this._bufferData.has(t.key.id)&&this._bufferData.delete(t.key.id),this._bufferIds.has(t.key.id)&&this._bufferIds.delete(t.key.id);for(const t of e.added)this._bufferData.forEach(a=>{for(const s of a)s.message.tileKey===t.id&&this._updateTileMesh("append",t,x(s),[],!1,!1,null)})}_addBufferData(e,t){var a;this._bufferData.has(e)||this._bufferData.set(e,[]),(a=this._bufferData.get(e))==null||a.push(x(t))}_createFactory(e){const{geometryType:t,objectIdField:a,fields:s}=this.service,r=(d,l)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",d,l),i=K.fromJSON(this.spatialReference),c={geometryType:t,fields:s,spatialReference:i},o=new B(r,this.tileStore.tileScheme.tileInfo),{matcher:h,aggregateMatcher:u}=e.mesh;return this._store=o,this._matchers.feature=R(h,o,c,this._resourceManagerProxy),this._matchers.aggregate=S(u,d=>R(d,o,c,this._resourceManagerProxy)),new W(t,a,o)}async _onTileData(e,t,a,s){var l;M(s);const{type:r,addOrUpdate:i,remove:c,clear:o,end:h}=t,u=!!this._schema.mesh.sortKey;if(!i){const f={type:r,addOrUpdate:null,remove:c,clear:o,end:h,sort:u};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:f},s)}const d=this._processFeatures(e,i,a,s,(l=t.status)==null?void 0:l.version);try{const f=await d;if(f==null){const n={type:r,addOrUpdate:null,remove:c,clear:o,end:h,sort:u};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:n},s)}const m=[];for(const n of f){let p=!1;const _=n.message.bufferIds,y=e.key.id,b=n.message.tileKey;if(y!==b&&_!=null){if(!this.tileStore.get(b)){this._addBufferData(y,n),m.push(n);continue}let I=this._bufferIds.get(b);I||(I=new Set,this._bufferIds.set(b,I));const F=Array.from(_);for(const T of F)if(I.has(T)){p=!0;break}else I.add(T)}p||(this._addBufferData(y,n),m.push(n))}await Promise.all(m.map(n=>{const p=e.key.id===n.message.tileKey,_=p?t.remove:[],y=p&&t.end;return this._updateTileMesh(r,e,n,_,y,!!t.clear,s.signal)}))}catch(f){this._handleError(e,f,s)}}async _updateTileMesh(e,t,a,s,r,i,c){const o=e,h=a.message.tileKey,u=!!this._schema.mesh.sortKey;h!==t.key.id&&(r=!1);const d=S(a,n=>n.message),l=S(a,n=>n.transferList)||[],f={type:o,addOrUpdate:d,remove:s,clear:i,end:r,sort:u},m={transferList:l||[],signal:c};return M(m),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:h,data:f},m)}async _processFeatures(e,t,a,s,r){if(t==null||!t.hasFeatures)return null;const i={transform:e.transform,hasZ:!1,hasM:!1},c=this._factory,o={viewingMode:"",scale:e.scale},h=await this._matchers.feature,u=await this._matchers.aggregate;M(s);const d=this._getLabelInfos(e,t);return await c.analyze(t.getCursor(),this._resourceManagerProxy,h,u,i,o),M(s),this._writeFeatureSet(e,t,i,d,c,a,r)}_writeFeatureSet(e,t,a,s,r,i,c){const o=t.getSize(),h=this._schema.mesh.matcher.symbologyType,u=new z(e.key.id,{features:o,records:o,metrics:0},h,i,h!==U.HEATMAP,c),d={viewingMode:"",scale:e.scale},l=t.getCursor();for(;l.next();)try{const m=l.getDisplayId(),n=s!=null?s.get(m):null;r.writeCursor(u,l,a,d,e.level,n,this._resourceManagerProxy)}catch{}const f=e.tileInfoView.tileInfo.isWrappable;return u.serialize(f)}_handleError(e,t,a){if(!D(t)){const s={tileKey:e.id,error:t.message};return this.remoteClient.invoke("tileRenderer.onTileError",s,{signal:a.signal})}return Promise.resolve()}_getLabelingSchemaForScale(e){const t=this._schema.mesh.labels;if(t==null)return null;if(t.type==="subtype"){const s={type:"subtype",classes:{}};let r=!1;for(const i in t.classes){const o=t.classes[i].filter(h=>C(h,e.scale));r=r||!!o.length,s.classes[i]=o}return r?s:null}const a=t.classes.filter(s=>C(s,e.scale));return a.length?{type:"simple",classes:a}:null}_getLabels(e,t){if(t.type==="subtype"){const a=this.service.subtypeField,s=A(a,"Expected to find subtype Field"),r=e.readAttribute(s);return r==null?[]:t.classes[r]??[]}return t.classes}_getLabelInfos(e,t){const a=this._getLabelingSchemaForScale(e);if(a==null)return null;const s=new Map,r=t.getCursor();for(;r.next();){const i=r.getDisplayId(),c=[],o=O(i),u=o&&r.readAttribute("cluster_count")!==1?"aggregate":"feature",d=this._getLabels(r,a);for(const l of d){if(l.target!==u)continue;const f=r.getStorage(),n=o&&u==="feature"?f.getComputedStringAtIndex(r.readAttribute("referenceId"),l.fieldIndex):f.getComputedStringAtIndex(i,l.fieldIndex);if(!n)continue;const p=L(n.toString()),_=p[0],y=p[1];this._store.getMosaicItem(l.symbol,G(_)).then(b=>{c[l.index]={glyphs:b.glyphMosaicItems??[],rtl:y,index:l.index}})}s.set(i,c)}return s}};w=P([k("esri.views.2d.layers.features.processors.SymbolProcessor")],w);const we=w;export{we as default};
