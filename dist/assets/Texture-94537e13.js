import{J as C,m as B,s as $,b as M,b5 as N}from"./index-21a3eccc.js";import{M as T,L as g,D as R,t as S,G as L,P as b,U as w,u as V}from"./enums-10aa9b05.js";const k=C.getLogger("esri.views.webgl.checkWebGLError");function z(n,t){switch(t){case n.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case n.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case n.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case n.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case n.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case n.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const F=!!B("enable-feature:webgl-debug");function K(){return F}function j(){return F}function A(n){if(K()){const t=n.getError();if(t){const e=z(n,t),r=new Error().stack;k.error(new $("webgl-error","WebGL error occured",{message:e,stack:r}))}}}const P={target:T.TEXTURE_2D,samplingMode:g.LINEAR,wrapMode:R.REPEAT,flipped:!1,hasMipmap:!1,isOpaque:!1,unpackAlignment:4,preMultiplyAlpha:!1,isImmutable:!1},y=4;let u=class{constructor(t,e,r=null){this._context=t,this.type="texture",this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,t.instanceCounter.increment(S.Texture,this),this._descriptor={...P,...e};for(const i in P)this._descriptor[i]===void 0&&(this._descriptor[i]=P[i]);if(t.type!==M.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),x(this._descriptor.target)))throw new Error("3D and array textures are not supported in WebGL1");this._descriptor.target===T.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._context.gl&&this._glName&&(this._context.unbindTexture(this),this._context.gl.deleteTexture(this._glName),this._glName=null,this._context.instanceCounter.decrement(S.Texture,this))}release(){this.dispose()}resize(t,e){const r=this._descriptor;if(r.width!==t||r.height!==e){if(this._wasImmutablyAllocated)throw new Error("Immutable textures can't be resized!");r.width=t,r.height=e,this._descriptor.target===T.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(t=null){for(let e=T.TEXTURE_CUBE_MAP_POSITIVE_X;e<=T.TEXTURE_CUBE_MAP_NEGATIVE_Z;e++)this._setData(t,e)}setData(t){this._setData(t)}_setData(t,e){if(!this._context||!this._context.gl)return;const r=this._context.gl;this._glName||(this._glName=r.createTexture()),t===void 0&&(t=null);const i=this._descriptor,a=e??i.target,o=x(a);t===null&&(i.width=i.width||y,i.height=i.height||y,o&&(i.depth=i.depth??1));const p=this._context.bindTexture(this,u.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(u.TEXTURE_UNIT_FOR_UPDATES),u._validateTexture(this._context,i),this._configurePixelStorage(),A(r);const l=i.pixelFormat;let s=i.internalFormat??this._deriveInternalFormat(l,i.dataType);if(U(t)){let h=t.width,_=t.height;const d=1;t instanceof HTMLVideoElement&&(h=t.videoWidth,_=t.videoHeight),i.width&&i.height,o&&i.depth,i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(a,s,i.hasMipmap,h,_,d),this._texImage(a,0,s,h,_,d,t),A(r),i.hasMipmap&&this.generateMipmap(),i.width===void 0&&(i.width=h),i.height===void 0&&(i.height=_),o&&i.depth===void 0&&(i.depth=d)}else{const{width:h,height:_,depth:d}=i;if(h==null||_==null)throw new Error("Width and height must be specified!");if(o&&d==null)throw new Error("Depth must be specified!");if(i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(a,s,i.hasMipmap,h,_,d),r.DEPTH24_STENCIL8&&s===r.DEPTH_STENCIL&&(s=r.DEPTH24_STENCIL8),D(t)){const m=t.levels,c=v(a,h,_,d),E=Math.min(c-1,m.length-1);this._context.gl2!=null?r.texParameteri(i.target,this._context.gl2.TEXTURE_MAX_LEVEL,E):i.hasMipmap=i.hasMipmap&&c===m.length;const f=s;if(!Y(f))throw new Error("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((I,O,G,X)=>{const W=m[Math.min(I,m.length-1)];this._compressedTexImage(a,I,f,O,G,X,W)},E)}else t!=null?(this._texImage(a,0,s,h,_,d,t),A(r),i.hasMipmap&&this.generateMipmap()):this._forEachMipmapLevel((m,c,E,f)=>{this._texImage(a,m,s,c,E,f,null),A(r)})}u._applySamplingMode(r,this._descriptor),u._applyWrapMode(r,this._descriptor),u._applyAnisotropicFilteringParameters(this._context,this._descriptor),A(r),this._context.bindTexture(p,u.TEXTURE_UNIT_FOR_UPDATES)}updateData(t,e,r,i,a,o,p=0){o||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._context.gl,s=this._descriptor,{pixelFormat:h,dataType:_,target:d,isImmutable:m}=s,c=s.internalFormat??this._deriveInternalFormat(h,_);if(m&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");const E=this._context.bindTexture(this,u.TEXTURE_UNIT_FOR_UPDATES,!0);if((e<0||r<0||i>s.width||a>s.height||e+i>s.width||r+a>s.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),p){if(this._context.gl2==null)return void console.error("Webgl2 must be enabled to use dataRowOffset!");l.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS,p)}if(U(o)?this._context.gl2!=null?this._context.gl2.texSubImage2D(d,t,e,r,i,a,h,_,o):l.texSubImage2D(d,t,e,r,h,_,o):D(o)?l.compressedTexSubImage2D(d,t,e,r,i,a,c,o.levels[t]):l.texSubImage2D(d,t,e,r,i,a,h,_,o),p){if(this._context.gl2==null)return void console.error("Webgl2 must be enabled to use dataRowOffset!");l.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS,0)}this._context.bindTexture(E,u.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(t,e,r,i,a,o,p,l){l||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const s=this._context.gl2;if(s==null)throw new Error("3D textures are not supported in WebGL1");const h=this._descriptor,{pixelFormat:_,dataType:d,isImmutable:m,target:c}=h,E=h.internalFormat??this._deriveInternalFormat(_,d);if(m&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");x(c)||console.warn("Attempting to set 3D texture data on a non-3D texture");const f=this._context.bindTexture(this,u.TEXTURE_UNIT_FOR_UPDATES);if(this._context.setActiveTexture(u.TEXTURE_UNIT_FOR_UPDATES),(e<0||r<0||i<0||a>h.width||o>h.height||p>h.depth||e+a>h.width||r+o>h.height||i+p>h.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),D(l))l=l.levels[t],s.compressedTexSubImage3D(c,t,e,r,i,a,o,p,E,l);else{const I=l;s.texSubImage3D(c,t,e,r,i,a,o,p,_,d,I)}this._context.bindTexture(f,u.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const t=this._descriptor;if(!t.hasMipmap){if(this._wasImmutablyAllocated)throw new Error("Cannot add mipmaps to immutable texture after allocation");t.hasMipmap=!0,this._samplingModeDirty=!0,u._validateTexture(this._context,t)}t.samplingMode===g.LINEAR?(this._samplingModeDirty=!0,t.samplingMode=g.LINEAR_MIPMAP_NEAREST):t.samplingMode===g.NEAREST&&(this._samplingModeDirty=!0,t.samplingMode=g.NEAREST_MIPMAP_NEAREST);const e=this._context.bindTexture(this,u.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(u.TEXTURE_UNIT_FOR_UPDATES),this._context.gl.generateMipmap(t.target),this._context.bindTexture(e,u.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(t){t!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=t,this._samplingModeDirty=!0)}setWrapMode(t){t!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=t,u._validateTexture(this._context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const t=this._context.gl,e=this._descriptor;this._samplingModeDirty&&(u._applySamplingMode(t,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(u._applyWrapMode(t,e),this._wrapModeDirty=!1)}_deriveInternalFormat(t,e){if(this._context.type===M.WEBGL1)return t;switch(e){case L.FLOAT:switch(t){case b.RGBA:return w.RGBA32F;case b.RGB:return w.RGB32F;default:throw new Error("Unable to derive format")}case L.UNSIGNED_BYTE:switch(t){case b.RGBA:return w.RGBA8;case b.RGB:return w.RGB8}default:return t}}_configurePixelStorage(){const t=this._context.gl,{unpackAlignment:e,flipped:r,preMultiplyAlpha:i}=this._descriptor;t.pixelStorei(t.UNPACK_ALIGNMENT,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r?1:0),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(t,e,r,i,a,o){const p=this._context.gl2;if(p==null)throw new Error("Immutable textures are not supported in WebGL1");if(!H(e))throw new Error("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const l=r?v(t,i,a,o):1;if(x(t)){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");p.texStorage3D(t,l,e,i,a,o)}else p.texStorage2D(t,l,e,i,a);this._wasImmutablyAllocated=!0}_texImage(t,e,r,i,a,o,p){const l=this._context.gl;let s=null;const h=this._context.type===M.WEBGL2,_=x(t),{isImmutable:d,pixelFormat:m,dataType:c}=this._descriptor;if(h&&(s=l),h||!U(p))if(d){if(p!=null){const E=p;if(_){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");s.texSubImage3D(t,e,0,0,0,i,a,o,m,c,E)}else l.texSubImage2D(t,e,0,0,i,a,m,c,E)}}else{const E=p;if(_){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");s.texImage3D(t,e,r,i,a,o,0,m,c,E)}else l.texImage2D(t,e,r,i,a,0,m,c,E)}else l.texImage2D(t,0,r,m,c,p)}_compressedTexImage(t,e,r,i,a,o,p){const l=this._context.gl;let s=null;const h=x(t),_=this._descriptor.isImmutable;if(h){if(this._context.type!==M.WEBGL2)throw new Error("3D textures are not supported in WebGL1");s=l}if(_){if(p!=null)if(h){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");s.compressedTexSubImage3D(t,e,0,0,0,i,a,o,r,p)}else l.compressedTexSubImage2D(t,e,0,0,i,a,r,p)}else if(h){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");s.compressedTexImage3D(t,e,r,i,a,o,0,p)}else l.compressedTexImage2D(t,e,r,i,a,0,p)}_forEachMipmapLevel(t,e=1/0){let{width:r,height:i,depth:a,hasMipmap:o,target:p}=this._descriptor;const l=p===T.TEXTURE_3D;if(r==null||i==null||l&&a==null)throw new Error("Missing texture dimensions for mipmap calculation");for(let s=0;t(s,r,i,a),o&&(r!==1||i!==1||l&&a!==1)&&!(s>=e);++s)r=Math.max(1,r>>1),i=Math.max(1,i>>1),l&&(a=Math.max(1,a>>1))}static _validateTexture(t,e){(e.width!=null&&e.width<0||e.height!=null&&e.height<0||e.depth!=null&&e.depth<0)&&console.error("Negative dimension parameters are not allowed!");const r=t.type===M.WEBGL2,i=e.width!=null&&N(e.width)&&e.height!=null&&N(e.height);r||!e.isImmutable&&!x(e.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!"),r||i||(typeof e.wrapMode=="number"?e.wrapMode!==R.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):e.wrapMode.s===R.CLAMP_TO_EDGE&&e.wrapMode.t===R.CLAMP_TO_EDGE||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),e.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))}static _applySamplingMode(t,e){let r=e.samplingMode,i=e.samplingMode;r===g.LINEAR_MIPMAP_NEAREST||r===g.LINEAR_MIPMAP_LINEAR?(r=g.LINEAR,e.hasMipmap||(i=g.LINEAR)):r!==g.NEAREST_MIPMAP_NEAREST&&r!==g.NEAREST_MIPMAP_LINEAR||(r=g.NEAREST,e.hasMipmap||(i=g.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,r),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,i)}static _applyWrapMode(t,e){typeof e.wrapMode=="number"?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}static _applyAnisotropicFilteringParameters(t,e){const r=t.capabilities.textureFilterAnisotropic;r&&t.gl.texParameterf(e.target,r.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}};function H(n){return n in w}function Y(n){return n in V}function D(n){return n!=null&&"type"in n&&n.type==="compressed"}function q(n){return n!=null&&"byteLength"in n}function U(n){return n!=null&&!D(n)&&!q(n)}function x(n){return n===T.TEXTURE_3D||n===T.TEXTURE_2D_ARRAY}function v(n,t,e,r=1){let i=Math.max(t,e);return n===T.TEXTURE_3D&&(i=Math.max(i,r)),Math.round(Math.log(i)/Math.LN2)+1}u.TEXTURE_UNIT_FOR_UPDATES=0;export{K as a,j as c,u as m,A as u};
