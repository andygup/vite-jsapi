import{d7 as mt,eE as B,hz as P,hA as Q,hB as w,bt as L,g8 as M,hC as q,hD as Y,hE as N,hF as Z,g1 as tt,hG as C,hH as ft,e as E,aK as f,hI as et,g0 as W,ab as _t,ad as pt,hJ as bt,c as gt,hK as St,hL as xt,hM as nt,gt as $}from"./index-0265f5b0.js";import{E as ot}from"./QueryEngineResult-27562a9e.js";import{i as it}from"./InterleavedLayout-4dbdc11c.js";import{m as Ot}from"./edgeProcessing-72c9437d.js";import"./quantizationUtils-5a38db0c.js";import"./WhereClause-fc5e1781.js";import"./executionError-fb3f283a.js";import"./utils-2e4fe165.js";import"./generateRendererUtils-489ca2af.js";import"./projectionSupport-1c354c95.js";import"./json-48e3ea08.js";import"./utils-ff4a5c29.js";import"./BufferView-fab14bf5.js";import"./types-1305598a.js";import"./deduplicate-caff52c7.js";import"./Indices-824db11e.js";import"./VertexAttribute-9f2e53ec.js";import"./enums-10aa9b05.js";import"./VertexElementDescriptor-2925c6af.js";let J=class R{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,e){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new c,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}destroy(){this._degenerateObjects.clear(),c.clearPool(),G[0]=null,T.prune(),z.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const n=c.acquire();for(let o=0;o<e;o++){const s=t[o];this._isDegenerate(s)?this._degenerateObjects.add(s):(n.init(this._root),this._add(s,n))}c.release(n)}remove(t,e=null){this._objectCount-=t.length;const n=c.acquire();for(const o of t){const s=e??P(this.objectToBoundingSphere(o),zt);v(s[3])?(n.init(this._root),this._remove(o,s,n)):this._degenerateObjects.delete(o)}c.release(n),this._shrink()}update(t,e){if(!v(e[3])&&this._isDegenerate(t))return;const n=Tt(t);this.remove(n,e),this.add(n)}forEachAlongRay(t,e,n){const o=Q(t,e);this._forEachNode(this._root,s=>{if(!this._intersectsNode(o,s))return!1;const h=s.node;return h.terminals.forAll(d=>{this._intersectsObject(o,d)&&n(d)}),h.residents!==null&&h.residents.forAll(d=>{this._intersectsObject(o,d)&&n(d)}),!0})}forEachAlongRayWithVerticalOffset(t,e,n,o){const s=Q(t,e);this._forEachNode(this._root,h=>{if(!this._intersectsNodeWithOffset(s,h,o))return!1;const d=h.node;return d.terminals.forAll(r=>{this._intersectsObjectWithOffset(s,r,o)&&n(r)}),d.residents!==null&&d.residents.forAll(r=>{this._intersectsObjectWithOffset(s,r,o)&&n(r)}),!0})}forEach(t){this._forEachNode(this._root,e=>{const n=e.node;return n.terminals.forAll(t),n.residents!==null&&n.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,n,o=()=>!0,s=1/0){let h=1/0,d=1/0,r=null;const a=k(t,e),u=l=>{if(--s,!o(l))return;const _=this.objectToBoundingSphere(l);if(!w(n,_))return;const S=j(t,e,N(_)),D=S-_[3],m=S+_[3];D<h&&(h=D,d=m,r=l)};return this._forEachNodeDepthOrdered(this._root,l=>{if(s<=0||!w(n,l.bounds)||(L(g,a,l.halfSize),M(g,g,l.bounds),j(t,e,g)>d))return!1;const _=l.node;return _.terminals.forAll(S=>u(S)),_.residents!==null&&_.residents.forAll(S=>u(S)),!0},t,e),r}forEachInDepthRange(t,e,n,o,s,h,d){let r=-1/0,a=1/0;const u={setRange:m=>{n===R.DepthOrder.FRONT_TO_BACK?(r=Math.max(r,m.near),a=Math.min(a,m.far)):(r=Math.max(r,-m.far),a=Math.min(a,-m.near))}};u.setRange(o);const l=j(e,n,t),_=k(e,n),S=k(e,-n),D=m=>{if(!d(m))return;const O=this.objectToBoundingSphere(m),A=N(O),X=j(e,n,A)-l,lt=X-O[3],ut=X+O[3];lt>a||ut<r||!w(h,O)||s(m,u)};this._forEachNodeDepthOrdered(this._root,m=>{if(!w(h,m.bounds)||(L(g,_,m.halfSize),M(g,g,m.bounds),j(e,n,g)-l>a)||(L(g,S,m.halfSize),M(g,g,m.bounds),j(e,n,g)-l<r))return!1;const O=m.node;return O.terminals.forAll(A=>D(A)),O.residents!==null&&O.residents.forAll(A=>D(A)),!0},e,n)}forEachNode(t){this._forEachNode(this._root,e=>t(e.node,e.bounds,e.halfSize,e.depth))}forEachNeighbor(t,e){const n=q(e),o=N(e),s=r=>{const a=this.objectToBoundingSphere(r),u=q(a),l=n+u;return!(Y(N(a),o)-l*l<=0)||t(r)};let h=!0;const d=r=>{h&&(h=s(r))};this._forEachNode(this._root,r=>{const a=q(r.bounds),u=n+a;if(Y(N(r.bounds),o)-u*u>0)return!1;const l=r.node;return l.terminals.forAll(d),h&&l.residents!==null&&l.residents.forAll(d),h}),h&&this.forEachDegenerateObject(d)}_intersectsNode(t,e){return y(e.bounds,2*-e.halfSize,p),y(e.bounds,2*e.halfSize,b),it(t.origin,t.direction,p,b)}_intersectsNodeWithOffset(t,e,n){return y(e.bounds,2*-e.halfSize,p),y(e.bounds,2*e.halfSize,b),n.applyToMinMax(p,b),it(t.origin,t.direction,p,b)}_intersectsObject(t,e){const n=this.objectToBoundingSphere(e);return!(n[3]>0)||Z(n,t)}_intersectsObjectWithOffset(t,e,n){const o=this.objectToBoundingSphere(e);return!(o[3]>0)||Z(n.applyToBoundingSphere(o),t)}_forEachNode(t,e){let n=c.acquire().init(t);const o=[n];for(;o.length!==0;){if(n=o.pop(),e(n)&&!n.isLeaf())for(let s=0;s<n.node.children.length;s++)n.node.children[s]&&o.push(c.acquire().init(n).advance(s));c.release(n)}}_forEachNodeDepthOrdered(t,e,n,o=R.DepthOrder.FRONT_TO_BACK){let s=c.acquire().init(t);const h=[s];for(Et(n,o,ht);h.length!==0;){if(s=h.pop(),e(s)&&!s.isLeaf())for(let d=7;d>=0;--d){const r=ht[d];s.node.children[r]&&h.push(c.acquire().init(s).advance(r))}c.release(s)}}_remove(t,e,n){T.clear();const o=n.advanceTo(e,(s,h)=>{T.push(s.node),T.push(h)})?n.node.terminals:n.node.residents;if(o.removeUnordered(t),o.length===0)for(let s=T.length-2;s>=0;s-=2){const h=T.data[s],d=T.data[s+1];if(!this._purge(h,d))break}}_nodeIsEmpty(t){if(t.terminals.length!==0)return!1;if(t.residents!==null)return t.residents.length===0;for(let e=0;e<t.children.length;e++)if(t.children[e])return!1;return!0}_purge(t,e){return e>=0&&(t.children[e]=null),!!this._nodeIsEmpty(t)&&(t.residents===null&&(t.residents=new B({shrink:!0})),!0)}_add(t,e){e.advanceTo(this.objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let n=0;n<e.length;n++){const o=c.acquire().init(t);this._add(e.getItemAt(n),o),c.release(o)}}_grow(t,e){if(e!==0&&(st(t,e,n=>this.objectToBoundingSphere(n),x),v(x[3])&&!this._fitsInsideTree(x)))if(this._nodeIsEmpty(this._root.node))P(x,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const n=this._rootBoundsForRootAsSubNode(x);this._placingRootViolatesMaxDepth(n)?this._rebuildTree(x,n):this._growRootAsSubNode(n),c.release(n)}}_rebuildTree(t,e){tt(K,e.bounds),K[3]=e.halfSize,st([t,K],2,o=>o,H);const n=c.acquire().init(this._root);this._root.initFrom(null,H,H[3]),this._root.increaseHalfSize(1.25),this._forEachNode(n,o=>(this.add(o.node.terminals.data,o.node.terminals.length),o.node.residents!==null&&this.add(o.node.residents.data,o.node.residents.length),!0)),c.release(n)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,o=>(n=Math.max(n,o.depth),n+e<=this._maximumDepth)),n+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],n=t;let o=-1/0;const s=this._root.bounds,h=this._root.halfSize;for(let r=0;r<3;r++){const a=s[r]-h-(n[r]-e),u=n[r]+e-(s[r]+h),l=Math.max(0,Math.ceil(a/(2*h))),_=Math.max(0,Math.ceil(u/(2*h)))+1,S=2**Math.ceil(Math.log(l+_)*Math.LOG2E);o=Math.max(o,S),F[r].min=l,F[r].max=_}for(let r=0;r<3;r++){let a=F[r].min,u=F[r].max;const l=(o-(a+u))/2;a+=Math.ceil(l),u+=Math.floor(l);const _=s[r]-h-a*h*2;V[r]=_+(u+a)*h}const d=o*h;return V[3]=d*ct,c.acquire().initFrom(null,V,d,0)}_growRootAsSubNode(t){const e=this._root.node;tt(x,this._root.bounds),x[3]=this._root.halfSize,this._root.init(t),t.advanceTo(x,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let n=0,o=0;for(;o<e.length&&t==null;)n=o++,t=e[n];for(;o<e.length;)if(e[o++])return-1;return n}_isDegenerate(t){return!v(this.objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,n=this._root.halfSize;return t[3]<=n&&t[0]>=e[0]-n&&t[0]<=e[0]+n&&t[1]>=e[1]-n&&t[1]<=e[1]+n&&t[2]>=e[2]-n&&t[2]<=e[2]+n}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:e,_objectCount:n}=this,o=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:e,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:o}}}_nodeToJSON(t){var s,h;const e=t.children.map(d=>d?this._nodeToJSON(d):null),n=(s=t.residents)==null?void 0:s.map(d=>this.objectToBoundingSphere(d)),o=(h=t.terminals)==null?void 0:h.map(d=>this.objectToBoundingSphere(d));return{children:e,residents:n,terminals:o}}static fromJSON(t){const e=new R(n=>n,{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return e._objectCount=t.objectCount,e._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),e}};class c{constructor(){this.bounds=C(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,n,o=this.depth){return this.node=t??c.createEmptyNode(),e!=null&&P(e,this.bounds),this.halfSize=n,this.depth=o,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*ct}advance(t){let e=this.node.children[t];e||(e=c.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const n=at[t];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,e,n=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!n)return e&&e(this,-1),!1;this.node.residents=null}const o=this._childIndex(t);e&&e(this,o),this.advance(o)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new B({shrink:!0}),residents:new B({shrink:!0})}}static acquire(){return c._pool.acquire()}static release(t){c._pool.release(t)}static clearPool(){c._pool.prune()}}function jt(i,t){i[0]=Math.min(i[0],t[0]-t[3]),i[1]=Math.min(i[1],t[1]-t[3]),i[2]=Math.min(i[2],t[2]-t[3])}function Nt(i,t){i[0]=Math.max(i[0],t[0]+t[3]),i[1]=Math.max(i[1],t[1]+t[3]),i[2]=Math.max(i[2],t[2]+t[3])}function y(i,t,e){e[0]=i[0]+t,e[1]=i[1]+t,e[2]=i[2]+t}function st(i,t,e,n){if(t===1){const o=e(i[0]);P(o,n)}else{p[0]=1/0,p[1]=1/0,p[2]=1/0,b[0]=-1/0,b[1]=-1/0,b[2]=-1/0;for(let o=0;o<t;o++){const s=e(i[o]);v(s[3])&&(jt(p,s),Nt(b,s))}ft(n,p,b,.5),n[3]=Math.max(b[0]-p[0],b[1]-p[1],b[2]-p[2])/2}}function Et(i,t,e){if(!z.length)for(let n=0;n<8;++n)z.push({index:0,distance:0});for(let n=0;n<8;++n){const o=at[n];z.data[n].index=n,z.data[n].distance=j(i,t,o)}z.sort((n,o)=>n.distance-o.distance);for(let n=0;n<8;++n)e[n]=z.data[n].index}function k(i,t){let e,n=1/0;for(let o=0;o<8;++o){const s=j(i,t,rt[o]);s<n&&(n=s,e=rt[o])}return e}function j(i,t,e){return t*(i[0]*e[0]+i[1]*e[1]+i[2]*e[2])}function v(i){return!isNaN(i)&&i!==-1/0&&i!==1/0&&i>0}c._pool=new mt(c),function(i){var t;(t=i.DepthOrder||(i.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(J||(J={}));const at=[f(-1,-1,-1),f(1,-1,-1),f(-1,1,-1),f(1,1,-1),f(-1,-1,1),f(1,-1,1),f(-1,1,1),f(1,1,1)],rt=[f(-1,-1,-1),f(-1,-1,1),f(-1,1,-1),f(-1,1,1),f(1,-1,-1),f(1,-1,1),f(1,1,-1),f(1,1,1)],ct=Math.sqrt(3),G=[null];function Tt(i){return G[0]=i,G}const V=C(),g=E(),p=E(),b=E(),T=new B,zt=C(),x=C(),K=C(),H=C(),F=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],z=new B,ht=[0,0,0,0,0,0,0,0],dt=J,Ct=1e3;function Mt(i,t,e){const n=C(),o=N(n);return et(o,o,i,.5),et(o,o,t,.5),n[3]=W(o,i),M(o,o,e),n}let U=class{constructor(){this._idToComponent=new Map,this._components=new dt(i=>i.bounds),this._edges=new dt(i=>i.bounds),this._tmpLineSegment=bt(),this._tmpP1=E(),this._tmpP2=E(),this._tmpP3=E(),this.remoteClient=null}async fetchCandidates(i,t){await Promise.resolve(),gt(t),await this._ensureEdgeLocations(i,t);const e=[];return this._edges.forEachNeighbor(n=>(this._addCandidates(i,n,e),e.length<Ct),i.bounds),{result:{candidates:e}}}async _ensureEdgeLocations(i,t){const e=[];if(this._components.forEachNeighbor(s=>{if(s.info==null){const{id:h,uid:d}=s;e.push({id:h,uid:d})}return!0},i.bounds),!e.length)return;const n={components:e},o=await this.remoteClient.invoke("fetchAllEdgeLocations",n,t??{});for(const s of o.components)this._setFetchEdgeLocations(s)}async add(i){const t=new I(i.id,i.bounds);return this._idToComponent.set(t.id,t),this._components.add([t]),{result:{}}}async remove(i){const t=this._idToComponent.get(i.id);if(t){const e=[];this._edges.forEachNeighbor(n=>(n.component===t&&e.push(n),!0),t.bounds),this._edges.remove(e),this._components.remove([t]),this._idToComponent.delete(t.id)}return{result:{}}}_setFetchEdgeLocations(i){const t=this._idToComponent.get(i.id);if(t==null||i.uid!==t.uid)return;const e=Ot.createView(i.locations),n=new Array(e.count),o=E(),s=E();for(let r=0;r<e.count;r++){e.position0.getVec(r,o),e.position1.getVec(r,s);const a=Mt(o,s,i.origin),u=new Dt(t,r,a);n[r]=u}this._edges.add(n);const{objectIds:h,origin:d}=i;t.info={locations:e,objectIds:h,origin:d}}_addCandidates(i,t,e){const{info:n}=t.component,{origin:o,objectIds:s}=n,h=n.locations,d=h.position0.getVec(t.index,this._tmpP1),r=h.position1.getVec(t.index,this._tmpP2);M(d,d,o),M(r,r,o);const a=s[h.componentIndex.get(t.index)];this._addEdgeCandidate(i,a,d,r,e),this._addVertexCandidate(i,a,d,e),this._addVertexCandidate(i,a,r,e)}_addEdgeCandidate(i,t,e,n,o){if(!(i.types&ot.EDGE))return;const s=N(i.bounds),h=St(e,n,this._tmpLineSegment),d=xt(h,s,this._tmpP3);nt(i.bounds,d)&&o.push({type:"edge",objectId:t,target:$(d),distance:W(s,d),start:$(e),end:$(n)})}_addVertexCandidate(i,t,e,n){if(!(i.types&ot.VERTEX))return;const o=N(i.bounds);nt(i.bounds,e)&&n.push({type:"vertex",objectId:t,target:$(e),distance:W(o,e)})}};U=_t([pt("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],U);const Ut=U;class I{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++I.uid}}I.uid=0;class Dt{constructor(t,e,n){this.component=t,this.index=e,this.bounds=n}}export{Ut as default};
