import{L as k,m as V,E as K,C as A,bM as N}from"./index-b51e75d5.js";import{j as S,q as f,T,e as L,d as I,f as b,a as D,s as Y}from"./enums-08489827.js";const z=k.getLogger("esri.views.webgl.checkWebGLError");function H(s,e){switch(e){case s.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case s.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case s.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case s.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case s.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case s.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const C=!!V("enable-feature:webgl-debug");function q(){return C}function te(){return C}function M(s){if(q()){const e=s.getError();if(e){const i=H(s,e),r=new Error().stack;z.error(new K("webgl-error","WebGL error occured",{message:i,stack:r}))}}}const y=4;let d=class{constructor(e,i,r=null){if(this._context=e,this.type="texture",this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,e.instanceCounter.increment(S.Texture,this),this._descriptor={...i},e.type!==A.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),g(this._descriptor.target)))throw new Error("3D and array textures are not supported in WebGL1");this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){!this._context.gl||!this._glName||(this._context.unbindTexture(this),this._context.gl.deleteTexture(this._glName),this._glName=null,this._context.instanceCounter.decrement(S.Texture,this))}release(){this.dispose()}resize(e,i){const r=this._descriptor;if(!(r.width===e&&r.height===i)){if(this._wasImmutablyAllocated)throw new Error("Immutable textures can't be resized!");r.width=e,r.height=i,this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let i=f.TEXTURE_CUBE_MAP_POSITIVE_X;i<=f.TEXTURE_CUBE_MAP_NEGATIVE_Z;i++)this._setData(e,i)}setData(e){this._setData(e)}_setData(e,i){if(!this._context||!this._context.gl)return;const r=this._context.gl;M(r),this._glName||(this._glName=r.createTexture()),e===void 0&&(e=null);const t=this._descriptor,o=i??t.target,n=g(o);e===null&&(t.width=t.width||y,t.height=t.height||y,n&&(t.depth=t.depth??1));const p=this._context.bindTexture(this,d.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(d.TEXTURE_UNIT_FOR_UPDATES),P(this._context,t),this._configurePixelStorage(),M(r);const a=t.pixelFormat;let l=t.internalFormat??this._deriveInternalFormat(a,t.dataType);if(U(e)){let u=e.width,h=e.height;const m=1;e instanceof HTMLVideoElement&&(u=e.videoWidth,h=e.videoHeight),t.width&&t.height,n&&t.depth,t.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(o,l,t.hasMipmap,u,h,m),this._texImage(o,0,l,u,h,m,e),M(r),t.hasMipmap&&this.generateMipmap(),t.width||(t.width=u),t.height||(t.height=h),n&&!t.depth&&(t.depth=m)}else{const{width:u,height:h,depth:m}=t;if(u==null||h==null)throw new Error("Width and height must be specified!");if(n&&m==null)throw new Error("Depth must be specified!");if(t.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(o,l,t.hasMipmap,u,h,m),r.DEPTH24_STENCIL8&&l===r.DEPTH_STENCIL&&(l=r.DEPTH24_STENCIL8),R(e)){const c=e.levels,E=X(o,u,h,m),_=Math.min(E-1,c.length-1);this._context.gl2!=null?r.texParameteri(t.target,this._context.gl2.TEXTURE_MAX_LEVEL,_):t.hasMipmap=t.hasMipmap&&E===c.length;const x=l;if(!Z(x))throw new Error("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((w,W,B,v)=>{const O=c[Math.min(w,c.length-1)];this._compressedTexImage(o,w,x,W,B,v,O)},_)}else e!=null?(this._texImage(o,0,l,u,h,m,e),M(r),t.hasMipmap&&this.generateMipmap()):this._forEachMipmapLevel((c,E,_,x)=>{this._texImage(o,c,l,E,_,x,null),M(r)})}F(r,this._descriptor),G(r,this._descriptor),$(this._context,this._descriptor),M(r),this._context.bindTexture(p,d.TEXTURE_UNIT_FOR_UPDATES)}updateData(e,i,r,t,o,n,p=0){n||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const a=this._context.gl,l=this._descriptor,{pixelFormat:u,dataType:h,target:m,isImmutable:c}=l,E=l.internalFormat??this._deriveInternalFormat(u,h);if(c&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");const _=this._context.bindTexture(this,d.TEXTURE_UNIT_FOR_UPDATES,!0);if((i<0||r<0||t>l.width||o>l.height||i+t>l.width||r+o>l.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),p){if(this._context.gl2==null){console.error("Webgl2 must be enabled to use dataRowOffset!");return}a.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS,p)}if(U(n)?this._context.gl2!=null?this._context.gl2.texSubImage2D(m,e,i,r,t,o,u,h,n):a.texSubImage2D(m,e,i,r,u,h,n):R(n)?a.compressedTexSubImage2D(m,e,i,r,t,o,E,n.levels[e]):a.texSubImage2D(m,e,i,r,t,o,u,h,n),p){if(this._context.gl2==null){console.error("Webgl2 must be enabled to use dataRowOffset!");return}a.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS,0)}this._context.bindTexture(_,d.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,i,r,t,o,n,p,a){a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._context.gl2;if(l==null)throw new Error("3D textures are not supported in WebGL1");const u=this._descriptor,{pixelFormat:h,dataType:m,isImmutable:c,target:E}=u,_=u.internalFormat??this._deriveInternalFormat(h,m);if(c&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");g(E)||console.warn("Attempting to set 3D texture data on a non-3D texture");const x=this._context.bindTexture(this,d.TEXTURE_UNIT_FOR_UPDATES);if(this._context.setActiveTexture(d.TEXTURE_UNIT_FOR_UPDATES),(i<0||r<0||t<0||o>u.width||n>u.height||p>u.depth||i+o>u.width||r+n>u.height||t+p>u.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),R(a))a=a.levels[e],l.compressedTexSubImage3D(E,e,i,r,t,o,n,p,_,a);else{const w=a;l.texSubImage3D(E,e,i,r,t,o,n,p,h,m,w)}this._context.bindTexture(x,d.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new Error("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,P(this._context,e)}e.samplingMode===T.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=T.LINEAR_MIPMAP_NEAREST):e.samplingMode===T.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=T.NEAREST_MIPMAP_NEAREST);const i=this._context.bindTexture(this,d.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(d.TEXTURE_UNIT_FOR_UPDATES),this._context.gl.generateMipmap(e.target),this._context.bindTexture(i,d.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,P(this._context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._context.gl,i=this._descriptor;this._samplingModeDirty&&(F(e,i),this._samplingModeDirty=!1),this._wrapModeDirty&&(G(e,i),this._wrapModeDirty=!1)}_deriveInternalFormat(e,i){if(this._context.type===A.WEBGL1)return e;switch(i){case L.FLOAT:switch(e){case I.RGBA:return b.RGBA32F;case I.RGB:return b.RGB32F;default:throw new Error("Unable to derive format")}case L.UNSIGNED_BYTE:switch(e){case I.RGBA:return b.RGBA8;case I.RGB:return b.RGB8}default:return e}}_configurePixelStorage(){const e=this._context.gl,{unpackAlignment:i,flipped:r,preMultiplyAlpha:t}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,i),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t?1:0)}_texStorage(e,i,r,t,o,n){const p=this._context.gl2;if(p==null)throw new Error("Immutable textures are not supported in WebGL1");if(!j(i))throw new Error("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const a=r?X(e,t,o,n):1;if(g(e)){if(n==null)throw new Error("Missing depth dimension for 3D texture upload");p.texStorage3D(e,a,i,t,o,n)}else p.texStorage2D(e,a,i,t,o);this._wasImmutablyAllocated=!0}_texImage(e,i,r,t,o,n,p){const a=this._context.gl,l=g(e),{isImmutable:u,pixelFormat:h,dataType:m}=this._descriptor,c=this._context.type===A.WEBGL2,E=c?a:null;if(!c&&U(p)){a.texImage2D(e,0,r,h,m,p);return}if(u){if(p!=null){const _=p;if(l){if(n==null)throw new Error("Missing depth dimension for 3D texture upload");E.texSubImage3D(e,i,0,0,0,t,o,n,h,m,_)}else a.texSubImage2D(e,i,0,0,t,o,h,m,_)}}else{const _=p;if(l){if(n==null)throw new Error("Missing depth dimension for 3D texture upload");E.texImage3D(e,i,r,t,o,n,0,h,m,_)}else a.texImage2D(e,i,r,t,o,0,h,m,_)}}_compressedTexImage(e,i,r,t,o,n,p){const a=this._context.gl;let l=null;const u=g(e),h=this._descriptor.isImmutable;if(u){if(this._context.type!==A.WEBGL2)throw new Error("3D textures are not supported in WebGL1");l=a}if(h){if(p!=null)if(u){if(n==null)throw new Error("Missing depth dimension for 3D texture upload");l.compressedTexSubImage3D(e,i,0,0,0,t,o,n,r,p)}else a.compressedTexSubImage2D(e,i,0,0,t,o,r,p)}else if(u){if(n==null)throw new Error("Missing depth dimension for 3D texture upload");l.compressedTexImage3D(e,i,r,t,o,n,0,p)}else a.compressedTexImage2D(e,i,r,t,o,0,p)}_forEachMipmapLevel(e,i=1/0){let{width:r,height:t,depth:o,hasMipmap:n,target:p}=this._descriptor;const a=p===f.TEXTURE_3D;if(r==null||t==null||a&&o==null)throw new Error("Missing texture dimensions for mipmap calculation");for(let l=0;e(l,r,t,o),!(!n||r===1&&t===1&&(!a||o===1)||l>=i);++l)r=Math.max(1,r>>1),t=Math.max(1,t>>1),a&&(o=Math.max(1,o>>1))}};d.TEXTURE_UNIT_FOR_UPDATES=0;function P(s,e){(e.width!=null&&e.width<0||e.height!=null&&e.height<0||e.depth!=null&&e.depth<0)&&console.error("Negative dimension parameters are not allowed!");const i=s.type===A.WEBGL2;if(!i&&(e.isImmutable||g(e.target))&&console.error("Immutable and 3D-like textures are not supported in WebGL1!"),i)return;e.width!=null&&N(e.width)&&e.height!=null&&N(e.height)||(typeof e.wrapMode=="number"?e.wrapMode!==D.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):(e.wrapMode.s!==D.CLAMP_TO_EDGE||e.wrapMode.t!==D.CLAMP_TO_EDGE)&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),e.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))}function F(s,e){let i=e.samplingMode,r=e.samplingMode;i===T.LINEAR_MIPMAP_NEAREST||i===T.LINEAR_MIPMAP_LINEAR?(i=T.LINEAR,e.hasMipmap||(r=T.LINEAR)):(i===T.NEAREST_MIPMAP_NEAREST||i===T.NEAREST_MIPMAP_LINEAR)&&(i=T.NEAREST,e.hasMipmap||(r=T.NEAREST)),s.texParameteri(e.target,s.TEXTURE_MAG_FILTER,i),s.texParameteri(e.target,s.TEXTURE_MIN_FILTER,r)}function G(s,e){typeof e.wrapMode=="number"?(s.texParameteri(e.target,s.TEXTURE_WRAP_S,e.wrapMode),s.texParameteri(e.target,s.TEXTURE_WRAP_T,e.wrapMode)):(s.texParameteri(e.target,s.TEXTURE_WRAP_S,e.wrapMode.s),s.texParameteri(e.target,s.TEXTURE_WRAP_T,e.wrapMode.t))}function $(s,e){const i=s.capabilities.textureFilterAnisotropic;if(!i)return;s.gl.texParameterf(e.target,i.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}function j(s){return s in b}function Z(s){return s in Y}function R(s){return s!=null&&"type"in s&&s.type==="compressed"}function J(s){return s!=null&&"byteLength"in s}function U(s){return s!=null&&!R(s)&&!J(s)}function g(s){return s===f.TEXTURE_3D||s===f.TEXTURE_2D_ARRAY}function X(s,e,i,r=1){let t=Math.max(e,i);return s===f.TEXTURE_3D&&(t=Math.max(t,r)),Math.round(Math.log(t)/Math.LN2)+1}class re{constructor(){this.target=f.TEXTURE_2D,this.pixelFormat=I.RGBA,this.dataType=L.UNSIGNED_BYTE,this.samplingMode=T.LINEAR,this.wrapMode=D.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.width=0,this.height=0,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}}export{d as T,re as a,te as b,M as c,q as w};
