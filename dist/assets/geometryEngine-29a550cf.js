import{G as t}from"./geometryEngineBase-2fe41455.js";import{hydratedAdapter as r}from"./hydrated-3faf407e.js";import"./index-fb3bdf4f.js";function c(n){return Array.isArray(n)?n[0].spatialReference:n&&n.spatialReference}function R(n){return t.extendedSpatialReferenceInfo(n)}function h(n,e){return t.clip(r,c(n),n,e)}function w(n,e){return t.cut(r,c(n),n,e)}function x(n,e){return t.contains(r,c(n),n,e)}function S(n,e){return t.crosses(r,c(n),n,e)}function A(n,e,u){return t.distance(r,c(n),n,e,u)}function D(n,e){return t.equals(r,c(n),n,e)}function L(n,e){return t.intersects(r,c(n),n,e)}function T(n,e){return t.touches(r,c(n),n,e)}function V(n,e){return t.within(r,c(n),n,e)}function v(n,e){return t.disjoint(r,c(n),n,e)}function z(n,e){return t.overlaps(r,c(n),n,e)}function E(n,e,u){return t.relate(r,c(n),n,e,u)}function H(n){return t.isSimple(r,c(n),n)}function I(n){return t.simplify(r,c(n),n)}function C(n,e=!1){return t.convexHull(r,c(n),n,e)}function J(n,e){return t.difference(r,c(n),n,e)}function N(n,e){return t.symmetricDifference(r,c(n),n,e)}function b(n,e){return t.intersect(r,c(n),n,e)}function j(n,e=null){return t.union(r,c(n),n,e)}function q(n,e,u,i,f,s){return t.offset(r,c(n),n,e,u,i,f,s)}function B(n,e,u,i=!1){return t.buffer(r,c(n),n,e,u,i)}function P(n,e,u,i,f,s){return t.geodesicBuffer(r,c(n),n,e,u,i,f,s)}function G(n,e,u=!0){return t.nearestCoordinate(r,c(n),n,e,u)}function k(n,e){return t.nearestVertex(r,c(n),n,e)}function F(n,e,u,i){return t.nearestVertices(r,c(n),n,e,u,i)}function l(n){var e;return"xmin"in n?"center"in n?n.center:null:"x"in n?n:"extent"in n?((e=n.extent)==null?void 0:e.center)??null:null}function K(n,e,u){if(n==null)throw new a;const i=n.spatialReference;if(u=u??l(n),u==null)throw new a;const f=n.constructor.fromJSON(t.rotate(n,e,u));return f.spatialReference=i,f}function M(n,e){if(n==null)throw new a;const u=n.spatialReference;if(e=e??l(n),e==null)throw new a;const i=n.constructor.fromJSON(t.flipHorizontal(n,e));return i.spatialReference=u,i}function Q(n,e){if(n==null)throw new a;const u=n.spatialReference;if(e=e??l(n),e==null)throw new a;const i=n.constructor.fromJSON(t.flipVertical(n,e));return i.spatialReference=u,i}function U(n,e,u,i){return t.generalize(r,c(n),n,e,u,i)}function W(n,e,u){return t.densify(r,c(n),n,e,u)}function X(n,e,u,i=0){return t.geodesicDensify(r,c(n),n,e,u,i)}function Y(n,e){return t.planarArea(r,c(n),n,e)}function Z(n,e){return t.planarLength(r,c(n),n,e)}function _(n,e,u){return t.geodesicArea(r,c(n),n,e,u)}function $(n,e,u){return t.geodesicLength(r,c(n),n,e,u)}function O(n,e){return t.intersectLinesToPoints(r,c(n),n,e)}function m(n,e){t.changeDefaultSpatialReferenceTolerance(n,e)}function g(n){t.clearDefaultSpatialReferenceTolerance(n)}class a extends Error{constructor(){super("Illegal Argument Exception")}}export{B as buffer,m as changeDefaultSpatialReferenceTolerance,g as clearDefaultSpatialReferenceTolerance,h as clip,x as contains,C as convexHull,S as crosses,w as cut,W as densify,J as difference,v as disjoint,A as distance,D as equals,R as extendedSpatialReferenceInfo,M as flipHorizontal,Q as flipVertical,U as generalize,_ as geodesicArea,P as geodesicBuffer,X as geodesicDensify,$ as geodesicLength,b as intersect,O as intersectLinesToPoints,L as intersects,H as isSimple,G as nearestCoordinate,k as nearestVertex,F as nearestVertices,q as offset,z as overlaps,Y as planarArea,Z as planarLength,E as relate,K as rotate,I as simplify,N as symmetricDifference,T as touches,j as union,V as within};
