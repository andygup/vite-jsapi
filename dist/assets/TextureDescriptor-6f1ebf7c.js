import{J as B,m as $,s as V,b as M,bM as P}from"./index-6e11f365.js";import{t as S,M as g,L as d,G as N,P as w,U as A,D as b,u as k}from"./enums-74e97557.js";const z=B.getLogger("esri.views.webgl.checkWebGLError");function K(t,e){switch(e){case t.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case t.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case t.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case t.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case t.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case t.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const F=!!$("enable-feature:webgl-debug");function Y(){return F}function tt(){return F}function f(t){if(Y()){const e=t.getError();if(e){const r=K(t,e),i=new Error().stack;z.error(new V("webgl-error","WebGL error occured",{message:r,stack:i}))}}}const L=4;let E=class{constructor(t,e,r=null){if(this._context=t,this.type="texture",this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,t.instanceCounter.increment(S.Texture,this),this._descriptor={...e},t.type!==M.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),T(this._descriptor.target)))throw new Error("3D and array textures are not supported in WebGL1");this._descriptor.target===g.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._context.gl&&this._glName&&(this._context.unbindTexture(this),this._context.gl.deleteTexture(this._glName),this._glName=null,this._context.instanceCounter.decrement(S.Texture,this))}release(){this.dispose()}resize(t,e){const r=this._descriptor;if(r.width!==t||r.height!==e){if(this._wasImmutablyAllocated)throw new Error("Immutable textures can't be resized!");r.width=t,r.height=e,this._descriptor.target===g.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(t=null){for(let e=g.TEXTURE_CUBE_MAP_POSITIVE_X;e<=g.TEXTURE_CUBE_MAP_NEGATIVE_Z;e++)this._setData(t,e)}setData(t){this._setData(t)}_setData(t,e){if(!this._context||!this._context.gl)return;const r=this._context.gl;f(r),this._glName||(this._glName=r.createTexture()),t===void 0&&(t=null);const i=this._descriptor,s=e??i.target,o=T(s);t===null&&(i.width=i.width||L,i.height=i.height||L,o&&(i.depth=i.depth??1));const h=this._context.bindTexture(this,E.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES),D(this._context,i),this._configurePixelStorage(),f(r);const a=i.pixelFormat;let n=i.internalFormat??this._deriveInternalFormat(a,i.dataType);if(U(t)){let l=t.width,u=t.height;const _=1;t instanceof HTMLVideoElement&&(l=t.videoWidth,u=t.videoHeight),i.width&&i.height,o&&i.depth,i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(s,n,i.hasMipmap,l,u,_),this._texImage(s,0,n,l,u,_,t),f(r),i.hasMipmap&&this.generateMipmap(),i.width||(i.width=l),i.height||(i.height=u),o&&!i.depth&&(i.depth=_)}else{const{width:l,height:u,depth:_}=i;if(l==null||u==null)throw new Error("Width and height must be specified!");if(o&&_==null)throw new Error("Depth must be specified!");if(i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(s,n,i.hasMipmap,l,u,_),r.DEPTH24_STENCIL8&&n===r.DEPTH_STENCIL&&(n=r.DEPTH24_STENCIL8),R(t)){const m=t.levels,c=O(s,l,u,_),p=Math.min(c-1,m.length-1);this._context.gl2!=null?r.texParameteri(i.target,this._context.gl2.TEXTURE_MAX_LEVEL,p):i.hasMipmap=i.hasMipmap&&c===m.length;const x=n;if(!J(x))throw new Error("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((I,X,v,C)=>{const W=m[Math.min(I,m.length-1)];this._compressedTexImage(s,I,x,X,v,C,W)},p)}else t!=null?(this._texImage(s,0,n,l,u,_,t),f(r),i.hasMipmap&&this.generateMipmap()):this._forEachMipmapLevel((m,c,p,x)=>{this._texImage(s,m,n,c,p,x,null),f(r)})}y(r,this._descriptor),G(r,this._descriptor),H(this._context,this._descriptor),f(r),this._context.bindTexture(h,E.TEXTURE_UNIT_FOR_UPDATES)}updateData(t,e,r,i,s,o,h=0){o||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const a=this._context.gl,n=this._descriptor,{pixelFormat:l,dataType:u,target:_,isImmutable:m}=n,c=n.internalFormat??this._deriveInternalFormat(l,u);if(m&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");const p=this._context.bindTexture(this,E.TEXTURE_UNIT_FOR_UPDATES,!0);if((e<0||r<0||i>n.width||s>n.height||e+i>n.width||r+s>n.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),h){if(this._context.gl2==null)return void console.error("Webgl2 must be enabled to use dataRowOffset!");a.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS,h)}if(U(o)?this._context.gl2!=null?this._context.gl2.texSubImage2D(_,t,e,r,i,s,l,u,o):a.texSubImage2D(_,t,e,r,l,u,o):R(o)?a.compressedTexSubImage2D(_,t,e,r,i,s,c,o.levels[t]):a.texSubImage2D(_,t,e,r,i,s,l,u,o),h){if(this._context.gl2==null)return void console.error("Webgl2 must be enabled to use dataRowOffset!");a.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS,0)}this._context.bindTexture(p,E.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(t,e,r,i,s,o,h,a){a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const n=this._context.gl2;if(n==null)throw new Error("3D textures are not supported in WebGL1");const l=this._descriptor,{pixelFormat:u,dataType:_,isImmutable:m,target:c}=l,p=l.internalFormat??this._deriveInternalFormat(u,_);if(m&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");T(c)||console.warn("Attempting to set 3D texture data on a non-3D texture");const x=this._context.bindTexture(this,E.TEXTURE_UNIT_FOR_UPDATES);if(this._context.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES),(e<0||r<0||i<0||s>l.width||o>l.height||h>l.depth||e+s>l.width||r+o>l.height||i+h>l.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),R(a))a=a.levels[t],n.compressedTexSubImage3D(c,t,e,r,i,s,o,h,p,a);else{const I=a;n.texSubImage3D(c,t,e,r,i,s,o,h,u,_,I)}this._context.bindTexture(x,E.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const t=this._descriptor;if(!t.hasMipmap){if(this._wasImmutablyAllocated)throw new Error("Cannot add mipmaps to immutable texture after allocation");t.hasMipmap=!0,this._samplingModeDirty=!0,D(this._context,t)}t.samplingMode===d.LINEAR?(this._samplingModeDirty=!0,t.samplingMode=d.LINEAR_MIPMAP_NEAREST):t.samplingMode===d.NEAREST&&(this._samplingModeDirty=!0,t.samplingMode=d.NEAREST_MIPMAP_NEAREST);const e=this._context.bindTexture(this,E.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES),this._context.gl.generateMipmap(t.target),this._context.bindTexture(e,E.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(t){t!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=t,this._samplingModeDirty=!0)}setWrapMode(t){t!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=t,D(this._context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const t=this._context.gl,e=this._descriptor;this._samplingModeDirty&&(y(t,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(G(t,e),this._wrapModeDirty=!1)}_deriveInternalFormat(t,e){if(this._context.type===M.WEBGL1)return t;switch(e){case N.FLOAT:switch(t){case w.RGBA:return A.RGBA32F;case w.RGB:return A.RGB32F;default:throw new Error("Unable to derive format")}case N.UNSIGNED_BYTE:switch(t){case w.RGBA:return A.RGBA8;case w.RGB:return A.RGB8}default:return t}}_configurePixelStorage(){const t=this._context.gl,{unpackAlignment:e,flipped:r,preMultiplyAlpha:i}=this._descriptor;t.pixelStorei(t.UNPACK_ALIGNMENT,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r?1:0),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(t,e,r,i,s,o){const h=this._context.gl2;if(h==null)throw new Error("Immutable textures are not supported in WebGL1");if(!q(e))throw new Error("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const a=r?O(t,i,s,o):1;if(T(t)){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");h.texStorage3D(t,a,e,i,s,o)}else h.texStorage2D(t,a,e,i,s);this._wasImmutablyAllocated=!0}_texImage(t,e,r,i,s,o,h){const a=this._context.gl,n=T(t),{isImmutable:l,pixelFormat:u,dataType:_}=this._descriptor,m=this._context.type===M.WEBGL2,c=m?a:null;if(m||!U(h))if(l){if(h!=null){const p=h;if(n){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");c.texSubImage3D(t,e,0,0,0,i,s,o,u,_,p)}else a.texSubImage2D(t,e,0,0,i,s,u,_,p)}}else{const p=h;if(n){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");c.texImage3D(t,e,r,i,s,o,0,u,_,p)}else a.texImage2D(t,e,r,i,s,0,u,_,p)}else a.texImage2D(t,0,r,u,_,h)}_compressedTexImage(t,e,r,i,s,o,h){const a=this._context.gl;let n=null;const l=T(t),u=this._descriptor.isImmutable;if(l){if(this._context.type!==M.WEBGL2)throw new Error("3D textures are not supported in WebGL1");n=a}if(u){if(h!=null)if(l){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");n.compressedTexSubImage3D(t,e,0,0,0,i,s,o,r,h)}else a.compressedTexSubImage2D(t,e,0,0,i,s,r,h)}else if(l){if(o==null)throw new Error("Missing depth dimension for 3D texture upload");n.compressedTexImage3D(t,e,r,i,s,o,0,h)}else a.compressedTexImage2D(t,e,r,i,s,0,h)}_forEachMipmapLevel(t,e=1/0){let{width:r,height:i,depth:s,hasMipmap:o,target:h}=this._descriptor;const a=h===g.TEXTURE_3D;if(r==null||i==null||a&&s==null)throw new Error("Missing texture dimensions for mipmap calculation");for(let n=0;t(n,r,i,s),o&&(r!==1||i!==1||a&&s!==1)&&!(n>=e);++n)r=Math.max(1,r>>1),i=Math.max(1,i>>1),a&&(s=Math.max(1,s>>1))}};function D(t,e){(e.width!=null&&e.width<0||e.height!=null&&e.height<0||e.depth!=null&&e.depth<0)&&console.error("Negative dimension parameters are not allowed!");const r=t.type===M.WEBGL2;r||!e.isImmutable&&!T(e.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!"),!r&&(e.width!=null&&P(e.width)&&e.height!=null&&P(e.height)||(typeof e.wrapMode=="number"?e.wrapMode!==b.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):e.wrapMode.s===b.CLAMP_TO_EDGE&&e.wrapMode.t===b.CLAMP_TO_EDGE||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),e.hasMipmap&&console.error("Mipmapping requires power-of-two textures!")))}function y(t,e){let r=e.samplingMode,i=e.samplingMode;r===d.LINEAR_MIPMAP_NEAREST||r===d.LINEAR_MIPMAP_LINEAR?(r=d.LINEAR,e.hasMipmap||(i=d.LINEAR)):r!==d.NEAREST_MIPMAP_NEAREST&&r!==d.NEAREST_MIPMAP_LINEAR||(r=d.NEAREST,e.hasMipmap||(i=d.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,r),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,i)}function G(t,e){typeof e.wrapMode=="number"?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}function H(t,e){const r=t.capabilities.textureFilterAnisotropic;r&&t.gl.texParameterf(e.target,r.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}function q(t){return t in A}function J(t){return t in k}function R(t){return t!=null&&"type"in t&&t.type==="compressed"}function Z(t){return t!=null&&"byteLength"in t}function U(t){return t!=null&&!R(t)&&!Z(t)}function T(t){return t===g.TEXTURE_3D||t===g.TEXTURE_2D_ARRAY}function O(t,e,r,i=1){let s=Math.max(e,r);return t===g.TEXTURE_3D&&(s=Math.max(s,i)),Math.round(Math.log(s)/Math.LN2)+1}E.TEXTURE_UNIT_FOR_UPDATES=0;class et{constructor(){this.target=g.TEXTURE_2D,this.pixelFormat=w.RGBA,this.dataType=N.UNSIGNED_BYTE,this.samplingMode=d.LINEAR,this.wrapMode=b.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.width=0,this.height=0,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}}export{et as a,Y as b,f as c,tt as d,E as u};
