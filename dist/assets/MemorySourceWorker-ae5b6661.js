import{E as g,dC as v,bz as F,g4 as S,cp as R}from"./index-a9c4c008.js";import{h as O,j as Q,v as A}from"./featureConversionUtils-d43c9f43.js";import{i as M,f as k}from"./objectIdUtils-75d6d581.js";import{F as P}from"./FeatureStore-bdf249af.js";import{c as E,p as _}from"./projectionSupport-45f570d1.js";import{Q as Z}from"./QueryEngine-5a0f627c.js";import{c as C,a as G,b as L}from"./clientSideDefaults-0d467496.js";import{l as W,a as h,m as T,c as j,s as q}from"./sourceUtils-6587a5a0.js";import{F as $}from"./FieldsIndex-58671a99.js";import{k as z}from"./fieldType-ca53e87a.js";import"./OptimizedGeometry-af84d2ad.js";import"./OptimizedFeatureSet-5c82fe5a.js";import"./BoundsStore-20eda02d.js";import"./PooledRBush-968a22bf.js";import"./centroid-1116d1e7.js";import"./utils-dbf790c5.js";import"./normalizeUtils-e3f4b3bd.js";import"./normalizeUtilsCommon-82ae8352.js";import"./json-9ae8d6f8.js";import"./MemCache-75bedf1f.js";import"./QueryEngineResult-4d7db0c9.js";import"./quantizationUtils-b95043a5.js";import"./ItemCache-8ce94fa3.js";import"./WhereClause-741374f4.js";import"./executionError-e2eca390.js";import"./_commonjsHelpers-725317a4.js";import"./utils-cdb74f07.js";import"./generateRendererUtils-00b1e164.js";import"./QueryEngineCapabilities-60118ddb.js";import"./timeSupport-a17b5404.js";import"./defaultsJSON-b396ba80.js";const U=S,B={xmin:-180,ymin:-90,xmax:180,ymax:90,spatialReference:S},V={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};function N(y){return R(y)?y.z!=null:!!y.hasZ}function H(y){return R(y)?y.m!=null:!!y.hasM}class Oe{constructor(){this._queryEngine=null,this._nextObjectId=null}destroy(){this._queryEngine&&this._queryEngine&&this._queryEngine.destroy(),this._queryEngine=this._fieldsIndex=this._createDefaultAttributes=null}async load(e){const t=[],{features:o}=e,i=this._inferLayerProperties(o,e.fields),u=e.fields||[],d=e.hasM!=null?e.hasM:!!i.hasM,f=e.hasZ!=null?e.hasZ:!!i.hasZ,c=!e.spatialReference&&!i.spatialReference,m=c?U:e.spatialReference||i.spatialReference,p=c?B:null,s=e.geometryType||i.geometryType,a=!s;let l=e.objectIdField||i.objectIdField,r=e.timeInfo;if(!a&&(c&&t.push({name:"feature-layer:spatial-reference-not-found",message:"Spatial reference not provided or found in features. Defaults to WGS84"}),!s))throw new g("feature-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if(!l)throw new g("feature-layer:missing-property","objectIdField not set and couldn't be found in the provided fields");if(i.objectIdField&&l!==i.objectIdField&&(t.push({name:"feature-layer:duplicated-oid-field",message:`Provided objectIdField "${l}" doesn't match the field name "${i.objectIdField}", found in the provided fields`}),l=i.objectIdField),l&&!i.objectIdField){let n=null;u.some(D=>D.name===l?(n=D,!0):!1)?(n.type="esriFieldTypeOID",n.editable=!1,n.nullable=!1):u.unshift({alias:l,name:l,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const n of u){if(n.name==null&&(n.name=n.alias),n.alias==null&&(n.alias=n.name),!n.name)throw new g("feature-layer:invalid-field-name","field name is missing",{field:n});if(n.name===l&&(n.type="esriFieldTypeOID"),!z.jsonValues.includes(n.type))throw new g("feature-layer:invalid-field-type",`invalid type for field "${n.name}"`,{field:n})}const I={};for(const n of u)if(n.type!=="esriFieldTypeOID"&&n.type!=="esriFieldTypeGlobalID"){const b=v(n);b!==void 0&&(I[n.name]=b)}if(this._fieldsIndex=new $(u),this._createDefaultAttributes=C(I,l),r){if(r.startTimeField){const n=this._fieldsIndex.get(r.startTimeField);n?(r.startTimeField=n.name,n.type="esriFieldTypeDate"):r.startTimeField=null}if(r.endTimeField){const n=this._fieldsIndex.get(r.endTimeField);n?(r.endTimeField=n.name,n.type="esriFieldTypeDate"):r.endTimeField=null}if(r.trackIdField){const n=this._fieldsIndex.get(r.trackIdField);n?r.trackIdField=n.name:(r.trackIdField=null,t.push({name:"feature-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:r}}))}!r.startTimeField&&!r.endTimeField&&(t.push({name:"feature-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing or invalid",details:{timeInfo:r}}),r=null)}const x={warnings:t,featureErrors:[],layerDefinition:{...V,drawingInfo:G(s),templates:L(I),extent:p,geometryType:s,objectIdField:l,fields:u,hasZ:f,hasM:d,timeInfo:r},assignedObjectIds:{}};if(this._queryEngine=new Z({fields:u,geometryType:s,hasM:d,hasZ:f,objectIdField:l,spatialReference:m,featureStore:new P({geometryType:s,hasM:d,hasZ:f}),timeInfo:r,cacheSpatialQueries:!0}),!o||!o.length)return this._nextObjectId=M,x;const w=k(l,o);return this._nextObjectId=w+1,await E(o,m),this._loadInitialFeatures(x,o)}async applyEdits(e){const{spatialReference:t,geometryType:o}=this._queryEngine;return await Promise.all([W(t,o),E(e.adds,t),E(e.updates,t)]),this._applyEdits(e)}queryFeatures(e,t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e,t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e,t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e,t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_inferLayerProperties(e,t){let o,i,u=null,d=null,f=null;for(const c of e){const m=c.geometry;if(m!=null&&(u||(u=F(m)),d||(d=m.spatialReference),o==null&&(o=N(m)),i==null&&(i=H(m)),u&&d&&o!=null&&i!=null))break}if(t&&t.length){let c=null;t.some(p=>{const s=p.type==="esriFieldTypeOID",a=!p.type&&p.name&&p.name.toLowerCase()==="objectid";return c=p,s||a})&&(f=c.name)}return{geometryType:u,spatialReference:d,objectIdField:f,hasM:i,hasZ:o}}async _loadInitialFeatures(e,t){const{geometryType:o,hasM:i,hasZ:u,objectIdField:d,spatialReference:f,featureStore:c}=this._queryEngine,m=[];for(const a of t){if(a.uid!=null&&(e.assignedObjectIds[a.uid]=-1),a.geometry&&o!==F(a.geometry)){e.featureErrors.push(h("Incorrect geometry type."));continue}const l=this._createDefaultAttributes(),r=T(this._fieldsIndex,l,a.attributes,!0,e.warnings);if(r){e.featureErrors.push(r);continue}this._assignObjectId(l,a.attributes,!0),a.attributes=l,a.uid!=null&&(e.assignedObjectIds[a.uid]=a.attributes[d]),a.geometry!=null&&(a.geometry=_(a.geometry,a.geometry.spatialReference,f)),m.push(a)}c.addMany(O([],m,o,u,i,d));const{fullExtent:p,timeExtent:s}=await this._queryEngine.fetchRecomputedExtents();if(e.layerDefinition.extent=p,s){const{start:a,end:l}=s;e.layerDefinition.timeInfo.timeExtent=[a,l]}return e}async _applyEdits(e){const{adds:t,updates:o,deletes:i}=e,u={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(u,t),o&&o.length&&this._applyUpdateEdits(u,o),i&&i.length){for(const c of i)u.deleteResults.push(j(c));this._queryEngine.featureStore.removeManyById(i)}const{fullExtent:d,timeExtent:f}=await this._queryEngine.fetchRecomputedExtents();return{extent:d,timeExtent:f,featureEditResults:u}}_applyAddEdits(e,t){const{addResults:o}=e,{geometryType:i,hasM:u,hasZ:d,objectIdField:f,spatialReference:c,featureStore:m}=this._queryEngine,p=[];for(const s of t){if(s.geometry&&i!==F(s.geometry)){o.push(h("Incorrect geometry type."));continue}const a=this._createDefaultAttributes(),l=T(this._fieldsIndex,a,s.attributes);if(l){o.push(l);continue}if(this._assignObjectId(a,s.attributes),s.attributes=a,s.uid!=null){const r=s.attributes[f];e.uidToObjectId[s.uid]=r}if(s.geometry!=null){const r=s.geometry.spatialReference??c;s.geometry=_(q(s.geometry,r),r,c)}p.push(s),o.push(j(s.attributes[f]))}m.addMany(O([],p,i,d,u,f))}_applyUpdateEdits({updateResults:e},t){const{geometryType:o,hasM:i,hasZ:u,objectIdField:d,spatialReference:f,featureStore:c}=this._queryEngine;for(const m of t){const{attributes:p,geometry:s}=m,a=p&&p[d];if(a==null){e.push(h(`Identifier field ${d} missing`));continue}if(!c.has(a)){e.push(h(`Feature with object id ${a} missing`));continue}const l=Q(c.getFeature(a),o,u,i);if(s!=null){if(o!==F(s)){e.push(h("Incorrect geometry type."));continue}const r=s.spatialReference??f;l.geometry=_(q(s,r),r,f)}if(p){const r=T(this._fieldsIndex,l.attributes,p);if(r){e.push(r);continue}}c.add(A(l,o,u,i,d)),e.push(j(a))}}_assignObjectId(e,t,o=!1){const i=this._queryEngine.objectIdField;o?t&&isFinite(t[i])?e[i]=t[i]:e[i]=this._nextObjectId++:e[i]=this._nextObjectId++}}export{Oe as default};
