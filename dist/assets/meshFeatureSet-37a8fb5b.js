import{d as m,jx as P,C as w,X as Re,_ as Q,df as re,a3 as M,ke as Ne,kf as Ge,K as Z,bi as Ve,bo as Be,bm as Ze,e as d,y as x,a as Se,kg as Je,V as Xe,dR as se,iI as Me,fj as oe,es as Fe,dQ as J,kh as ie,ki as ae,kj as le,kk as ce,kl as ue,km as pe,ct as Le,et as fe,kn as N,ko as X,dt as We,kp as he,cm as Oe,cK as W,kq as Ye,kr as ee,ks as qe,kt as Ke,e7 as He,ku as ke,cM as Pe,aq as Qe,h2 as et,b7 as tt,kv as nt,g as rt,by as te,kw as st,j as ot,kx as it,bz as at,B as lt,ky as ct,aw as ge}from"./index-bdad94d1.js";import{r as H,k as ut,z as pt,x as ft,L as Y}from"./georeference-c22be248.js";import{o as me,h as ht,m as gt,i as mt,a as dt}from"./External-d77373a1.js";import{e as yt}from"./infoFor3D-5881142c.js";import{g as xt}from"./FeatureSet-973dd09f.js";const ne=m.getLogger("esri.geometry.support.meshUtils.centerAt");function wt(e,n,t){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=(t==null?void 0:t.origin)??e.origin;e.transform!=null?((t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&ne.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),vt(e.transform,n,r)):H(e.spatialReference,t)?bt(e,n,r):At(e,n,r)}function vt(e,n,t){const r=n.x-t.x,s=n.y-t.y,o=n.hasZ&&t.hasZ?n.z-t.z:0,i=e.origin;e.origin=[i[0]+r,i[1]+s,i[2]+o]}function bt(e,n,t){const r=ut(e.vertexAttributes,t,{geographic:!0}),{position:s,normal:o,tangent:i}=pt(r,n,{geographic:!0});e.vertexAttributes.position=s,e.vertexAttributes.normal=o,e.vertexAttributes.tangent=i,e.vertexAttributesChanged()}function At(e,n,t){const r=St,s=Rt;if(P(n,s,e.spatialReference)){if(!P(t,r,e.spatialReference)){const o=e.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,ne.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}$t(e.vertexAttributes.position,s,r),e.vertexAttributesChanged()}else ne.error(`Failed to project centerAt location (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}function $t(e,n,t){if(e)for(let r=0;r<e.length;r+=3)for(let s=0;s<3;s++)e[r+s]+=n[s]-t[s]}const Rt=w(),St=w();async function Mt(e,n,t){const{source:r}=n,{loadGLTFMesh:s}=await Re(Q(()=>import("./loadGLTFMesh-962f4178.js"),["assets/loadGLTFMesh-962f4178.js","assets/index-bdad94d1.js","assets/index-0492b785.css","assets/georeference-c22be248.js"]),t),o=await Lt(r,t);re(t);const i=s(new M({x:0,y:0,z:0,spatialReference:e.spatialReference}),o.url,{resolveFile:Ft(o),useTransform:!0,signal:t==null?void 0:t.signal});i.then(()=>o.dispose(),()=>o.dispose());const{vertexAttributes:a,components:l}=await i;e.vertexAttributes=a,e.components=l}function Ft(e){const n=Ne(e.url);return t=>{const r=Ge(t,n,n),s=r?r.replace(/^ *\.\//,""):null;return(s?e.files.get(s):null)??t}}async function Lt(e,n){if(Array.isArray(e)){if(!e.length)throw new Z("mesh-load-external:missing-assets","There must be at least one file to load");return e[0]instanceof File?kt(e):Pt(e,n)}return Ee(e)}async function Ot(e,n){const{parts:t}=e;if(t.length===1)return new q(t[0].partUrl);const r=await e.toBlob(n);return re(n),q.fromBlob(r)}function Ee(e){return q.fromBlob(e)}function kt(e){return Ce(e.map(n=>({name:n.name,mimeType:n.type,source:Ee(n)})))}async function Pt(e,n){const t=await Ve(e.map(async r=>{const s=await Ot(r);return re(n),{name:r.assetName,mimeType:r.assetMimeType,source:s}}));if(Be(n))throw t.forEach(r=>r.source.dispose()),Ze();return Ce(t)}const Et=/^(model\/gltf\+json)|(model\/gltf-binary)$/,Ct=/\.(gltf|glb)/i;function Ce(e){const n=new Map;let t=null;for(const{name:r,mimeType:s,source:o}of e)(t==null||Et.test(s)||Ct.test(r))&&(t=o.url),n.set(r,o.url),o.files.forEach((i,a)=>n.set(a,i));if(t==null)throw new Z("mesh-load-external:missing-files","Missing files to load external mesh source");return new q(t,()=>e.forEach(({source:r})=>r.dispose()),n)}let q=class _e{constructor(n,t=()=>{},r=new Map){this.url=n,this.dispose=t,this.files=r}static fromBlob(n){const t=URL.createObjectURL(n);return new _e(t,()=>URL.revokeObjectURL(t))}},k=class extends Je{constructor(){super(),this.externalSources=new Xe,this._explicitDisplaySource=null}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(n){if(n!=null&&!me(n))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=n,n&&this.externalSources.every(t=>!ht(t,n))&&this.externalSources.add(n)}clearSources(){this.displaySource=null,this.externalSources.removeAll()}getExternalSourcesOnService(n){return this.externalSources.items.filter(t=>gt(t,n))}get _implicitDisplaySource(){return this.externalSources.find(me)}};d([x()],k.prototype,"externalSources",void 0),d([x()],k.prototype,"displaySource",null),d([x()],k.prototype,"_implicitDisplaySource",null),d([x()],k.prototype,"_explicitDisplaySource",void 0),k=d([Se("esri.geometry.support.meshUtils.Metadata")],k);function _t(e,n,t){e.vertexAttributes&&e.vertexAttributes.position&&(e.transform!=null?((t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&m.getLogger("esri.geometry.support.meshUtils.offset").warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),It(e.transform,n)):H(e.spatialReference,t)?Tt(e,n):jt(e,n))}function It(e,n){const t=e.origin;e.origin=se(w(),t,n)}function Tt(e,n){const t=e.spatialReference,r=e.vertexAttributes.position,s=e.vertexAttributes.normal,o=e.vertexAttributes.tangent,i=new Float64Array(r.length),a=s!=null?new Float32Array(s.length):null,l=o!=null?new Float32Array(o.length):null,u=e.extent.center,c=zt;Me(t,[u.x,u.y,u.z],de,oe(t)),Fe(ye,de),J(c,n,ye),ie(r,t,i),s!=null&&a!=null&&ae(s,r,i,t,a),o!=null&&l!=null&&le(o,r,i,t,l),Ie(i,c),ce(i,r,t),s!=null&&a!=null&&ue(a,r,i,t,s),o!=null&&l!=null&&pe(l,r,i,t,o),e.vertexAttributesChanged()}function jt(e,n){Ie(e.vertexAttributes.position,n),e.vertexAttributesChanged()}function Ie(e,n){if(e)for(let t=0;t<e.length;t+=3)for(let r=0;r<3;r++)e[t+r]+=n[r]}const zt=w(),de=Le(),ye=fe();function Dt(){const{faceDescriptions:e,faceVertexOffsets:n,uvScales:t}=Xt,r=4*e.length,s=new Float64Array(3*r),o=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*e.length*3);let l=0,u=0,c=0,p=0;for(let f=0;f<e.length;f++){const h=e[f],b=l/3;for(const y of n)a[p++]=b+y;const F=h.corners;for(let y=0;y<4;y++){const $=F[y];let A=0;i[c++]=.25*t[y][0]+h.uvOrigin[0],i[c++]=h.uvOrigin[1]-.25*t[y][1];for(let R=0;R<3;R++)h.axis[R]!==0?(s[l++]=.5*h.axis[R],o[u++]=h.axis[R]):(s[l++]=.5*$[A++],o[u++]=0)}}return{position:s,normal:o,uv:i,faces:a}}function Ut(e,n){const t=e.components[0],r=t.faces,s=Wt[n],o=6*s,i=new Array(6),a=new Array(r.length-6);let l=0,u=0;for(let c=0;c<r.length;c++)c>=o&&c<o+6?i[l++]=r[c]:a[u++]=r[c];if(e.vertexAttributes.uv!=null){const c=new Float32Array(e.vertexAttributes.uv),p=4*s*2,f=[0,1,1,1,1,0,0,0];for(let h=0;h<f.length;h++)c[p+h]=f[h];e.vertexAttributes.uv=c}return e.components=[new N({faces:i,material:t.material}),new N({faces:a})],e}function Nt(e=0){const n=Math.round(8*2**e),t=2*n,r=(n-1)*(t+1)+2*t,s=new Float64Array(3*r),o=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(3*((n-1)*t*2));let l=0,u=0,c=0,p=0;for(let f=0;f<=n;f++){const h=f/n*Math.PI+.5*Math.PI,b=Math.cos(h),F=Math.sin(h);g[2]=F;const y=f===0||f===n,$=y?t-1:t;for(let A=0;A<=$;A++){const R=A/$*2*Math.PI;g[0]=-Math.sin(R)*b,g[1]=Math.cos(R)*b;for(let L=0;L<3;L++)s[l]=.5*g[L],o[l]=g[L],++l;i[u++]=(A+(y?.5:0))/t,i[u++]=f/n,f!==0&&A!==t&&(f!==n&&(a[c++]=p,a[c++]=p+1,a[c++]=p-t),f!==1&&(a[c++]=p,a[c++]=p-t,a[c++]=p-t-1)),p++}}return{position:s,normal:o,uv:i,faces:a}}function Gt(e=0){const t=Math.round(16*2**e),r=(5-1)*(t+1)+2*t,s=new Float64Array(3*r),o=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(3*(4*t));let l=0,u=0,c=0,p=0,f=0;for(let h=0;h<=5;h++){const b=h===0||h===5,F=h<=1||h>=5-1,y=h===2||h===4,$=b?t-1:t;for(let A=0;A<=$;A++){const R=A/$*2*Math.PI,L=b?0:.5;g[0]=L*Math.sin(R),g[1]=L*-Math.cos(R),g[2]=h<=2?.5:-.5;for(let C=0;C<3;C++)s[l++]=g[C],o[u++]=F?C===2?h<=1?1:-1:0:C===2?0:g[C]/L;i[c++]=(A+(b?.5:0))/t,i[c++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,y||h===0||A===t||(h!==5&&(a[p++]=f,a[p++]=f+1,a[p++]=f-t),h!==1&&(a[p++]=f,a[p++]=f-t,a[p++]=f-t-1)),f++}}return{position:s,normal:o,uv:i,faces:a}}function Vt(e,n){const t=typeof n=="number"?n:n!=null?n.width:1,r=typeof n=="number"?n:n!=null?n.height:1;switch(e){case"up":case"down":return{width:t,depth:r};case"north":case"south":return{width:t,height:r};case"east":case"west":return{depth:t,height:r}}}function Bt(e){const n=G.facingAxisOrderSwap[e],t=G.position,r=G.normal,s=new Float64Array(t.length),o=new Float32Array(r.length);let i=0;for(let a=0;a<4;a++){const l=i;for(let u=0;u<3;u++){const c=n[u],p=Math.abs(c)-1,f=c>=0?1:-1;s[i]=t[l+p]*f,o[i]=r[l+p]*f,i++}}return{position:s,normal:o,uv:new Float32Array(G.uv),faces:new Uint32Array(G.faces),isPlane:!0}}const _=1,I=2,T=3,G={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[T,_,I],west:[-T,-_,I],north:[-_,T,I],south:[_,-T,I],up:[_,I,T],down:[_,-I,-T]}};function V(e,n,t){e.isPlane||Zt(e),Jt(e,t==null?void 0:t.size);const{vertexAttributes:r,transform:s}=ft(e,n,t);return{vertexAttributes:new X({...r,uv:e.uv}),transform:s,components:[new N({faces:e.faces,material:t&&t.material||null})],spatialReference:n.spatialReference}}function Zt(e){for(let n=0;n<e.position.length;n+=3)e.position[n+2]+=.5}function Jt(e,n){if(n==null)return;const t=typeof n=="number"?[n,n,n]:[n.width!=null?n.width:1,n.depth!=null?n.depth:1,n.height!=null?n.height:1];O[0]=t[0],O[4]=t[1],O[8]=t[2];for(let r=0;r<e.position.length;r+=3){for(let s=0;s<3;s++)g[s]=e.position[r+s];J(g,g,O);for(let s=0;s<3;s++)e.position[r+s]=g[s]}if(t[0]!==t[1]||t[1]!==t[2]){O[0]=1/t[0],O[4]=1/t[1],O[8]=1/t[2];for(let r=0;r<e.normal.length;r+=3){for(let s=0;s<3;s++)g[s]=e.normal[r+s];J(g,g,O),We(g,g);for(let s=0;s<3;s++)e.normal[r+s]=g[s]}}}const Xt={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Wt={south:0,east:1,north:2,west:3,up:4,down:5},g=w(),O=fe(),Te=m.getLogger("esri.geometry.support.meshUtils.rotate");function Yt(e,n,t){if(!e.vertexAttributes||!e.vertexAttributes.position||n[3]===0)return;const r=e.spatialReference;if(e.transform!=null){(t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&Te.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const s=(t==null?void 0:t.origin)??e.transform.getOriginPoint(r);qt(e.transform,n,s)}else{const s=(t==null?void 0:t.origin)??e.origin;H(e.spatialReference,t)?Kt(e,n,s):Ht(e,n,s)}}function qt(e,n,t){const r=Oe(j,t.x,t.y,t.z),s=W(j,r,e.origin);e.applyLocalInverse(s,xe),e.rotation=Ye(e.rotation,n,he()),e.applyLocalInverse(s,s),W(s,s,xe),e.translation=se(w(),e.translation,s)}function Kt(e,n,t){const r=e.spatialReference,s=oe(r),o=je;P(t,o,s)||P(e.origin,o,s);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,u=new Float64Array(i.length),c=a!=null?new Float32Array(a.length):null,p=l!=null?new Float32Array(l.length):null;Me(s,o,K,s),Fe(ve,K);const f=we;J(ee(we),ee(n),ve),f[3]=n[3],ie(i,r,u),a!=null&&c!=null&&ae(a,i,u,r,c),l!=null&&p!=null&&le(l,i,u,r,p),D(u,f,3,o),ce(u,i,r),a!=null&&c!=null&&(D(c,f,3),ue(c,i,u,r,a)),l!=null&&p!=null&&(D(p,f,4),pe(p,i,u,r,l)),e.vertexAttributesChanged()}function Ht(e,n,t){const r=je;if(!P(t,r,e.spatialReference)){const s=e.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,Te.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}D(e.vertexAttributes.position,n,3,r),D(e.vertexAttributes.normal,n,3),D(e.vertexAttributes.tangent,n,4),e.vertexAttributesChanged()}function D(e,n,t,r=ke){if(e!=null){qe(K,Ke(n),ee(n));for(let s=0;s<e.length;s+=t){for(let o=0;o<3;o++)j[o]=e[s+o]-r[o];He(j,j,K);for(let o=0;o<3;o++)e[s+o]=j[o]+r[o]}}}const j=w(),xe=w(),we=he(),K=Le(),ve=fe(),je=w(),ze=m.getLogger("esri.geometry.support.meshUtils.scale");function Qt(e,n,t){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if(e.transform!=null){(t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&ze.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const s=(t==null?void 0:t.origin)??e.transform.getOriginPoint(r);en(e.transform,n,s)}else{const s=H(e.spatialReference,t),o=t&&t.origin||e.origin;s?tn(e,n,o):nn(e,n,o)}}function en(e,n,t){const r=Oe(z,t.x,t.y,t.z),s=W(z,r,e.origin);e.applyLocalInverse(s,be);const o=Pe(w(),e.scale,n);e.scale=o,e.applyLocalInverse(s,s),W(s,s,be),e.translation=se(w(),e.translation,s)}function tn(e,n,t){const r=e.spatialReference,s=oe(r),o=Ue;P(t,o,s)||P(e.origin,o,s);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,u=new Float64Array(i.length),c=a!=null?new Float32Array(a.length):null,p=l!=null?new Float32Array(l.length):null;ie(i,r,u),a!=null&&c!=null&&ae(a,i,u,r,c),l!=null&&p!=null&&le(l,i,u,r,p),De(u,n,o),ce(u,i,r),a!=null&&c!=null&&ue(c,i,u,r,a),l!=null&&p!=null&&pe(p,i,u,r,l),e.vertexAttributesChanged()}function nn(e,n,t){const r=Ue;if(!P(t,r,e.spatialReference)){const s=e.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,ze.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}De(e.vertexAttributes.position,n,r),e.vertexAttributesChanged()}function De(e,n,t=ke){if(e)for(let r=0;r<e.length;r+=3){for(let s=0;s<3;s++)z[s]=e[r+s]-t[s];Pe(z,z,n);for(let s=0;s<3;s++)e[r+s]=z[s]+t[s]}}const z=w(),be=w(),Ue=w();var S;const E="esri.geometry.Mesh";let v=S=class extends Qe(et.LoadableMixin(tt(nt))){constructor(e){super(e),this.components=null,this.transform=null,this.metadata=new k,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new X,this.type="mesh"}initialize(){(this.metadata.externalSources.length===0||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add(rt(()=>{var e;return{vertexAttributes:this.vertexAttributes,components:(e=this.components)==null?void 0:e.map(n=>n.clone())}},()=>this._clearSources(),{once:!0,sync:!0}))})}get hasExtent(){var e;return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):((e=this.metadata.displaySource)==null?void 0:e.extent)!=null}get _boundingInfo(){const e=this.vertexAttributes.position,n=this.spatialReference;if(e.length===0||this.components&&this.components.length===0)return{extent:new te({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:n}),center:new M({x:0,y:0,z:0,spatialReference:n})};const t=this.transform!=null?this.transform.project(e,n):e;let r=1/0,s=1/0,o=1/0,i=-1/0,a=-1/0,l=-1/0,u=0,c=0,p=0;const f=t.length,h=1/(f/3);let b=0;for(;b<f;){const F=t[b++],y=t[b++],$=t[b++];r=Math.min(r,F),s=Math.min(s,y),o=Math.min(o,$),i=Math.max(i,F),a=Math.max(a,y),l=Math.max(l,$),u+=h*F,c+=h*y,p+=h*$}return{extent:new te({xmin:r,ymin:s,zmin:o,xmax:i,ymax:a,zmax:l,spatialReference:n}),center:new M({x:u,y:c,z:p,spatialReference:n})}}get anchor(){if(this.transform!=null)return this.transform.getOriginPoint(this.spatialReference);const e=this._boundingInfo;return new M({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return this.transform!=null?this.transform.getOriginPoint(this.spatialReference):this._boundingInfo.center}get extent(){var e,n;return this.loaded||((n=(e=this.metadata)==null?void 0:e.displaySource)==null?void 0:n.extent)==null?this._boundingInfo.extent:this.metadata.displaySource.extent.clone()}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(N.from(e)),this.notifyChange("components")):m.getLogger(this.declaredClass).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const n=this.components.indexOf(e);if(n!==-1)return this.components.splice(n,1),void this.notifyChange("components")}m.getLogger(this.declaredClass).error("removeComponent()","Provided component is not part of the list of components")}else m.getLogger(this.declaredClass).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,n,t,r){return st(e,n,t,Ae),Yt(this,Ae,r),this}offset(e,n,t,r){return this.loaded?(B[0]=e,B[1]=n,B[2]=t,_t(this,B,r),this):(m.getLogger(this.declaredClass).error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,n){return this.loaded?(Qt(this,e,n),this):(m.getLogger(this.declaredClass).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,n){return this.loaded?(wt(this,e,n),this):(m.getLogger(this.declaredClass).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){const{metadata:{displaySource:n}}=this;return n&&this.addResolvingPromise(Mt(this,n,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(){let e=null;if(this.components){const t=new Map,r=new Map;e=this.components.map(s=>s.cloneWithDeduplication(t,r))}const n={components:e,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:this.transform!=null?this.transform.clone():null,metadata:this.metadata.clone()};return new S(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const n=Q(()=>import("./gltfexport-d578c40e.js"),["assets/gltfexport-d578c40e.js","assets/index-bdad94d1.js","assets/index-0492b785.css","assets/georeference-c22be248.js","assets/imageutils-b74e3b36.js"]),t=this.load(),r=await Promise.all([n,t]),{toBinaryGLTF:s}=r[0];return s(this,e)}_clearSources(){this.metadata.clearSources()}static createBox(e,n){if(!(e instanceof M))return m.getLogger(E).error(".createBox()","expected location to be a Point instance"),null;const t=new S(V(Dt(),e,n));return n&&n.imageFace&&n.imageFace!=="all"?Ut(t,n.imageFace):t}static createSphere(e,n){return e instanceof M?new S(V(Nt(n&&n.densificationFactor||0),e,n)):(m.getLogger(E).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,n){return e instanceof M?new S(V(Gt(n&&n.densificationFactor||0),e,n)):(m.getLogger(E).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,n){if(!(e instanceof M))return m.getLogger(E).error(".createPlane()","expected location to be a Point instance"),null;const t=(n==null?void 0:n.facing)??"up",r=Vt(t,n==null?void 0:n.size);return new S(V(Bt(t),e,{...n,size:r}))}static createFromPolygon(e,n){if(!(e instanceof ot))return m.getLogger(E).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const t=it(e);return new S({vertexAttributes:new X({position:t.position}),components:[new N({faces:t.faces,shading:"flat",material:(n==null?void 0:n.material)??null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,n,t){if(!(e instanceof M))throw m.getLogger(E).error(".createfromGLTF()","expected location to be a Point instance"),new Z("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=await Re(Q(()=>import("./loadGLTFMesh-962f4178.js"),["assets/loadGLTFMesh-962f4178.js","assets/index-bdad94d1.js","assets/index-0492b785.css","assets/georeference-c22be248.js"]),t);return new S(await r(e,n,t))}static createWithExternalSource(e,n,t){var l;const r=(t==null?void 0:t.extent)??null,s=((l=t==null?void 0:t.transform)==null?void 0:l.clone())??new Y;s.origin=[e.x,e.y,e.z??0];const o=e.spatialReference,i={source:n,extent:r},a=new k;return a.externalSources.push(i),new S({metadata:a,transform:s,spatialReference:o})}static createIncomplete(e,n){var o;const t=((o=n==null?void 0:n.transform)==null?void 0:o.clone())??new Y;t.origin=[e.x,e.y,e.z??0];const r=e.spatialReference,s=new S({transform:t,spatialReference:r});return s.addResolvingPromise(Promise.reject(new Z("mesh-incomplete","Mesh resources are not complete"))),s}};d([x({type:[N],json:{write:!0}})],v.prototype,"components",void 0),d([x({type:Y,json:{write:!0}})],v.prototype,"transform",void 0),d([x({constructOnly:!0})],v.prototype,"metadata",void 0),d([x({readOnly:!0})],v.prototype,"hasExtent",null),d([x({readOnly:!0})],v.prototype,"_boundingInfo",null),d([x({readOnly:!0})],v.prototype,"anchor",null),d([x({readOnly:!0})],v.prototype,"origin",null),d([x({readOnly:!0,json:{read:!1}})],v.prototype,"extent",null),d([x({readOnly:!0,json:{read:!1,write:!0,default:!0}})],v.prototype,"hasZ",void 0),d([x({readOnly:!0,json:{read:!1,write:!0,default:!1}})],v.prototype,"hasM",void 0),d([x({type:X,nonNullable:!0,json:{write:!0}})],v.prototype,"vertexAttributes",void 0),v=S=d([Se(E)],v);const B=w(),Ae=he(),$e=v;function xn(e,n,t){const r=t.features;t.features=[],delete t.geometryType;const s=xt.fromJSON(t);if(s.geometryType="mesh",!t.assetMaps)return s;const o=ln(n,t.assetMaps),i=s.spatialReference??at.WGS84,a=t.globalIdFieldName,{outFields:l}=e,u=l!=null&&l.length>0?rn(l.includes("*")?null:new Set(l)):()=>({});for(const c of r){const p=sn(c,a,i,n,o);p!=null&&s.features.push(new lt({geometry:p,attributes:u(c)}))}return s}function rn(e){return({attributes:n})=>{if(!n)return{};if(!e)return n;for(const t in n)e.has(t)||delete n[t];return n}}function sn(e,n,t,r,s){const o=e.attributes[n],i=s.get(o);if(i==null)return null;const a=on(e,t,r),l=te.fromJSON(e.geometry);l.spatialReference=t;const u=an(e.attributes,r,i.projectVertices),c=cn(i);return c?$e.createWithExternalSource(a,c,{extent:l,transform:u}):$e.createIncomplete(a,{extent:l,transform:u})}function on({attributes:e},n,{transformFieldRoles:t}){return new M({x:e[t.originX],y:e[t.originY],z:e[t.originZ],spatialReference:n})}function an(e,{transformFieldRoles:n},t){return new Y({translation:[e[n.translationX],-e[n.translationZ],e[n.translationY]],rotation:ct([e[n.rotationX],e[n.rotationZ],e[n.rotationY]],e[n.rotationDeg]),scale:[e[n.scaleX],e[n.scaleY],e[n.scaleZ]],geographic:t})}var U;function ln(e,n){const t=new Map;for(const r of n){const s=r.parentGlobalId;if(s==null)continue;const o=r.assetName,i=r.assetType,a=r.assetHash,l=r.assetURL,u=r.conversionStatus,c=r.seqNo,p=yt(i,e.supportedFormats);if(!p){m.getLogger("esri.rest.support.meshFeatureSet").error("mesh-feature-set:unknown-format",`Service returned an asset of type ${i}, but it does not list it as a supported type`);continue}const f=ge(t,s,()=>({projectVertices:pn(r.flags).projectVertices,files:new Map}));ge(f.files,o,()=>({name:o,type:i,mimeType:p,status:un(u),parts:[]})).parts[c]={hash:a,url:l}}return t}function cn(e){const n=Array.from(e.files.values()),t=new Array;for(const r of n){if(r.status!==U.COMPLETED)return null;const s=new Array;for(const o of r.parts){if(!o)return null;s.push(new mt(o.url,o.hash))}t.push(new dt(r.name,r.mimeType,s))}return t}function un(e){switch(e){case"COMPLETED":case"SUBMITTED":return U.COMPLETED;case"INPROGRESS":return U.PENDING;default:return U.FAILED}}function pn(e){return{projectVertices:e.includes("PROJECT_VERTICES")}}(function(e){e[e.FAILED=0]="FAILED",e[e.PENDING=1]="PENDING",e[e.COMPLETED=2]="COMPLETED"})(U||(U={}));export{ln as assetMapFromAssetMapsJSON,sn as extractMesh,xn as meshFeatureSetFromJSON};
