import{K as O}from"./index-b4b3ae7d.js";import{p as K,b as L,s as q}from"./rasterProjectionHelper-99af23ff.js";class F{constructor(n=15e3,e=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=n,this._interval=Math.min(n,e)}decreaseRefCount(n,e){const t=n+"/"+e,c=this._cachedBlocks;if(c.has(t)){const o=c.get(t);return o.refCount--,o.refCount<=0&&(c.delete(t),o.controller&&o.controller.abort()),o.refCount}return 0}getBlock(n,e){const t=n+"/"+e,c=this._cachedBlocks;if(c.has(t)){const o=c.get(t);return o.ts=Date.now(),o.refCount++,c.delete(t),c.set(t,o),o.block}return null}putBlock(n,e,t,c){const o=this._cachedBlocks,i=n+"/"+e;if(o.has(i)){const a=o.get(i);a.ts=Date.now(),a.refCount++}else o.set(i,{block:t,ts:Date.now(),refCount:1,controller:c});this._trim(),this._updateTimer()}deleteBlock(n,e){const t=this._cachedBlocks,c=n+"/"+e;t.has(c)&&t.delete(c)}updateMaxSize(n){this._size=n,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const n=this._cachedBlocks;this._timer=setInterval(()=>{const e=Array.from(n),t=Date.now();for(let c=0;c<e.length&&e[c][1].ts<=t-this._duration;c++)n.delete(e[c][0]);n.size===0&&this._clearTimer()},this._interval)}_trim(){const n=this._cachedBlocks;if(this._size===-1||this._size>=n.size)return;const e=Array.from(n);for(let t=0;t<e.length-this._size;t++)n.delete(e[t][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}}const f=new Map,d=new F;function Q(s,n){return n==null?s:`${s}?sliceId=${n}`}function U(s,n){const e={extent:null,rasterInfo:n,cache:new Map},t=f.get(s);return t?(t.push(e),t.length-1):(f.set(s,[e]),0)}function V(s,n){const e=f.get(s);e&&(e[n]=null,e.some(t=>t!=null)||f.delete(s))}function X(s,n,e){var i,a;const t=f.get(s);if(!t)return n==null?d.decreaseRefCount(s,e):0;if(n==null||t[n]==null)return d.decreaseRefCount(s,e);const c=(i=t[n])==null?void 0:i.cache,o=c==null?void 0:c.get(e);if(c&&o){if(o.refCount--,o.refCount===0){c.delete(e);for(let l=0;l<t.length;l++)(a=t[l])==null||a.cache.delete(e);o.controller&&o.controller.abort()}return o.refCount}return 0}function Y(s,n,e){var o,i,a;const t=f.get(s);if(!t)return n==null?d.getBlock(s,e):null;if(n==null||t[n]==null){for(let l=0;l<t.length;l++){const r=(o=t[l])==null?void 0:o.cache.get(e);if(r)return r.refCount++,r.block}return d.getBlock(s,e)}const c=(i=t[n])==null?void 0:i.cache.get(e);if(c)return c.refCount++,c.block;for(let l=0;l<t.length;l++){if(l===n||!t[l])continue;const r=(a=t[l])==null?void 0:a.cache,m=r==null?void 0:r.get(e);if(r&&m)return m.refCount++,r.set(e,m),m.block}return null}function Z(s,n,e,t,c=null){var a;const o=f.get(s);if(!o){n==null&&d.putBlock(s,e,t,c);return}if(n==null||o[n]==null){d.putBlock(s,e,t,c);return}const i={refCount:1,block:t,isResolved:!1,isRejected:!1,controller:c};t.then(()=>i.isResolved=!0).catch(()=>i.isRejected=!0),(a=o[n])==null||a.cache.set(e,i)}function P(s,n,e){var c;const t=f.get(s);if(!t){n==null&&d.deleteBlock(s,e);return}if(n==null||t[n]==null){d.deleteBlock(s,e);return}(c=t[n])==null||c.cache.delete(e)}function G(s,n){const e=f.get(s);return e?e[n]??null:null}function I(s,n,e,t,c,o,i=null){const a=G(s,n);if(!a)return;const l=a.extent,{cache:r,rasterInfo:m}=a;if(l&&l.xmin===e.xmin&&l.xmax===e.xmax&&l.ymin===e.ymin&&l.ymax===e.ymax)return;t=t??0;const R=e.clone().normalize(),{spatialReference:w,transform:y}=m,v=new Set;for(let _=0;_<R.length;_++){const u=R[_];if(u.xmax-u.xmin<=t||u.ymax-u.ymin<=t)continue;let h=K(u,w,i);y!=null&&(h=y.inverseTransform(h));const j=new O({x:t,y:t,spatialReference:u.spatialReference});if(c==null&&(c=L(j,w,u,i),!c))return;const{pyramidLevel:C,pyramidResolution:k,excessiveReading:S}=q(c,m,o||"closest");if(S)return;const{storageInfo:x}=m,{origin:z}=x,B={x:Math.max(0,Math.floor((h.xmin-z.x)/k.x)),y:Math.max(0,Math.floor((z.y-h.ymax)/k.y))},$=Math.ceil((h.xmax-h.xmin)/k.x-.1),T=Math.ceil((h.ymax-h.ymin)/k.y-.1),E=C>0?x.pyramidBlockWidth:x.blockWidth,b=C>0?x.pyramidBlockHeight:x.blockHeight,p=1,A=Math.max(0,Math.floor(B.x/E)-p),D=Math.max(0,Math.floor(B.y/b)-p),H=Math.floor((B.x+$-1)/E)+p,W=Math.floor((B.y+T-1)/b)+p;for(let g=D;g<=W;g++)for(let M=A;M<=H;M++)v.add(`${C}/${g}/${M}`)}r.forEach((_,u)=>{if(!v.has(u)){const h=r.get(u);(h==null||h.isResolved||h.isRejected)&&r.delete(u)}}),a.extent={xmin:e.xmin,ymin:e.ymin,xmax:e.xmax,ymax:e.ymax}}export{V as a,Y as b,X as c,P as d,Q as g,Z as p,U as r,I as u};
