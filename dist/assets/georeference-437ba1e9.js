import{e as u,y as g,a as P,bB as q,C as A,kn as M,kx as L,ky as T,kr as D,kp as E,kz as H,iT as R,ct as h,e7 as $,fj as d,iG as j,cf as W,dW as F,kA as f,dX as J,kB as K,kC as _,dC as U,a3 as X,kD as Y,kE as Q,kF as m,kG as S,kH as N,ki as V,kI as y,kj as Z,kk as tt,kJ as nt,kf as et,kg as ot,kh as it,W as rt,d4 as at,g_ as lt,et as st,kK as ct,kL as ut}from"./index-0b6846a6.js";var x;let c=x=class extends q{constructor(t){super(t),this.origin=A(),this.translation=A(),this.rotation=M(),this.scale=L(1,1,1),this.geographic=!0}get localMatrix(){const t=h();return T(b,E(this.rotation),D(this.rotation)),H(t,b,this.translation,this.scale),t}get localMatrixInverse(){return R(h(),this.localMatrix)}applyLocal(t,n){return $(n,t,this.localMatrix)}applyLocalInverse(t,n){return $(n,t,this.localMatrixInverse)}project(t,n){if(this.geographic){const i=d(n),a=h();j(n,this.origin,a,i),W(a,a,this.localMatrix);const s=F(t.length);return f(s,t,a),J(s,i,0,s,n,0,s.length/3),s}const{localMatrix:e,origin:o}=this,r=K(e,_)?U(t):f(F(t.length),t,e);for(let i=0;i<r.length;i+=3)r[i]+=o[0],r[i+1]+=o[1],r[i+2]+=o[2];return r}getOriginPoint(t){const[n,e,o]=this.origin;return new X({x:n,y:e,z:o,spatialReference:t})}equals(t){return t!=null&&this.geographic===t.geographic&&Y(this.origin,t.origin)&&Q(this.localMatrix,t.localMatrix)}clone(){const t={origin:m(this.origin),translation:m(this.translation),rotation:M(this.rotation),scale:m(this.scale),geographic:this.geographic};return new x(t)}};u([g({type:[Number],nonNullable:!0,json:{write:!0}})],c.prototype,"origin",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],c.prototype,"translation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],c.prototype,"rotation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],c.prototype,"scale",void 0),u([g({type:Boolean,nonNullable:!0,json:{write:!0}})],c.prototype,"geographic",void 0),u([g()],c.prototype,"localMatrix",null),u([g()],c.prototype,"localMatrixInverse",null),c=x=u([P("esri.geometry.support.MeshTransform")],c);const b=S(),gt=c;function G(t,n){return t.isGeographic||t.isWebMercator&&((n==null?void 0:n.geographic)??!0)}function I(t,n,e){return G(n.spatialReference,e)?ft(t,n,e):ht(t,n,e)}function pt(t,n,e){const{position:o,normal:r,tangent:i}=t;if(n==null)return{position:o,normal:r,tangent:i};const a=n.localMatrix;return I({position:f(new Float64Array(o.length),o,a),normal:r!=null?ct(r,new Float32Array(r.length),a):null,tangent:i!=null?ut(i,new Float32Array(i.length),a):null},n.getOriginPoint(e),{geographic:n.geographic})}function bt(t,n,e){if(e!=null&&e.useTransform){const{position:o,normal:r,tangent:i}=t;return{vertexAttributes:{position:o,normal:r,tangent:i},transform:new gt({origin:[n.x,n.y,n.z??0],geographic:!0})}}return{vertexAttributes:I(t,n,e),transform:null}}function z(t,n,e){return G(n.spatialReference,e)?xt(t,n,e):O(t,n,e)}function zt(t,n,e,o){if(n==null)return z(t,e,o);const r=pt(t,n,e.spatialReference);return e.equals(n.getOriginPoint(e.spatialReference))?O(r,e,o):z(r,e,o)}function ht(t,n,e){const o=new Float64Array(t.position.length),r=t.position,i=n.x,a=n.y,s=n.z||0,{horizontal:p,vertical:k}=v(e?e.unit:null,n.spatialReference);for(let l=0;l<r.length;l+=3)o[l]=r[l]*p+i,o[l+1]=r[l+1]*p+a,o[l+2]=r[l+2]*k+s;return{position:o,normal:t.normal,tangent:t.tangent}}function ft(t,n,e){const o=n.spatialReference,r=B(n,e,w),i=new Float64Array(t.position.length),a=yt(t.position,r,o,i),s=N(C,r);return{position:a,normal:kt(a,i,t.normal,s,o),tangent:mt(a,i,t.tangent,s,o)}}function yt(t,n,e,o){f(o,t,n);const r=new Float64Array(t.length);return V(o,r,e)}function kt(t,n,e,o,r){if(e==null)return null;const i=new Float32Array(e.length);return y(i,e,o),Z(i,t,n,r,i),i}function mt(t,n,e,o,r){if(e==null)return null;const i=new Float32Array(e.length);y(i,e,o,4);for(let a=3;a<i.length;a+=4)i[a]=e[a];return tt(i,t,n,r,i),i}function O(t,n,e){const o=new Float64Array(t.position.length),r=t.position,i=n.x,a=n.y,s=n.z||0,{horizontal:p,vertical:k}=v(e?e.unit:null,n.spatialReference);for(let l=0;l<r.length;l+=3)o[l]=(r[l]-i)/p,o[l+1]=(r[l+1]-a)/p,o[l+2]=(r[l+2]-s)/k;return{position:o,normal:t.normal,tangent:t.tangent}}function xt(t,n,e){const o=n.spatialReference;B(n,e,w);const r=R(Mt,w),i=new Float64Array(t.position.length),a=wt(t.position,o,r,i),s=N(C,r);return{position:a,normal:vt(t.normal,t.position,i,o,s),tangent:At(t.tangent,t.position,i,o,s)}}function B(t,n,e){j(t.spatialReference,[t.x,t.y,t.z||0],e,d(t.spatialReference));const{horizontal:o,vertical:r}=v(n?n.unit:null,t.spatialReference);return nt(e,e,[o,o,r]),e}function wt(t,n,e,o){const r=et(t,n,o),i=new Float64Array(r.length);return f(i,r,e),i}function vt(t,n,e,o,r){if(t==null)return null;const i=ot(t,n,e,o,new Float32Array(t.length));return y(i,i,r),i}function At(t,n,e,o,r){if(t==null)return null;const i=it(t,n,e,o,new Float32Array(t.length));return y(i,i,r,4),i}function v(t,n){if(t==null)return $t;const e=n.isGeographic?1:rt(n),o=n.isGeographic?1:at(n),r=lt(1,t,"meters");return{horizontal:r*e,vertical:r*o}}const w=h(),Mt=h(),C=st(),$t={horizontal:1,vertical:1};export{gt as L,zt as b,z as k,G as r,pt as v,bt as x,I as z};
