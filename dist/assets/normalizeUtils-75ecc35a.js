import{bw as E,bz as W,r as U,bB as F,du as _,dG as $,dH as H,L as K,bW as Q,bP as v,cc as J,a2 as C,a_ as N,dI as V,E as Y}from"./index-0ea7d266.js";import{c as O,o as R,u as B,g as I}from"./normalizeUtilsCommon-c67d270a.js";async function Z(e,n,r,s){const t=E(e),c=n[0].spatialReference,l={...s,query:{...t.query,f:"json",sr:JSON.stringify(c),target:JSON.stringify({geometryType:W(n[0]),geometries:n}),cutter:JSON.stringify(r)}},o=await U(t.path+"/cut",l),{cutIndexes:u,geometries:h=[]}=o.data;return{cutIndexes:u,geometries:h.map(y=>{const m=F(y);return m.spatialReference=c,m})}}async function X(e,n,r){const s=typeof e=="string"?_(e):e,t=n[0].spatialReference,c=W(n[0]),l={...r,query:{...s.query,f:"json",sr:t.wkid??JSON.stringify(t),geometries:JSON.stringify($(n))}},{data:o}=await U(s.path+"/simplify",l);return H(o.geometries,c,t)}const k=K.getLogger("esri.geometry.support.normalizeUtils");function ee(e){return e.type==="polygon"}function te(e){return e[0].type==="polygon"}function ne(e){return e[0].type==="polyline"}function se(e,n){if(!(e instanceof C||e instanceof J)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw k.error(t),new Y(t)}const r=I(e),s=[];for(const t of r){const c=[];s.push(c),c.push([t[0][0],t[0][1]]);for(let l=0;l<t.length-1;l++){const o=t[l][0],u=t[l][1],h=t[l+1][0],y=t[l+1][1],m=Math.sqrt((h-o)*(h-o)+(y-u)*(y-u)),d=(y-u)/m,p=(h-o)/m,f=m/n;if(f>1){for(let L=1;L<=f-1;L++){const M=L*n,i=p*M+o,a=d*M+u;c.push([i,a])}const P=(m+Math.floor(f-1)*n)/2,b=p*P+o,T=d*P+u;c.push([b,T])}c.push([h,y])}}return ee(e)?new J({rings:s,spatialReference:e.spatialReference}):new C({paths:s,spatialReference:e.spatialReference})}function q(e,n,r){if(n){const t=se(e,1e6);e=V(t,!0)}return r&&(e=B(e,r)),e}function D(e,n,r){if(Array.isArray(e)){const s=e[0];if(s>n){const t=R(s,n);e[0]=s+t*(-2*n)}else if(s<r){const t=R(s,r);e[0]=s+t*(-2*r)}}else{const s=e.x;if(s>n){const t=R(s,n);e=e.clone().offset(t*(-2*n),0)}else if(s<r){const t=R(s,r);e=e.clone().offset(t*(-2*r),0)}}return e}function oe(e,n){let r=-1;for(let s=0;s<n.cutIndexes.length;s++){const t=n.cutIndexes[s],c=n.geometries[s],l=I(c);for(let o=0;o<l.length;o++){const u=l[o];u.some(h=>{if(h[0]<180)return!0;{let y=0;for(let p=0;p<u.length;p++){const f=u[p][0];y=f>y?f:y}y=Number(y.toFixed(9));const d=R(y,180)*-360;for(let p=0;p<u.length;p++){const f=c.getPoint(o,p);c.setPoint(o,p,f.clone().offset(d,0))}return!0}})}if(t===r){if(te(e))for(const o of I(c))e[t]=e[t].addRing(o);else if(ne(e))for(const o of I(c))e[t]=e[t].addPath(o)}else r=t,e[t]=c}return e}async function ie(e,n,r){if(!Array.isArray(e))return ie([e],n);n&&typeof n!="string"&&k.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof n=="string"?n:(n==null?void 0:n.url)??Q.geometryServiceUrl;let t,c,l,o,u,h,y,m,d=0;const p=[],f=[];for(const i of e){if(i==null){f.push(i);continue}if(t||(t=i.spatialReference,c=v(t),l=t.isWebMercator,h=l?102100:4326,o=O[h].maxX,u=O[h].minX,y=O[h].plus180Line,m=O[h].minus180Line),!c)f.push(i);else if(i.type==="mesh")f.push(i);else if(i.type==="point")f.push(D(i.clone(),o,u));else if(i.type==="multipoint"){const a=i.clone();a.points=a.points.map(g=>D(g,o,u)),f.push(a)}else if(i.type==="extent"){const g=i.clone()._normalize(!1,!1,c);f.push(g.rings?new J(g):g)}else if(i.extent){const a=i.extent,x=R(a.xmin,u)*(2*o);let w=x===0?i.clone():B(i.clone(),x);a.offset(x,0),a.intersects(y)&&a.xmax!==o?(d=a.xmax>d?a.xmax:d,w=q(w,l),p.push(w),f.push("cut")):a.intersects(m)&&a.xmin!==u?(d=a.xmax*(2*o)>d?a.xmax*(2*o):d,w=q(w,l,360),p.push(w),f.push("cut")):f.push(w)}else f.push(i.clone())}let P=R(d,o),b=-90;const T=P,L=new C;for(;P>0;){const i=-180+360*P;L.addPath([[i,b],[i,b*-1]]),b=b*-1,P--}if(p.length>0&&T>0){const i=await Z(s,p,L,r),a=oe(p,i),g=[],x=[];for(let G=0;G<f.length;G++){const S=f[G];if(S!=="cut")x.push(S);else{const z=a.shift(),j=e[G];j!=null&&j.type==="polygon"&&j.rings&&j.rings.length>1&&z.rings.length>=j.rings.length?(g.push(z),x.push("simplify")):x.push(l?N(z):z)}}if(!g.length)return x;const w=await X(s,g,r),A=[];for(let G=0;G<x.length;G++){const S=x[G];S!=="simplify"?A.push(S):A.push(l?N(w.shift()):w.shift())}return A}const M=[];for(let i=0;i<f.length;i++){const a=f[i];if(a!=="cut")M.push(a);else{const g=p.shift();M.push(l===!0?N(g):g)}}return M}function fe(e,n){const r=v(n);if(r){const[s,t]=r.valid,c=t-s;if(e<s)for(;e<s;)e+=c;if(e>t)for(;e>t;)e-=c}return e}export{fe as a,ie as n};
