import{a as I,ds as Y,b9 as E,gc as ee,_ as Ae,gd as Te,ge as te,ch as be,gf as ve,ab as _e,x as se,B as ie,bB as ae,s as Ve,gg as Qe,fJ as Ee,fI as ze,fL as Ce,R as L,gh as re,cI as ne,gi as De,cq as Pe,dg as le,cg as $e,cm as qe,Q as Me,gj as Ge}from"./index-989909ce.js";import{e as oe,h as Ne,i as je}from"./LRUCache-a1ffc3d4.js";import{b as ue}from"./normalizeUtils-938fb227.js";import{r as Be}from"./featureConversionUtils-b1362163.js";import{f as Oe}from"./WhereClause-89ac4fc8.js";import{g as P,f as H,M as ke}from"./projectionSupport-f9da330e.js";import{t as Ze}from"./QueryEngineCapabilities-42e44ded.js";import{m as ce}from"./quantizationUtils-611ec4df.js";import{c as U,z as Le,m as He,f as he,d as de,g as Ue,y as Ye,F as Je,D as We,S as Xe,M as Ke,v as et,p as tt}from"./utils-6954664e.js";import{Z as j,P as Z,G as fe,M,t as st,v as me,a as O,n as it,I as pe,b as ge}from"./timeSupport-5a0eb742.js";import{r as at}from"./FieldsIndex-958df084.js";let rt=class{constructor(e,t){this._cache=new oe(e),this._invalidCache=new oe(t)}get(e,t){const s=`${t.uid}:${e}`,i=this._cache.get(s);if(i)return i;if(this._invalidCache.get(s)!==void 0)return null;try{const a=Oe.create(e,t);return this._cache.put(s,a),a}catch{return this._invalidCache.put(s,null),null}}};const J=new rt(50,500),C="feature-store:unsupported-query",Fe=" as ",nt=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function lt(p,e){if(!e)return!0;const t=J.get(e,p);if(!t)throw new I(C,"invalid SQL expression",{where:e});if(!t.isStandardized)throw new I(C,"where clause is not standard",{where:e});return z(p,t.fieldNames,"where clause contains missing fields"),!0}function ot(p,e,t){if(!e)return!0;const s=J.get(e,p);if(!s)throw new I(C,"invalid SQL expression",{having:e});if(!s.isAggregate)throw new I(C,"having does not contain a valid aggregate function",{having:e});const i=s.fieldNames;if(z(p,i,"having contains missing fields"),!s.getExpressions().every(a=>{var o;const{aggregateType:r,field:n}=a,l=(o=p.get(n))==null?void 0:o.name;return t.some(u=>{var m;const{onStatisticField:c,statisticType:d}=u;return((m=p.get(c))==null?void 0:m.name)===l&&d.toLowerCase().trim()===r})}))throw new I(C,"expressions in having should also exist in outStatistics",{having:e});return!0}function G(p,e){return p?J.get(p,e):null}function z(p,e,t,s=!0){const i=[];for(const a of e)if(a!=="*"&&!p.has(a))if(s){const r=we(a);try{const n=G(r,p);if(!n)throw new I(C,"invalid SQL expression",{where:r});if(!n.isStandardized)throw new I(C,"expression is not standard",{clause:n});z(p,n.fieldNames,"expression contains missing fields")}catch(n){const l=n==null?void 0:n.details;if(l&&(l.clause||l.where))throw n;l!=null&&l.missingFields?i.push(...l.missingFields):i.push(a)}}else i.push(a);if(i.length)throw new I(C,t,{missingFields:i})}function we(p){return p.split(Fe)[0]}function ut(p){return p.split(Fe)[1]}function ct(p,e){const t=e.get(p);return!!t&&!nt.has(t.type)}class k{constructor(e,t,s){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=s,this.featureAdapter=t;const i=e.outFields;if(i&&!i.includes("*")){this.outFields=i;let a=0;for(const r of i){const n=we(r),l=this.fieldsIndex.get(n),o=l?null:G(n,s),u=l?l.name:ut(r)||"FIELD_EXP_"+a++;this._fieldDataCache.set(r,{alias:u,clause:o})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,s){var r;const i=s?s.name:t;let a=null;return this._fieldDataCache.has(i)?a=(r=this._fieldDataCache.get(i))==null?void 0:r.clause:s||(a=G(t,this.fieldsIndex),this._fieldDataCache.set(i,{alias:i,clause:a})),s?this.featureAdapter.getAttribute(e,i):a==null?void 0:a.calculateValue(e,this.featureAdapter)}getDataValue(e,t){const s=t.normalizationType,i=t.normalizationTotal;let a=t.field&&this.getFieldValue(e,t.field,this.fieldsIndex.get(t.field));if(t.field2&&(a=`${U(a)}${t.fieldDelimiter}${U(this.getFieldValue(e,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(a=`${a}${t.fieldDelimiter}${U(this.getFieldValue(e,t.field3,this.fieldsIndex.get(t.field3)))}`)),s&&Number.isFinite(a)){const r=s==="field"&&t.normalizationField?this.getFieldValue(e,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;a=Le(a,s,r,i)}return a}getExpressionValue(e,t,s,i){const a={attributes:this.featureAdapter.getAttributes(e),layer:{fields:this.fieldsIndex.fields}},r=i.createExecContext(a,s);return i.executeFunction(t,r)}getExpressionValues(e,t,s,i){const a={fields:this.fieldsIndex.fields};return e.map(r=>{const n={attributes:this.featureAdapter.getAttributes(r),layer:a},l=i.createExecContext(n,s);return i.executeFunction(t,l)})}validateItem(e,t){var s,i;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:G(t,this.fieldsIndex)}),((i=(s=this._fieldDataCache.get(t))==null?void 0:s.clause)==null?void 0:i.testFeature(e,this.featureAdapter))??!1}validateItems(e,t){var s,i;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:G(t,this.fieldsIndex)}),((i=(s=this._fieldDataCache.get(t))==null?void 0:s.clause)==null?void 0:i.testSet(e,this.featureAdapter))??!1}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const s={};for(const i of t){const{alias:a,clause:r}=this._fieldDataCache.get(i);s[a]=r?r.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,a)}return s}_processAttributesForDistinctValues(e){if(e==null||!this.returnDistinctValues)return e;const t=this.outFields,s=[];if(t)for(const r of t){const{alias:n}=this._fieldDataCache.get(r);s.push(e[n])}else for(const r in e)s.push(e[r]);const i=`${(t||["*"]).join(",")}=${s.join(",")}`;let a=this._returnDistinctMap.get(i)||0;return this._returnDistinctMap.set(i,++a),a>1?null:e}}function ht(p,e,t){return{objectId:p,target:e,distance:t,type:"vertex"}}function dt(p,e,t,s,i,a=!1){return{objectId:p,target:e,distance:t,type:"edge",start:s,end:i,draped:a}}class A{constructor(e,t,s){this.items=e,this.query=t,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.fieldsIndex=s.fieldsIndex,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.featureAdapter=s.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new k(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:s,outStatistics:i}=this.query;if(!(t==null?void 0:t.length))return 1;const r=new Map,n=new Map,l=new Set;for(const o of i){const{statisticType:u}=o,c=u!=="exceedslimit"?o.onStatisticField:void 0;if(!n.has(c)){const f=[];for(const m of t){const h=this._getAttributeValues(e,m,r);f.push(h)}n.set(c,this._calculateUniqueValues(f,e.returnDistinctValues))}const d=n.get(c);for(const f in d){const{data:m,items:h}=d[f],F=m.join(",");s&&!e.validateItems(h,s)||l.add(F)}}return l.size}async createQueryResponse(){let e;if(this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;Y(this.query.outSR)&&!E(t.spatialReference,this.query.outSR)?e.queryGeometry=j({spatialReference:this.query.outSR,...P(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=j({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t){const s=this.featureAdapter,i=ye(this.hasZ,this.hasM),{point:a,mode:r}=e,n=typeof e.distance=="number"?e.distance:e.distance.x,l=typeof e.distance=="number"?e.distance:e.distance.y,o={candidates:[]},u=this.geometryType==="esriGeometryPolygon",c=this._getPointCreator(r,this.spatialReference,t),d=new xe(null,0),f=new xe(null,0),m={x:0,y:0,z:0};for(const h of this.items){const F=s.getGeometry(h);if(F==null)continue;const{coords:x,lengths:S}=F;if(d.coords=x,f.coords=x,e.returnEdge){let w=0;for(let g=0;g<S.length;g++){const y=S[g];for(let _=0;_<y;_++,w+=i){const R=d;if(R.coordsIndex=w,_!==y-1){const b=f;b.coordsIndex=w+i;const D=m;ft(m,a,R,b);const T=(a.x-D.x)/n,v=(a.y-D.y)/l,$=T*T+v*v;$<=1&&o.candidates.push(dt(s.getObjectId(h),c(D),Math.sqrt($),c(R),c(b)))}}}}if(e.returnVertex){const w=u?x.length-i:x.length;for(let g=0;g<w;g+=i){const y=d;y.coordsIndex=g;const _=(a.x-y.x)/n,R=(a.y-y.y)/l,b=_*_+R*R;b<=1&&o.candidates.push(ht(s.getObjectId(h),c(y),Math.sqrt(b)))}}}return o.candidates.sort((h,F)=>h.distance-F.distance),o}_getPointCreator(e,t,s){const i=s==null||E(t,s)?n=>n:n=>P(n,t,s),{hasZ:a}=this,r=0;return e==="3d"?a?({x:n,y:l,z:o})=>i({x:n,y:l,z:o}):({x:n,y:l})=>i({x:n,y:l,z:r}):({x:n,y:l})=>i({x:n,y:l})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,minValue:n,maxValue:l,scale:o}=e,u=this.fieldsIndex.isDateField(t),c=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:o}),d=He({normalizationType:a,normalizationField:i,minValue:n,maxValue:l}),f=this.fieldsIndex.get(t),m={value:.5,fieldType:f==null?void 0:f.type},h=ee(f)?he({values:c,supportsNullCount:d,percentileParams:m}):de({values:c,minValue:n,maxValue:l,useSampleStdDev:!a,supportsNullCount:d,percentileParams:m});return Ue(h,u)}async createUniqueValuesResponse(e){const{field:t,valueExpression:s,domains:i,returnAllCodedValues:a,scale:r}=e,n=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:s,scale:r}),l=Ye(n);return Je(l,i,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:l,minValue:o,maxValue:u,numClasses:c,scale:d}=e,f=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:d}),m=We(f,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:l,minValue:o,maxValue:u,numClasses:c});return Xe(m,n)}async createHistogramResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:l,minValue:o,maxValue:u,numBins:c,scale:d}=e,f=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:d});return Ke(f,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:l,minValue:o,maxValue:u,numBins:c})}_sortFeatures(e,t,s){if(e.length>1&&t&&t.length)for(const i of t.reverse()){const a=i.split(" "),r=a[0],n=this.fieldsIndex.get(r),l=!!a[1]&&a[1].toLowerCase()==="desc",o=et(n==null?void 0:n.type,l);e.sort((u,c)=>{const d=s(u,r,n),f=s(c,r,n);return o(d,f)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:s,hasM:i,hasZ:a,objectIdField:r,spatialReference:n}=this,{outFields:l,outSR:o,quantizationParameters:u,resultRecordCount:c,resultOffset:d,returnZ:f,returnM:m}=e,h=c!=null&&t.length>(d||0)+c,F=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(x=>this.fieldsIndex.get(x)));return{exceededTransferLimit:h,features:this._createFeatures(e,t),fields:F,geometryType:s,hasM:i&&m,hasZ:a&&f,objectIdFieldName:r,spatialReference:j(o||n),transform:u&&ce(u)||null}}_createFeatures(e,t){const s=new k(e,this.featureAdapter,this.fieldsIndex),{hasM:i,hasZ:a}=this,{orderByFields:r,quantizationParameters:n,returnGeometry:l,returnCentroid:o,maxAllowableOffset:u,resultOffset:c,resultRecordCount:d,returnZ:f=!1,returnM:m=!1}=e,h=a&&f,F=i&&m;let x=[],S=0;const w=[...t];if(this._sortFeatures(w,r,(y,_,R)=>s.getFieldValue(y,_,R)),l||o){const y=ce(n)??void 0;if(l&&!o)for(const _ of w)x[S++]={attributes:s.getAttributes(_),geometry:Z(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(_),u,y,h,F)};else if(!l&&o)for(const _ of w)x[S++]={attributes:s.getAttributes(_),centroid:fe(this,this.featureAdapter.getCentroid(_,this),y)};else for(const _ of w)x[S++]={attributes:s.getAttributes(_),centroid:fe(this,this.featureAdapter.getCentroid(_,this),y),geometry:Z(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(_),u,y,h,F)}}else for(const y of w){const _=s.getAttributes(y);_&&(x[S++]={attributes:_})}const g=c||0;if(d!=null){const y=g+d;x=x.slice(g,Math.min(x.length,y))}return x}_createExceedsLimitQueryResponse(e){let t=!1,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const r of e.outStatistics??[])if(r.statisticType==="exceedslimit"){s=r.maxPointCount!=null?r.maxPointCount:Number.POSITIVE_INFINITY,i=r.maxRecordCount!=null?r.maxRecordCount:Number.POSITIVE_INFINITY,a=r.maxVertexCount!=null?r.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>s;else if(this.items.length>i)t=!0;else{const r=ye(this.hasZ,this.hasM),n=this.featureAdapter;t=this.items.reduce((l,o)=>{const u=n.getGeometry(o);return l+(u!=null&&u.coords.length||0)},0)/r>a}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},s=[],i=new Map,a=new Map,r=new Map,n=new Map,l=new k(e,this.featureAdapter,this.fieldsIndex),o=e.outStatistics,{groupByFieldsForStatistics:u,having:c,orderByFields:d}=e,f=u&&u.length,m=!!f,h=m?u[0]:null,F=m&&!this.fieldsIndex.get(h);for(const S of o??[]){const{outStatisticFieldName:w,statisticType:g}=S,y=S,_=g!=="exceedslimit"?S.onStatisticField:void 0,R=g==="percentile_disc"||g==="percentile_cont",b=g==="EnvelopeAggregate"||g==="CentroidAggregate"||g==="ConvexHullAggregate",D=m&&f===1&&(_===h||F)&&g==="count";if(m){if(!r.has(_)){const v=[];for(const $ of u){const B=this._getAttributeValues(l,$,i);v.push(B)}r.set(_,this._calculateUniqueValues(v,!b&&l.returnDistinctValues))}const T=r.get(_);for(const v in T){const{count:$,data:B,items:W,itemPositions:Se}=T[v],X=B.join(",");if(!c||l.validateItems(W,c)){const q=n.get(X)||{attributes:{}};if(b){q.aggregateGeometries||(q.aggregateGeometries={});const{aggregateGeometries:V,outStatisticFieldName:N}=await this._getAggregateGeometry(y,W);q.aggregateGeometries[N]=V}else{let V=null;if(D)V=$;else{const N=this._getAttributeValues(l,_,i),K=Se.map(Re=>N[Re]);V=R&&"statisticParameters"in y?this._getPercentileValue(y,K):this._getStatisticValue(y,K,null,l.returnDistinctValues)}q.attributes[w]=V}let Ie=0;u.forEach((V,N)=>q.attributes[this.fieldsIndex.get(V)?V:"EXPR_"+ ++Ie]=B[N]),n.set(X,q)}}}else if(b){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:T,outStatisticFieldName:v}=await this._getAggregateGeometry(y,this.items);t.aggregateGeometries[v]=T}else{const T=this._getAttributeValues(l,_,i);t.attributes[w]=R&&"statisticParameters"in y?this._getPercentileValue(y,T):this._getStatisticValue(y,T,a,l.returnDistinctValues)}s.push({name:w,alias:w,type:"esriFieldTypeDouble"})}const x=m?Array.from(n.values()):[t];return this._sortFeatures(x,d,(S,w)=>S.attributes[w]),{fields:s,features:x}}async _getAggregateGeometry(e,t){const{convexHull:s,union:i}=await Ae(()=>import("./geometryEngineJSON-34740f61.js"),["assets/geometryEngineJSON-34740f61.js","assets/geometryEngineBase-564f3d0e.js","assets/index-989909ce.js","assets/index-0492b785.css","assets/geometryEngineJSON-d1888d8d.js","assets/json-48e3ea08.js"]),{statisticType:a,outStatisticFieldName:r}=e,{featureAdapter:n,spatialReference:l,geometryType:o,hasZ:u,hasM:c}=this,d=t.map(h=>Z(o,u,c,n.getGeometry(h))),f=s(l,d,!0)[0],m={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){const h=f?Te(f):te(i(l,d));m.aggregateGeometries={...h,spatialReference:l},m.outStatisticFieldName=r||"extent"}else if(a==="CentroidAggregate"){const h=f?be(f):ve(te(i(l,d)));m.aggregateGeometries={x:h[0],y:h[1],spatialReference:l},m.outStatisticFieldName=r||"centroid"}else a==="ConvexHullAggregate"&&(m.aggregateGeometries=f,m.outStatisticFieldName=r||"convexHull");return m}_getStatisticValue(e,t,s,i){const{onStatisticField:a,statisticType:r}=e;let n=null;return n=s!=null&&s.has(a)?s.get(a):ee(this.fieldsIndex.get(a))?he({values:t,returnDistinct:i}):de({values:i?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(a,n),n[r==="var"?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:s,statisticParameters:i,statisticType:a}=e,{value:r,orderBy:n}=i,l=this.fieldsIndex.get(s);return tt(t,{value:r,orderBy:n,fieldType:l==null?void 0:l.type,isDiscrete:a==="percentile_disc"})}_getAttributeValues(e,t,s){if(s.has(t))return s.get(t);const i=this.fieldsIndex.get(t),a=this.items.map(r=>e.getFieldValue(r,t,i));return s.set(t,a),a}_getAttributeDataValues(e,t){return this.items.map(s=>e.getDataValue(s,{field:t.field,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:t.normalizationField,normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal}))}async _getAttributeExpressionValues(e,t,s){const{arcadeUtils:i}=await _e(),a=i.createFunction(t),r=s&&i.getViewInfo(s);return e.getExpressionValues(this.items,a,r,i)}_calculateUniqueValues(e,t){const s={},i=this.items,a=i.length;for(let r=0;r<a;r++){const n=i[r],l=[];for(const u of e)l.push(u[r]);const o=l.join(",");s[o]==null?s[o]={count:1,data:l,items:[n],itemPositions:[r]}:(t||s[o].count++,s[o].items.push(n),s[o].itemPositions.push(r))}return s}async _getDataValues(e){const t=new k(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:i,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:l}=e,o=s?{viewingMode:"map",scale:l,spatialReference:this.query.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(t,s,o):this._getAttributeDataValues(t,{field:i,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:a,normalizationType:r,normalizationTotal:n})}}function ft(p,e,t,s){const i=s.x-t.x,a=s.y-t.y,r=i*i+a*a,n=(e.x-t.x)*i+(e.y-t.y)*a,l=Math.min(1,Math.max(0,n/r));p.x=t.x+i*l,p.y=t.y+a*l}function ye(p,e){return p?e?4:3:e?3:2}class xe{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}function mt(p){return p!=null&&p.every(e=>e.statisticType!=="exceedslimit")}const Q="feature-store:unsupported-query",pt=new Ne(2e6);let gt=0;class Vt{constructor(e){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:Ze},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new je(gt+++"$$",pt)),this.fieldsIndex=new at(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=se(this._frameTask),this.clearCache(),ie(this._geometryQueryCache),this._changeHandle=se(this._changeHandle),ie(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){var e;(e=this._geometryQueryCache)==null||e.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null}async executeQuery(e,t){try{return(await this._executeQuery(e,{},t)).createQueryResponse()}catch(s){if(s!==M)throw s;return new A([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},t)).createQueryResponseForCount()}catch(s){if(s!==M)throw s;return 0}}async executeQueryForExtent(e,t){const s=e.outSR;try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),a=i.size;return a?{count:a,extent:await this._getBounds(i.items,i.spatialReference,s||this.spatialReference)}:{count:0,extent:null}}catch(i){if(i===M)return{count:0,extent:null};throw i}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then(s=>Array.from(s))}async executeQueryForIdSet(e,t){try{const s=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),i=s.items,a=new Set;return await this._reschedule(()=>{for(const r of i)a.add(s.featureAdapter.getObjectId(r))},t),a}catch(s){if(s===M)return new Set;throw s}}async executeQueryForSnapping(e,t){const{point:s,distance:i,returnEdge:a,returnVertex:r}=e;if(!a&&!r)return{candidates:[]};const n=await this._reschedule(()=>this._checkQuerySupport(e.query),t),l=!E(s.spatialReference,this.spatialReference);l&&await H(s.spatialReference,this.spatialReference);const o=typeof i=="number"?i:i.x,u=typeof i=="number"?i:i.y,c={xmin:s.x-o,xmax:s.x+o,ymin:s.y-u,ymax:s.y+u,spatialReference:s.spatialReference},d=l?P(c,this.spatialReference):c;if(!d)return{candidates:[]};const f=(await ue(ae(s),null,{signal:t}))[0],m=(await ue(ae(d),null,{signal:t}))[0];if(f==null||m==null)return{candidates:[]};const h=new A(await this._reschedule(()=>this._searchFeatures(this._getQueryBBoxes(m.toJSON())),t),n,this);await this._reschedule(()=>this._executeObjectIdsQuery(h),t),await this._reschedule(()=>this._executeTimeQuery(h),t),await this._reschedule(()=>this._executeAttributesQuery(h),t);const F=f.toJSON(),x=l?P(F,this.spatialReference):F,S=l?Math.max(d.xmax-d.xmin,d.ymax-d.ymin)/2:i;return h.createSnappingResponse({...e,point:x,distance:S},s.spatialReference)}async executeQueryForLatestObservations(e,t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new I(Q,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const s=await this._executeQuery(e,{},t);return await this._reschedule(()=>this._filterLatest(s),t),s.createQueryResponse()}catch(s){if(s!==M)throw s;return new A([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,s){const{field:i,normalizationField:a,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:a,valueExpression:r},s)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,s){const{field:i,field2:a,field3:r,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:i,field2:a,field3:r,valueExpression:n},s)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,s){const{field:i,normalizationField:a,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:a,valueExpression:r},s)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,s){const{field:i,normalizationField:a,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:a,valueExpression:r},s)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const[t,s]=await Promise.all(["getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getBounds(await this._getAllFeatures(),this.spatialReference,this.spatialReference),this._timeExtentPromise!=null?this._timeExtentPromise:this._timeExtentPromise=st(this.timeInfo,this.featureStore)]);return Ve(e),{fullExtent:t,timeExtent:s}}async _getBounds(e,t,s){const i=Qe(ze(),Ee);await this.featureStore.forEachBounds(e,n=>Ce(i,n));const a={xmin:i[0],ymin:i[1],xmax:i[3],ymax:i[4],spatialReference:j(this.spatialReference)};this.hasZ&&isFinite(i[2])&&isFinite(i[5])&&(a.zmin=i[2],a.zmax=i[5]);const r=P(a,t,s);if(r.spatialReference=j(s),r.xmax-r.xmin==0){const n=L(r.spatialReference);r.xmin-=n,r.xmax+=n}if(r.ymax-r.ymin==0){const n=L(r.spatialReference);r.ymin-=n,r.ymax+=n}if(this.hasZ&&r.zmin!=null&&r.zmax!=null&&r.zmax-r.zmin==0){const n=L(r.spatialReference);r.zmin-=n,r.zmax+=n}return r}async _schedule(e,t){return this._frameTask!=null?this._frameTask.schedule(e,t):e(re)}async _reschedule(e,t){return this._frameTask!=null?this._frameTask.reschedule(e,t):e(re)}async _getAllFeaturesQueryEngineResult(e){return new A(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(this._allFeaturesPromise==null){const s=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach(i=>s.push(i))})().then(()=>s)}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,s){e=ne(e),e=await this._schedule(()=>me(e,this.definitionExpression,this.spatialReference),s),e=await this._reschedule(()=>this._checkQuerySupport(e),s),e={...e,...t};const i=await this._reschedule(()=>this._executeSceneFilterQuery(e,s),s),a=await this._reschedule(()=>this._executeGeometryQuery(e,i,s),s);return await this._reschedule(()=>this._executeAggregateIdsQuery(a),s),await this._reschedule(()=>this._executeObjectIdsQuery(a),s),await this._reschedule(()=>this._executeTimeQuery(a),s),await this._reschedule(()=>this._executeAttributesQuery(a),s),a}async _executeSceneFilterQuery(e,t){if(e.sceneFilter==null)return null;const{outSR:s,returnGeometry:i,returnCentroid:a}=e,r=this.featureStore.featureSpatialReference,n=e.sceneFilter.geometry,l=r==null||E(r,n.spatialReference)?n:P(n,r);if(!l)return null;const o=i||a,u=Y(s)&&!E(this.spatialReference,s)&&o?async h=>this._project(h,s):h=>h,c=this.featureAdapter,d=await this._reschedule(()=>this._searchFeatures(this._getQueryBBoxes(l)),t);if(e.sceneFilter.spatialRelationship==="disjoint"){if(!d.length)return null;const h=new Set;for(const S of d)h.add(c.getObjectId(S));const F=await this._reschedule(()=>this._getAllFeatures(),t),x=await this._reschedule(async()=>{const S=await O("esriSpatialRelDisjoint",l,this.geometryType,this.hasZ,this.hasM),w=y=>!h.has(c.getObjectId(y))||S(c.getGeometry(y)),g=await this._runSpatialFilter(F,w,t);return new A(g,e,this)},t);return u(x)}if(!d.length)return new A([],e,this);if(this._canExecuteSinglePass(l,e))return u(new A(d,e,this));const f=await O("esriSpatialRelContains",l,this.geometryType,this.hasZ,this.hasM),m=await this._runSpatialFilter(d,h=>f(c.getGeometry(h)),t);return u(new A(m,e,this))}async _executeGeometryQuery(e,t,s){if(t!=null&&t.items.length===0)return t;e=t!=null?t.query:e;const{geometry:i,outSR:a,spatialRel:r,returnGeometry:n,returnCentroid:l}=e,o=this.featureStore.featureSpatialReference,u=!i||o==null||E(o,i.spatialReference)?i:P(i,o),c=n||l,d=Y(a)&&!E(this.spatialReference,a),f=this._geometryQueryCache&&t==null?JSON.stringify(d&&c?{originalFilterGeometry:i,spatialRelationship:r,outSpatialReference:a}:{originalFilterGeometry:i,spatialRelationship:r}):null,m=f?this._geometryQueryCache.get(f):null;if(m!=null)return new A(m,e,this);const h=async g=>(d&&c&&await this._project(g,a),f&&this._geometryQueryCache.put(f,g.items,g.items.length+1),g);if(!u)return h(t??await this._getAllFeaturesQueryEngineResult(e));const F=this.featureAdapter;let x=await this._reschedule(()=>this._searchFeatures(this._getQueryBBoxes(i)),s);if(r==="esriSpatialRelDisjoint"){if(!x.length)return h(t??await this._getAllFeaturesQueryEngineResult(e));const g=new Set;for(const R of x)g.add(F.getObjectId(R));const y=t!=null?t.items:await this._reschedule(()=>this._getAllFeatures(),s),_=await this._reschedule(async()=>{const R=await O(r,u,this.geometryType,this.hasZ,this.hasM),b=T=>!g.has(F.getObjectId(T))||R(F.getGeometry(T)),D=await this._runSpatialFilter(y,b,s);return new A(D,e,this)},s);return h(_)}if(t!=null){const g=new Ge;x=x.filter(y=>De(t.items,y,t.items.length,g)>=0)}if(!x.length){const g=new A([],e,this);return f&&this._geometryQueryCache.put(f,g.items,1),g}if(this._canExecuteSinglePass(u,e))return h(new A(x,e,this));const S=await O(r,u,this.geometryType,this.hasZ,this.hasM),w=await this._runSpatialFilter(x,g=>S(F.getGeometry(g)),s);return h(new A(w,e,this))}_executeAggregateIdsQuery(e){if(e.items.length===0||!e.query.aggregateIds||!e.query.aggregateIds.length||this.aggregateAdapter==null)return;const t=new Set;for(const i of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(i).forEach(a=>t.add(a));const s=this.featureAdapter.getObjectId;e.items=e.items.filter(i=>t.has(s(i)))}_executeObjectIdsQuery(e){if(e.items.length===0||!e.query.objectIds||!e.query.objectIds.length)return;const t=new Set(e.query.objectIds),s=this.featureAdapter.getObjectId;e.items=e.items.filter(i=>t.has(s(i)))}_executeTimeQuery(e){if(e.items.length===0)return;const t=it(this.timeInfo,e.query.timeExtent,this.featureAdapter);t!=null&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(e.items.length===0)return;const t=G(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(s=>t.testFeature(s,this.featureAdapter))}}async _runSpatialFilter(e,t,s){if(!t)return e;if(this._frameTask==null)return e.filter(n=>t(n));let i=0;const a=new Array,r=async n=>{for(;i<e.length;){const l=e[i++];t(l)&&(a.push(l),n.madeProgress()),n.done&&await this._reschedule(o=>r(o),s)}};return this._reschedule(n=>r(n),s).then(()=>a)}_filterLatest(e){const{trackIdField:t,startTimeField:s,endTimeField:i}=this.timeInfo,a=i||s,r=new Map,n=this.featureAdapter.getAttribute;for(const l of e.items){const o=n(l,t),u=n(l,a),c=r.get(o);(!c||u>n(c,a))&&r.set(o,l)}e.items=Array.from(r.values())}_canExecuteSinglePass(e,t){const{spatialRel:s}=t;return pe(e)&&(s==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(s==="esriSpatialRelIntersects"||s==="esriSpatialRelContains"||s==="esriSpatialRelWithin"))}async _project(e,t){if(!t||E(this.spatialReference,t))return e;const s=this.featureAdapter,i=await ke(e.items.map(a=>Z(this.geometryType,this.hasZ,this.hasM,s.getGeometry(a))),this.spatialReference,t);return e.items=i.map((a,r)=>s.cloneWithGeometry(e.items[r],Be(a,this.hasZ,this.hasM))),e}_getQueryBBoxes(e){if(pe(e)){if(Pe(e))return[le(e.xmin,e.ymin,e.xmax,e.ymax)];if($e(e))return e.rings.map(t=>le(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[qe(Me(),e)]}async _searchFeatures(e){const t=new Set;await Promise.all(e.map(i=>this.featureStore.forEachInBounds(i,a=>t.add(a))));const s=Array.from(t.values());return t.clear(),s}async _checkStatisticsSupport(e,t){if((e.distance??0)<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new I(Q,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),Promise.all([this._checkStatisticsParamsSupport(t),ge(e,this.geometryType,this.spatialReference),H(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:s}=await _e();t=s.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.field2&&t.push(e.field2),e.field3&&t.push(e.field3),e.normalizationField&&t.push(e.normalizationField),!t.length&&!e.valueExpression)throw new I(Q,"params should have at least a field or valueExpression",{params:e});z(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if((e.distance??0)<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new I(Q,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Promise.all([ge(e,this.geometryType,this.spatialReference),H(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:s,returnDistinctValues:i,outStatistics:a}=e,r=a?a.map(n=>n.outStatisticFieldName&&n.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(s&&s.length>0){const n=" asc",l=" desc",o=s.map(u=>{const c=u.toLowerCase();return c.includes(n)?c.split(n)[0]:c.includes(l)?c.split(l)[0]:u}).filter(u=>!r.includes(u));z(this.fieldsIndex,o,"orderByFields contains missing fields")}if(t&&t.length>0)z(this.fieldsIndex,t,"outFields contains missing fields");else if(i)throw new I(Q,"outFields should be specified for returnDistinctValues",{query:e});lt(this.fieldsIndex,e.where)}_checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:s,having:i}=e,a=s&&s.length,r=t&&t.length;if(i){if(!a||!r)throw new I(Q,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});ot(this.fieldsIndex,i,t)}if(r){if(!mt(t))return;const n=t.map(l=>l.onStatisticField).filter(Boolean);z(this.fieldsIndex,n,"onStatisticFields contains missing fields"),a&&z(this.fieldsIndex,s,"groupByFieldsForStatistics contains missing fields");for(const l of t){const{onStatisticField:o,statisticType:u}=l;if((u==="percentile_disc"||u==="percentile_cont")&&"statisticParameters"in l){const{statisticParameters:c}=l;if(!c)throw new I(Q,"statisticParamters should be set for percentile type",{definition:l,query:e})}else if(u!=="count"&&o&&ct(o,this.fieldsIndex))throw new I(Q,"outStatistics contains non-numeric fields",{definition:l,query:e})}}}async _getQueryEngineResultForStats(e,t,s){e=ne(e);try{e=await this._schedule(()=>me(e,this.definitionExpression,this.spatialReference),s),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),s);const i=await this._reschedule(()=>this._executeSceneFilterQuery(e,s),s),a=await this._reschedule(()=>this._executeGeometryQuery(e,i,s),s);return await this._reschedule(()=>this._executeAggregateIdsQuery(a),s),await this._reschedule(()=>this._executeObjectIdsQuery(a),s),await this._reschedule(()=>this._executeTimeQuery(a),s),await this._reschedule(()=>this._executeAttributesQuery(a),s),a}catch(i){if(i!==M)throw i;return new A([],e,this)}}}export{Vt as K};
