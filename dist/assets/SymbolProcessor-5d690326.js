import{d as D,ab as F,ad as R,cu as K,cA as w,c as b,aF as $,cl as S,cM as E}from"./index-9f03d686.js";import{i as P}from"./ExpandedCIM-6cea9dff.js";import{p as A}from"./visualVariablesUtils-9c29b7c3.js";import{S as L}from"./color-b838c155.js";import{x as O,o as x,b as U,E as z,c as B}from"./Matcher-6fbf6c3f.js";import{p as j}from"./BaseProcessor-efc7ace9.js";import"./BidiEngine-9a40f2f4.js";import"./GeometryUtils-53652037.js";import"./enums-55085e26.js";import"./MaterialKey-3bd82cb0.js";import"./definitions-43101aab.js";import"./Rect-ea14f53a.js";import"./quantizationUtils-972531c3.js";import"./floatRGBA-8960ccf7.js";import"./visualVariablesUtils-1400c8a8.js";import"./enums-74e97557.js";import"./VertexElementDescriptor-2925c6af.js";import"./tileUtils-c2f19f52.js";import"./TurboLine-27fc11fb.js";import"./GeometryUtils-dd03fc25.js";import"./earcut-61f7b102.js";import"./devEnvironmentUtils-5002a058.js";class H{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,r){const s=this._resourceMap,i=s.get(e);if(i)return i;let a=this._inFlightResourceMap.get(e);if(a)return a;try{a=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...r}),this._inFlightResourceMap.set(e,a),a.then(n=>(this._inFlightResourceMap.delete(e),s.set(e,n),n))}catch(n){return D(n)?null:{width:0,height:0}}return a}getResource(e){return this._resourceMap.get(e)??null}}function T(t,e){return(!t.minScale||t.minScale>=e)&&(!t.maxScale||t.maxScale<=e)}function k(t){const e=t.message,r={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin,version:e.version},transferList:new Array};for(const s in e.data){const i=s,a=e.data[i];if(r.message.data[i]=null,a!=null){const n=a.stride,o=a.indices.slice(0),l=a.vertices.slice(0),c=a.records.slice(0),h={stride:n,indices:o,vertices:l,records:c,metrics:S(a.metrics,f=>f.slice(0))};r.transferList.push(o,l,c),r.message.data[i]=h}}return r}let I=class extends j{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new H(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(t){this._bufferIds.forEach(e=>{e.forEach(t)})}async update(t,e){var i;const r=e.schema.processors[0];if(r.type!=="symbol")return;const s=K(this._schema,r);(w(s,"mesh")||w(s,"target"))&&(t.mesh=!0,(i=t.why)==null||i.mesh.push("Symbology changed"),this._schema=r,this._factory=this._createFactory(r),this._factory.update(r,this.tileStore.tileScheme.tileInfo))}onTileMessage(t,e,r,s){return b(s),this._onTileData(t,e,r,s)}onTileClear(t){const e={clear:!0};return this._bufferData.delete(t.key.id),this._bufferIds.delete(t.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:e})}onTileError(t,e,r){const s=r.signal,i={tileKey:t.id,error:e};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:s})}onTileUpdate(t){for(const e of t.removed)this._bufferData.has(e.key.id)&&this._bufferData.delete(e.key.id),this._bufferIds.has(e.key.id)&&this._bufferIds.delete(e.key.id);for(const e of t.added)this._bufferData.forEach(r=>{for(const s of r)s.message.tileKey===e.id&&this._updateTileMesh("append",e,k(s),[],!1,!1,null)})}_addBufferData(t,e){var r;this._bufferData.has(t)||this._bufferData.set(t,[]),(r=this._bufferData.get(t))==null||r.push(k(e))}_createFactory(t){const{geometryType:e,objectIdField:r,fields:s}=this.service,i=(c,h)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",c,h),a={geometryType:e,fields:s,spatialReference:$.fromJSON(this.spatialReference)},n=new O(i,this.tileStore.tileScheme.tileInfo),{matcher:o,aggregateMatcher:l}=t.mesh;return this._store=n,this._matchers.feature=x(o,n,a,this._resourceManagerProxy),this._matchers.aggregate=S(l,c=>x(c,n,a,this._resourceManagerProxy)),new U(e,r,n)}async _onTileData(t,e,r,s){var f;b(s);const{type:i,addOrUpdate:a,remove:n,clear:o,end:l}=e,c=!!this._schema.mesh.sortKey;if(!a){const u={type:i,addOrUpdate:null,remove:n,clear:o,end:l,sort:c};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:u},s)}const h=this._processFeatures(t,a,r,s,(f=e.status)==null?void 0:f.version);try{const u=await h;if(u==null){const d={type:i,addOrUpdate:null,remove:n,clear:o,end:l,sort:c};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:d},s)}const m=[];for(const d of u){let g=!1;const p=d.message.bufferIds,y=t.key.id,M=d.message.tileKey;if(y!==M&&p!=null){if(!this.tileStore.get(M)){this._addBufferData(y,d),m.push(d);continue}let _=this._bufferIds.get(M);_||(_=new Set,this._bufferIds.set(M,_));const C=Array.from(p);for(const v of C){if(_.has(v)){g=!0;break}_.add(v)}}g||(this._addBufferData(y,d),m.push(d))}await Promise.all(m.map(d=>{const g=t.key.id===d.message.tileKey,p=g?e.remove:[],y=g&&e.end;return this._updateTileMesh(i,t,d,p,y,!!e.clear,s.signal)}))}catch(u){this._handleError(t,u,s)}}async _updateTileMesh(t,e,r,s,i,a,n){const o=t,l=r.message.tileKey,c=!!this._schema.mesh.sortKey;l!==e.key.id&&(i=!1);const h={type:o,addOrUpdate:S(r,u=>u.message),remove:s,clear:a,end:i,sort:c},f={transferList:S(r,u=>u.transferList)||[],signal:n};return b(f),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:l,data:h},f)}async _processFeatures(t,e,r,s,i){if(e==null||!e.hasFeatures)return null;const a={transform:t.transform,hasZ:!1,hasM:!1},n=this._factory,o={viewingMode:"",scale:t.scale},l=await this._matchers.feature,c=await this._matchers.aggregate;b(s);const h=this._getLabelInfos(t,e);return await n.analyze(e.getCursor(),this._resourceManagerProxy,l,c,a,o),b(s),this._writeFeatureSet(t,e,a,h,n,r,i)}_writeFeatureSet(t,e,r,s,i,a,n){const o=e.getSize(),l=this._schema.mesh.matcher.symbologyType,c=new z(t.key.id,{features:o,records:o,metrics:0},l,a,l!==L.HEATMAP,n),h={viewingMode:"",scale:t.scale},f=e.getCursor();for(;f.next();)try{const m=f.getDisplayId(),d=s!=null?s.get(m):null;i.writeCursor(c,f,r,h,t.level,d,this._resourceManagerProxy)}catch{}const u=t.tileInfoView.tileInfo.isWrappable;return c.serialize(u)}_handleError(t,e,r){if(!D(e)){const s={tileKey:t.id,error:e.message};return this.remoteClient.invoke("tileRenderer.onTileError",s,{signal:r.signal})}return Promise.resolve()}_getLabelingSchemaForScale(t){const e=this._schema.mesh.labels;if(e==null)return null;if(e.type==="subtype"){const s={type:"subtype",classes:{}};let i=!1;for(const a in e.classes){const n=e.classes[a].filter(o=>T(o,t.scale));i=i||!!n.length,s.classes[a]=n}return i?s:null}const r=e.classes.filter(s=>T(s,t.scale));return r.length?{type:"simple",classes:r}:null}_getLabels(t,e){if(e.type==="subtype"){const r=this.service.subtypeField,s=E(r,"Expected to find subtype Field"),i=t.readAttribute(s);return i==null?[]:e.classes[i]??[]}return e.classes}_getLabelInfos(t,e){const r=this._getLabelingSchemaForScale(t);if(r==null)return null;const s=new Map,i=e.getCursor();for(;i.next();){const a=i.getDisplayId(),n=[],o=A(a),l=o&&i.readAttribute("cluster_count")!==1?"aggregate":"feature",c=this._getLabels(i,r);for(const h of c){if(h.target!==l)continue;const f=i.getStorage(),u=o&&l==="feature"?f.getComputedStringAtIndex(i.readAttribute("referenceId"),h.fieldIndex):f.getComputedStringAtIndex(a,h.fieldIndex);if(!u)continue;const m=P(u.toString()),d=m[0],g=m[1];this._store.getMosaicItem(h.symbol,B(d)).then(p=>{n[h.index]={glyphs:p.glyphMosaicItems??[],rtl:g,index:h.index}})}s.set(a,n)}return s}};I=F([R("esri.views.2d.layers.features.processors.SymbolProcessor")],I);const de=I;export{de as default};
