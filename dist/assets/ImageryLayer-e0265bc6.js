import{e as a,y as u,s as nt,n as J,l as k,R as at}from"./cast-daef7652.js";import{k as ot}from"./PopupTemplate-343851b8.js";import{t as L,r as F,e as lt}from"./typedArrayUtil-2bcf3cee.js";import{O as ut}from"./MultiOriginJSONSupport-03b5d89b.js";import{w as pt}from"./promiseUtils-29120e0a.js";import{T as le,v as ie,a as ct}from"./ensureType-fa162cfc.js";import{o as M,w as X,r as O,k as ne,a as fe}from"./Extent-7f29a1bb.js";import{b as mt}from"./Layer-8a472a77.js";import{i as Ue}from"./geometry-4b789d90.js";import{g as dt}from"./Graphic-cf98a91a.js";import{w as x,o as Y,i as de,c as ht,l as yt,a as ft,u as gt,m as Rt,k as vt,L as bt,j as wt,$ as St,f as xt,n as It}from"./fetchRasterInfo-61d2b0ab.js";import{U as _,j as Ft}from"./request-c2b0ab45.js";import{s as Le,a as E}from"./Error-bd05b442.js";import{o as Oe}from"./jsonMap-a9c94baf.js";import{y as $}from"./string-3d0ebcd3.js";import{l as Tt}from"./reactiveUtils-3c1b281e.js";import{w as Dt,f as Nt,c as Pt,a as Ct,p as _t}from"./OperationalLayer-7b681a2a.js";import{p as Ie,m as qe,d as Ot,c as Vt}from"./multidimensionalUtils-5ae835b1.js";import{_ as Ge,h as Be,n as jt,f as Mt,k as At,b as $t,e as We,T as Jt,S as ze,P as Et}from"./RasterSymbolizer-9d8f2f14.js";import{a as Lt}from"./UniqueValueRenderer-83bbe8b7.js";import{y as re}from"./Field-0ac3c9d2.js";import{r as qt}from"./FieldsIndex-394de0a1.js";import{g as be}from"./pixelUtils-5f39bd45.js";import{f as zt,b as kt}from"./dataUtils-0f7e9d2b.js";import{f as ee,a as ue,b as pe,v as Ve}from"./normalizeUtils-d322ac85.js";import Ke from"./FeatureSet-9ea00c01.js";import{x as we}from"./Query-e996b56b.js";import{s as Ht}from"./executeQueryJSON-1890fc00.js";import"./unitUtils-43365914.js";import"./featureConversionUtils-7c9ea581.js";import{u as Qt,v as Ut}from"./Polyline-c56eca9b.js";import"./pbf-c27e6a55.js";import"./RelationshipQuery-c22f6308.js";import{s as Gt,n as Bt}from"./executeForIds-753b3d1d.js";import"./TopFeaturesQuery-da583ecc.js";import{T as je}from"./TimeExtent-84882adb.js";import{v as Ze,c as Me}from"./jsonUtils-8bd548d9.js";import{p as Wt}from"./ArcGISService-a76daa10.js";import{n as Kt}from"./BlendLayer-1b58b599.js";import{o as Zt}from"./CustomParametersMixin-35ce1754.js";import{v as Xt}from"./PortalLayer-4d594091.js";import{p as Yt}from"./RefreshableLayer-b2e977af.js";import{t as ei}from"./ScaleRangeLayer-d12362d4.js";import{a as ti}from"./TemporalLayer-e6ec9fbe.js";import{e as ii}from"./versionUtils-95cac3d6.js";import{p as ri}from"./popupUtils-aa41216c.js";import"./nextTick-3ee5a785.js";import"./Clonable-f249bc0f.js";import"./Collection-e2259e32.js";import"./Evented-d8fc77f0.js";import"./SimpleObservable-7c382d01.js";import"./fieldUtils-021fea8a.js";import"./preload-helper-101896b7.js";import"./arcadeOnDemand-87969052.js";import"./enumeration-e46f3fd4.js";import"./number-53937715.js";import"./locale-30120714.js";import"./Identifiable-e3a09883.js";import"./Loadable-7c89bd10.js";import"./Promise-088a0e17.js";import"./typeUtils-d7b057b5.js";import"./symbols-fce921a6.js";import"./CIMSymbol-d0e12b74.js";import"./Symbol-f45dc441.js";import"./Color-2245b966.js";import"./colorUtils-639f4d25.js";import"./mathUtils-daf59e84.js";import"./common-701a4199.js";import"./screenUtils-7afeb41c.js";import"./opacityUtils-94fd2faa.js";import"./aaBoundingBox-6fbd5972.js";import"./persistableUrlUtils-7e525def.js";import"./collectionUtils-09289d8f.js";import"./Portal-ac0dca24.js";import"./PortalGroup-f3dee6d8.js";import"./PortalUser-cdb4116b.js";import"./workers-125ce03d.js";import"./Connection-98b56925.js";import"./Queue-e839cb6a.js";import"./assets-4cb15247.js";import"./intl-afc91037.js";import"./messages-03a939ad.js";import"./LegendOptions-54bbb61a.js";import"./colorRamps-3439e132.js";import"./utils-95450d21.js";import"./asyncUtils-59234081.js";import"./parser-e6166e34.js";import"./mat4-62d5e6a4.js";import"./ItemCache-9a7b0057.js";import"./MemCache-5bd66e9c.js";import"./generateRendererUtils-92e71197.js";import"./ElevationInfo-4e7fad68.js";import"./lengthUtils-5215af35.js";import"./colorUtils-0c057879.js";import"./diffUtils-58fbd195.js";import"./sizeVariableUtils-d4870b0d.js";import"./compilerUtils-06ced1a6.js";import"./jsonUtils-f34afef9.js";import"./styleUtils-84c98663.js";import"./fieldType-4ec45634.js";import"./query-e9f3f48f.js";import"./pbfQueryUtils-21bc0894.js";import"./OptimizedFeature-9345d11b.js";import"./OptimizedFeatureSet-1d1ac4b9.js";import"./queryZScale-bb883c00.js";import"./zscale-a508c8e5.js";import"./arcgisLayerUrl-269cc7a9.js";import"./PortalItem-07c1e88d.js";import"./TimeInfo-cbe37d4e.js";const si={StretchFunction:{arguments:{ComputeGamma:{isDataset:!1,isPublic:!1,name:"ComputeGamma",type:"RasterFunctionVariable",value:!1},DRA:{isDataset:!1,isPublic:!1,name:"DRA",type:"RasterFunctionVariable",value:!1},EstimateStatsHistogram:{isDataset:!1,isPublic:!1,name:"EstimateStatsHistogram",type:"RasterFunctionVariable",value:!1},Gamma:{displayName:"Gamma",isDataset:!1,isPublic:!1,name:"Gamma",type:"RasterFunctionVariable"},Histograms:{isDataset:!1,isPublic:!1,name:"Histograms",type:"RasterFunctionVariable"},Max:{isDataset:!1,isPublic:!1,name:"Max",type:"RasterFunctionVariable",value:255},MaxPercent:{isDataset:!1,isPublic:!1,name:"MaxPercent",type:"RasterFunctionVariable",value:.5},Min:{isDataset:!1,isPublic:!1,name:"Min",type:"RasterFunctionVariable",value:0},MinPercent:{isDataset:!1,isPublic:!1,name:"MinPercent",type:"RasterFunctionVariable",value:.25},NumberOfStandardDeviations:{isDataset:!1,isPublic:!1,name:"NumberOfStandardDeviation",type:"RasterFunctionVariable",value:2},Raster:{isDataset:!0,isPublic:!1,name:"Raster",type:"RasterFunctionVariable"},SigmoidStrengthLevel:{isDataset:!1,isPublic:!1,name:"SigmoidStrengthLevel",type:"RasterFunctionVariable",value:2},Statistics:{isDataset:!1,isPublic:!1,name:"Statistics",type:"RasterFunctionVariable"},StretchType:{isDataset:!1,isPublic:!1,name:"StretchType",type:"RasterFunctionVariable",value:0},type:"StretchFunctionArguments",UseGamma:{isDataset:!1,isPublic:!1,name:"UseGamma",type:"RasterFunctionVariable",value:!1}},description:"Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.",function:{description:"Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.",name:"Stretch",pixelType:"UNKNOWN",type:"StretchFunction"},functionType:0,name:"Stretch",thumbnail:""},RemapFunction:{name:"Remap",description:"Changes pixel values by assigning new values to ranges of pixel values or using an external table.",function:{type:"RemapFunction",pixelType:"UNKNOWN",name:"Remap",description:"Changes pixel values by assigning new values to ranges of pixel values or using an external table."},arguments:{Raster:{name:"Raster",isPublic:!1,isDataset:!0,type:"RasterFunctionVariable"},UseTable:{name:"UseTable",isPublic:!1,isDataset:!1,value:!1,type:"RasterFunctionVariable"},InputRanges:{name:"InputRanges",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable",displayName:"Input Ranges"},OutputValues:{name:"OutputValues",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable",displayName:"Output Values"},NoDataRanges:{name:"NoDataRanges",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable",displayName:"NoData Ranges"},Table:{name:"Table",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable"},InputField:{name:"InputField",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable"},OutputField:{name:"OutputField",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable"},InputMaxField:{name:"InputMaxField",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable"},RemapTableType:{name:"RemapTableType",isPublic:!1,isDataset:!1,value:1,type:"RasterFunctionVariable"},AllowUnmatched:{name:"AllowUnmatched",isPublic:!1,isDataset:!1,value:!0,type:"RasterFunctionVariable"},type:"RemapFunctionArguments"},functionType:0,thumbnail:""},ColormapFunction:{name:"Colormap",description:"Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.",function:{type:"ColormapFunction",pixelType:"UNKNOWN",name:"Colormap",description:"Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp."},arguments:{Raster:{name:"Raster",isPublic:!1,isDataset:!0,type:"RasterFunctionVariable"},ColorSchemeType:{name:"ColorSchemeType",isPublic:!1,isDataset:!1,value:1,type:"RasterFunctionVariable"},Colormap:{name:"Colormap",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable"},ColormapName:{name:"ColormapName",isPublic:!1,isDataset:!1,value:"Gray",type:"RasterFunctionVariable"},ColorRamp:{name:"ColorRamp",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable"},type:"ColormapFunctionArguments"},functionType:0,thumbnail:""},ShadedReliefFunction:{name:"Shaded Relief",description:"Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.",function:{type:"ShadedReliefFunction",pixelType:"UNKNOWN",name:"Shaded Relief",description:"Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image."},arguments:{Raster:{name:"Raster",isPublic:!1,isDataset:!0,type:"RasterFunctionVariable"},ColorSchemeType:{name:"ColorSchemeType",isPublic:!1,isDataset:!1,value:1,type:"RasterFunctionVariable"},ColorRamp:{name:"ColorRamp",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable"},HillshadeType:{name:"HillshadeType",isPublic:!1,isDataset:!1,value:0,type:"RasterFunctionVariable"},Colormap:{name:"Colormap",isPublic:!1,isDataset:!1,type:"RasterFunctionVariable"},Azimuth:{name:"Azimuth",isPublic:!1,isDataset:!1,value:315,type:"RasterFunctionVariable"},Altitude:{name:"Altitude",isPublic:!1,isDataset:!1,value:45,type:"RasterFunctionVariable"},SlopeType:{name:"SlopeType",isPublic:!1,isDataset:!1,value:1,type:"RasterFunctionVariable"},ZFactor:{name:"ZFactor",isPublic:!1,isDataset:!1,value:1,type:"RasterFunctionVariable"},PSPower:{name:"PSPower",isPublic:!1,isDataset:!1,value:.664,type:"RasterFunctionVariable"},PSZFactor:{name:"PSZFactor",isPublic:!1,isDataset:!1,value:.024,type:"RasterFunctionVariable"},RemoveEdgeEffect:{name:"RemoveEdgeEffect",isPublic:!1,isDataset:!1,value:!1,type:"RasterFunctionVariable"},type:"ShadedReliefFunctionArguments"},functionType:0,thumbnail:""},HillshadeFunction:{name:"Hillshade",description:"Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image",function:{type:"HillshadeFunction",pixelType:"UNKNOWN",name:"Hillshade",description:"Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image"},arguments:{DEM:{name:"DEM",isPublic:!1,isDataset:!0,type:"RasterFunctionVariable"},HillshadeType:{name:"HillshadeType",isPublic:!1,isDataset:!1,value:0,type:"RasterFunctionVariable"},Azimuth:{name:"Azimuth",isPublic:!1,isDataset:!1,value:315,type:"RasterFunctionVariable"},Altitude:{name:"Altitude",isPublic:!1,isDataset:!1,value:45,type:"RasterFunctionVariable"},SlopeType:{name:"SlopeType",isPublic:!1,isDataset:!1,value:1,type:"RasterFunctionVariable"},ZFactor:{name:"ZFactor",isPublic:!1,isDataset:!1,value:1,type:"RasterFunctionVariable"},PSPower:{name:"PSPower",isPublic:!1,isDataset:!1,value:.664,type:"RasterFunctionVariable"},PSZFactor:{name:"PSZFactor",isPublic:!1,isDataset:!1,value:.024,type:"RasterFunctionVariable"},RemoveEdgeEffect:{name:"RemoveEdgeEffect",isPublic:!1,isDataset:!1,value:!1,type:"RasterFunctionVariable"},type:"HillshadeFunctionArguments"},functionType:0,thumbnail:""},ResampleFunction:{name:"Resample",description:"Changes the cell size of a raster.",function:{type:"ResampleFunction",pixelType:"UNKNOWN",name:"Resample",description:"Changes the cell size of a raster."},arguments:{Raster:{name:"Raster",isPublic:!1,isDataset:!0,type:"RasterFunctionVariable"},ResamplingType:{name:"ResamplingType",isPublic:!1,isDataset:!1,value:0,type:"RasterFunctionVariable"},InputCellSize:{name:"InputCellsize",isPublic:!1,isDataset:!1,value:{x:0,y:0},type:"RasterFunctionVariable"},OutputCellSize:{name:"OutputCellsize",isPublic:!1,isDataset:!1,value:{x:0,y:0},type:"RasterFunctionVariable"},type:"ResampleFunctionArguments"},functionType:0,thumbnail:""}},ni={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767]},ai={simple_scalar:"Simple Scalar",wind_barb:"Wind Barb",single_arrow:"Single Arrow",beaufort_kn:"Beaufort Wind (Knots)",beaufort_m:"Beaufort Wind (MetersPerSecond)",ocean_current_m:"Ocean Current (MetersPerSecond)",ocean_current_kn:"Ocean Current (Knots)"},oi=new Set(["raster-stretch","unique-value","class-breaks","raster-shaded-relief","vector-field","raster-colormap"]);function Xe(s){return oi.has(s.type)}function Se(s,t){if(!s||!t)return $(s||t);const o=$(s);if(t.rasterFunctionDefinition){const e=t.rasterFunctionDefinition;(e.thumbnail||e.thumbnailEx)&&(e.thumbnail=e.thumbnailEx=null),Ye(o.rasterFunctionDefinition.arguments,t)}else t.functionName.toLowerCase()!=="none"&&(et(o.functionArguments).Raster=t);return o}function Ye(s,t){for(const o in s)o.toLowerCase()==="raster"&&(s[o].type==="RasterFunctionVariable"?(s[o]=t.rasterFunctionDefinition,s[o].type="RasterFunctionTemplate"):s[o].type==="RasterFunctionTemplate"&&Ye(s[o].arguments,t))}function W(s){const t=$(si[s.functionName+"Function"]),o=s.functionArguments;for(const e in o)e.toLowerCase()==="raster"?(t.arguments[e]=W(o[e]),t.arguments[e].type="RasterFunctionTemplate"):e.toLowerCase()==="colormap"?(t.arguments[e].value=fi(o[e]),t.arguments.ColorSchemeType.value=0):t.arguments[e].value=o[e];return t}function li(s,t){switch(t=t||{},s.type){case"raster-stretch":return ci(s,t);case"class-breaks":return mi(s,t);case"unique-value":return di(s,t);case"raster-colormap":return hi(s,t);case"vector-field":return ui(s,t);case"raster-shaded-relief":return pi(s,t);case"flow":throw new Error("Unsupported rendering rule.")}}function et(s){const t=s==null?void 0:s.Raster;return t&&t.declaredClass==="esri.layers.support.RasterFunction"?et(t.functionArguments):s}const me={none:0,standardDeviation:3,histogramEqualization:4,minMax:5,percentClip:6,sigmoid:9};function ui(s,t){const o=new x;o.functionName="VectorFieldRenderer";const{dataType:e,bandProperties:i}=t,r=e==="vector-uv";let n,l;i&&i.length===2&&(n=i.map(h=>h.BandName.toLowerCase()).indexOf("magnitude"),l=i.map(h=>h.BandName.toLowerCase()).indexOf("direction")),n!==-1&&n!==null||(n=0,l=1);const p=s.rotationType==="arithmetic"?1:2,m=s.flowRepresentation==="flow-from"?0:1,c=s.visualVariables?s.visualVariables.find(h=>h.field==="Magnitude"):new Lt,d={magnitudeBandID:n,directionBandID:l,isUVComponents:r,referenceSystem:p,massFlowAngleRepresentation:m,symbolTileSize:50,symbolTileSizeUnits:100,calculationMethod:"Vector Average",symbologyName:ai[s.style.toLowerCase().replace("-","_")],minimumMagnitude:c.minDataValue,maximumMagnitude:c.maxDataValue,minimumSymbolSize:c.minSize,maximumSymbolSize:c.maxSize};return o.functionArguments=d,t.convertToRFT?new x({rasterFunctionDefinition:W(o)}):o}function pi(s,t){const o=t.convertToRFT;if(t.dataType!=="elevation"&&(t.dataType!=="generic"||t.bandCount!==1||t.pixelType!=="s16"&&t.pixelType!=="s32"&&t.pixelType!=="f32"&&t.pixelType!=="f64"))return new x;const e=new x;e.functionName="Hillshade";const i=s.hillshadeType==="traditional"?0:1,r=s.scalingType==="none"?1:3,n={HillshadeType:i,SlopeType:r,ZFactor:s.zFactor};return i===0&&(n.Azimuth=s.azimuth,n.Altitude=s.altitude),r===3&&(n.PSPower=s.pixelSizePower,n.PSZFactor=s.pixelSizeFactor),e.functionArguments=n,e.variableName="Raster",s.colorRamp&&(e.functionName="ShadedRelief",o?n.ColorRamp=Ge(s.colorRamp):n.Colormap=Be(s.colorRamp,256)),o?new x({rasterFunctionDefinition:W(e)}):e}function ci(s,t){var l;const o=t.convertToRFT,e=new x;e.functionName="Stretch";const i=me[jt.toJSON(s.stretchType)],r="u8",n={StretchType:i,Statistics:yi(s.statistics),DRA:s.dynamicRangeAdjustment,UseGamma:s.useGamma,Gamma:s.gamma,ComputeGamma:s.computeGamma};if(s.outputMin!=null&&(n.Min=s.outputMin),s.outputMax!=null&&(n.Max=s.outputMax),i===me.standardDeviation?(n.NumberOfStandardDeviations=s.numberOfStandardDeviations,e.outputPixelType=r):i===me.percentClip?(n.MinPercent=s.minPercent,n.MaxPercent=s.maxPercent,e.outputPixelType=r):i===me.minMax?e.outputPixelType=r:i===me.sigmoid&&(n.SigmoidStrengthLevel=s.sigmoidStrengthLevel),e.functionArguments=n,e.variableName="Raster",s.colorRamp){const p=s.colorRamp,m=new x;if(o)m.functionArguments={ColorRamp:Ge(p)};else{const c=Mt(p);if(c)m.functionArguments={colorRamp:c};else if(!t.convertColorRampToColormap||p.type!=="algorithmic"&&p.type!=="multipart"){const d=s.colorRamp.toJSON();d.type==="algorithmic"?d.algorithm=d.algorithm||"esriCIELabAlgorithm":d.type==="multipart"&&((l=d.colorRamps)!=null&&l.length)&&d.colorRamps.forEach(h=>h.algorithm=h.algorithm||"esriCIELabAlgorithm"),m.functionArguments={colorRamp:d}}else m.functionArguments={Colormap:Be(p,256)}}return m.variableName="Raster",m.functionName="Colormap",m.functionArguments.Raster=e,o?new x({rasterFunctionDefinition:W(m)}):m}return o?new x({rasterFunctionDefinition:W(e)}):e}function mi(s,t){const o=[],e=[],i=[],r=[],{pixelType:l,rasterAttributeTable:p}=t,m=L(p)?null:p.features,c=tt(p);if(m&&Array.isArray(m)&&s.classBreakInfos){s.classBreakInfos.forEach((f,T)=>{const V=f.symbol.color;let w;V.a&&m.forEach(v=>{w=v.attributes[s.field],(w>=f.minValue&&w<f.maxValue||T===s.classBreakInfos.length-1&&w>=f.minValue)&&r.push([v.attributes[c],V.r,V.g,V.b])})});const g=l?ve(r,l):r,y=new x;return y.functionName="Colormap",y.functionArguments={},y.functionArguments.Colormap=g,y.variableName="Raster",t.convertToRFT?new x({rasterFunctionDefinition:W(y)}):y}s.classBreakInfos.forEach((g,y)=>{const f=g.symbol&&g.symbol.color;f.a?(y===0?o.push(g.minValue,g.maxValue+1e-6):o.push(g.minValue+1e-6,g.maxValue+1e-6),e.push(y),r.push([y,f.r,f.g,f.b])):i.push(g.minValue,g.maxValue)});const d=l?ve(r,l):r,h=new x;h.functionName="Remap",h.functionArguments={InputRanges:o,OutputValues:e,NoDataRanges:i},h.variableName="Raster";const R=new x;return R.functionName="Colormap",R.functionArguments={Colormap:d,Raster:h},t.convertToRFT?new x({rasterFunctionDefinition:W(R)}):R}function ve(s,t){const o=ni[String(t).toLowerCase()];return o&&s.push([Math.floor(o[0]-1),0,0,0],[Math.ceil(o[1]+1),0,0,0]),s}function tt(s){if(L(s))return;const{fields:t}=s,o=t&&t.find(e=>e&&e.name&&e.name.toLowerCase()==="value");return o&&o.name}function di(s,t){var d,h;const o=[],{pixelType:e,rasterAttributeTable:i}=t,r=L(i)?null:i.features,n=tt(i),l=(h=(d=s.defaultSymbol)==null?void 0:d.color)==null?void 0:h.toRgb(),p=s.uniqueValueInfos;if(p)if(r){const R=new Map;p.forEach(y=>{const f=y.value,T=y.symbol.color;f!=null&&T&&T.a&&R.set(String(f),T.toRgb())});const g=s.field;r.forEach(({attributes:y})=>{const f=String(y[g]),T=y[n];if(R.has(f)){const V=R.get(f);o.push([T,...V])}else l&&o.push([T,...l])})}else for(let R=0;R<p.length;R++){const g=p[R],y=g.symbol.color,f=+g.value;if(y!=null&&y.a){if(isNaN(f))return null;o.push([f,y.r,y.g,y.b])}}const m=e&&o.length>0?ve(o,e):o,c=new x;return c.functionName="Colormap",c.functionArguments={},c.functionArguments.Colormap=m,c.variableName="Raster",t.convertToRFT?new x({rasterFunctionDefinition:W(c)}):c}function hi(s,t){const o=s.extractColormap();if(!o||o.length===0)return;const{pixelType:e}=t,i=e?ve(o,e):o,r=new x;return r.functionName="Colormap",r.functionArguments={},r.functionArguments.Colormap=i,t.convertToRFT?new x({rasterFunctionDefinition:W(r)}):r}function yi(s){const t=[];return s.forEach(o=>{const e=o;if(Array.isArray(e))t.push(e);else{if(e.min==null||e.max==null)return;const i=[e.min,e.max,e.avg||0,e.stddev||0];t.push(i)}}),t}function fi(s){const t=[],o=[];return s.forEach(e=>{t.push(e[0]),o.push(At([...e.slice(1),255]))}),{type:"RasterColormap",values:t,colors:o}}var Fe;const he=Oe()({MT_FIRST:"first",MT_LAST:"last",MT_MIN:"min",MT_MAX:"max",MT_MEAN:"mean",MT_BLEND:"blend",MT_SUM:"sum"}),Te=Oe()({esriMosaicNone:"none",esriMosaicCenter:"center",esriMosaicNadir:"nadir",esriMosaicViewpoint:"viewpoint",esriMosaicAttribute:"attribute",esriMosaicLockRaster:"lock-raster",esriMosaicNorthwest:"northwest",esriMosaicSeamline:"seamline"});function gi(s){let t;switch(s?s.toLowerCase().replace("esrimosaic",""):""){case"byattribute":case"attribute":t="esriMosaicAttribute";break;case"lockraster":t="esriMosaicLockRaster";break;case"center":t="esriMosaicCenter";break;case"northwest":t="esriMosaicNorthwest";break;case"nadir":t="esriMosaicNadir";break;case"viewpoint":t="esriMosaicViewpoint";break;case"seamline":t="esriMosaicSeamline";break;default:t="esriMosaicNone"}return Te.fromJSON(t)}let j=Fe=class extends k{constructor(s){super(s),this.ascending=!0,this.itemRenderingRule=null,this.lockRasterIds=null,this.method=null,this.multidimensionalDefinition=null,this.objectIds=null,this.operation=null,this.sortField=null,this.sortValue=null,this.viewpoint=null,this.where=null}readAscending(s,t){return t.ascending!=null?t.ascending:t.sortAscending==null||t.sortAscending}readMethod(s,t){return gi(t.mosaicMethod||t.defaultMosaicMethod)}readOperation(s,t){const o=t.mosaicOperation,e=t.mosaicOperator&&t.mosaicOperator.toLowerCase(),i=o||(e?he.toJSON(e):null);return he.fromJSON(i)||"first"}castSortValue(s){return s==null||typeof s=="string"||typeof s=="number"?s:`${s}`}clone(){return new Fe({ascending:this.ascending,itemRenderingRule:$(this.itemRenderingRule),lockRasterIds:$(this.lockRasterIds),method:this.method,multidimensionalDefinition:$(this.multidimensionalDefinition),objectIds:$(this.objectIds),operation:this.operation,sortField:this.sortField,sortValue:this.sortValue,viewpoint:$(this.viewpoint),where:this.where})}};a([u({type:Boolean,json:{write:!0}})],j.prototype,"ascending",void 0),a([M("ascending",["ascending","sortAscending"])],j.prototype,"readAscending",null),a([u({type:x,json:{write:!0}})],j.prototype,"itemRenderingRule",void 0),a([u({type:[le],json:{write:{overridePolicy(){return{enabled:this.method==="lock-raster"}}}}})],j.prototype,"lockRasterIds",void 0),a([u({type:String,json:{type:Te.jsonValues,write:{target:"mosaicMethod",writer:Te.write}}})],j.prototype,"method",void 0),a([M("method",["mosaicMethod","defaultMosaicMethod"])],j.prototype,"readMethod",null),a([u({type:[Ie],json:{write:!0}})],j.prototype,"multidimensionalDefinition",void 0),a([u({type:[le],json:{name:"fids",write:!0}})],j.prototype,"objectIds",void 0),a([u({json:{type:he.jsonValues,read:{reader:he.read},write:{target:"mosaicOperation",writer:he.write}}})],j.prototype,"operation",void 0),a([M("operation",["mosaicOperation","mosaicOperator"])],j.prototype,"readOperation",null),a([u({type:String,json:{write:{overridePolicy(){return{enabled:this.method==="attribute"}}}}})],j.prototype,"sortField",void 0),a([u({type:[String,Number],json:{write:{allowNull:!0,overridePolicy(){return{enabled:this.method==="attribute",allowNull:!0}}}}})],j.prototype,"sortValue",void 0),a([nt("sortValue")],j.prototype,"castSortValue",null),a([u({type:X,json:{write:!0}})],j.prototype,"viewpoint",void 0),a([u({type:String,json:{write:!0}})],j.prototype,"where",void 0),j=Fe=a([J("esri.layers.support.MosaicRule")],j);const z=j;let P=class extends k{constructor(){super(...arguments),this.layer=null,this.adjustAspectRatio=void 0,this.compression=void 0,this.pixelType=void 0,this.lercVersion=2}writeAdjustAspectRatio(t,o,e){this.layer.version<10.3||(o[e]=t)}get bandIds(){return this.layer.bandIds}set bandIds(t){this.layer&&(this.layer.bandIds=t)}get compressionQuality(){var t;return(t=this.layer)==null?void 0:t.compressionQuality}set compressionQuality(t){this.layer&&(this.layer.compressionQuality=t)}writeCompressionQuality(t,o,e){this.format&&this.format.toLowerCase().includes("jpg")&&t!=null&&(o[e]=t)}get compressionTolerance(){var t;return(t=this.layer)==null?void 0:t.compressionTolerance}set compressionTolerance(t){this.layer&&(this.layer.compressionTolerance=t)}writeCompressionTolerance(t,o,e){this.format==="lerc"&&t!=null&&(o[e]=t)}get format(){var t;return((t=this.layer.renderer)==null?void 0:t.type)==="vector-field"?"lerc":this.layer.format}get interpolation(){var t;return(t=this.layer)==null?void 0:t.interpolation}set interpolation(t){this.layer&&(this.layer.interpolation=t)}get noData(){var t;return(t=this.layer)==null?void 0:t.noData}set noData(t){this.layer&&(this.layer.noData=t)}get noDataInterpretation(){var t;return(t=this.layer)==null?void 0:t.noDataInterpretation}set noDataInterpretation(t){this.layer&&(this.layer.noDataInterpretation=t)}writeLercVersion(t,o,e){this.format==="lerc"&&this.layer.version>=10.5&&(o[e]=t)}get version(){const t=this.layer;return t.commitProperty("bandIds"),t.commitProperty("format"),t.commitProperty("compressionQuality"),t.commitProperty("compressionTolerance"),t.commitProperty("interpolation"),t.commitProperty("noData"),t.commitProperty("noDataInterpretation"),t.commitProperty("mosaicRule"),t.commitProperty("renderingRule"),t.commitProperty("adjustAspectRatio"),t.commitProperty("pixelFilter"),t.commitProperty("definitionExpression"),t.commitProperty("multidimensionalSubset"),(this._get("version")||0)+1}set version(t){this._set("version",t)}get mosaicRule(){const t=this.layer;let o=t.mosaicRule;const e=t.definitionExpression;return o?e&&e!==o.where&&(o=o.clone(),o.where=e):e&&(o=new z({where:e})),o}get renderingRule(){var n,l;const t=this.layer;let o=t.renderingRule;const e=t.pixelFilter,i=!t.format||t.format.includes("jpg")||t.format.includes("png");o=this._addResampleRasterFunction(o);const r=(n=t.multidimensionalSubset)==null?void 0:n.areaOfInterest;return r&&(o=this._addClipFunction(o,r)),i&&!e&&((l=t.renderer)==null?void 0:l.type)!=="vector-field"&&(o=this.combineRendererWithRenderingRule(o)),o}combineRendererWithRenderingRule(t){var r;const o=this.layer,{rasterInfo:e,renderer:i}=o;return t=t||o.renderingRule,!i||!Xe(i)?t:Se(li(i,{rasterAttributeTable:e.attributeTable,pixelType:e.pixelType,dataType:e.dataType,bandProperties:(r=e.keyProperties)==null?void 0:r.BandProperties,convertColorRampToColormap:o.version<10.6,convertToRFT:!!(t!=null&&t.rasterFunctionDefinition),bandCount:e.bandCount}),t)}_addResampleRasterFunction(t){var r;if(((r=this.layer.renderer)==null?void 0:r.type)!=="vector-field"||(t==null?void 0:t.functionName)==="Resample")return t;const o=this.layer.serviceDataType==="esriImageServiceDataTypeVector-UV"?7:10,e=this.layer.serviceRasterInfo.pixelSize;let i=new x({functionName:"Resample",functionArguments:{ResamplingType:o,InputCellSize:e}});return i=t!=null&&t.rasterFunctionDefinition?new x({rasterFunctionDefinition:W(i)}):i,Se(i,t)}_addClipFunction(t,o){const e=new x({functionName:"Clip",functionArguments:{ClippingGeometry:o.toJSON(),ClippingType:1}});return Se(e,t)}};a([u()],P.prototype,"layer",void 0),a([u({json:{write:!0}})],P.prototype,"adjustAspectRatio",void 0),a([O("adjustAspectRatio")],P.prototype,"writeAdjustAspectRatio",null),a([u({json:{write:!0}})],P.prototype,"bandIds",null),a([u({json:{write:!0}})],P.prototype,"compression",void 0),a([u({json:{write:!0}})],P.prototype,"compressionQuality",null),a([O("compressionQuality")],P.prototype,"writeCompressionQuality",null),a([u({json:{write:!0}})],P.prototype,"compressionTolerance",null),a([O("compressionTolerance")],P.prototype,"writeCompressionTolerance",null),a([u({json:{write:!0}})],P.prototype,"format",null),a([u({type:String,json:{read:{reader:Y.read},write:{writer:Y.write}}})],P.prototype,"interpolation",null),a([u({json:{write:!0}})],P.prototype,"noData",null),a([u({type:String,json:{read:{reader:de.read},write:{writer:de.write}}})],P.prototype,"noDataInterpretation",null),a([u({json:{write:!0}})],P.prototype,"pixelType",void 0),a([u({json:{write:!0}})],P.prototype,"lercVersion",void 0),a([O("lercVersion")],P.prototype,"writeLercVersion",null),a([u({type:Number})],P.prototype,"version",null),a([u({json:{write:!0}})],P.prototype,"mosaicRule",null),a([u({json:{write:!0}})],P.prototype,"renderingRule",null),P=a([J("esri.layers.mixins.ExportImageServiceParameters")],P);let ae=class extends k{constructor(){super(...arguments),this.north=null,this.up=null,this.spatialReference=null}};a([u({type:Number,json:{write:!0}})],ae.prototype,"north",void 0),a([u({type:Number,json:{write:!0}})],ae.prototype,"up",void 0),a([u({type:ne,json:{write:!0}})],ae.prototype,"spatialReference",void 0),ae=a([J("esri.rest.support.ImageAngleResult")],ae);const Ri=ae;let H=class extends k{constructor(){super(...arguments),this.catalogItemVisibilities=null,this.catalogItems=null,this.location=null,this.name=null,this.objectId=null,this.processedValues=null,this.properties=null,this.value=null}};a([u({json:{write:!0}})],H.prototype,"catalogItemVisibilities",void 0),a([u({type:Ke,json:{write:!0}})],H.prototype,"catalogItems",void 0),a([u({type:X,json:{write:!0}})],H.prototype,"location",void 0),a([u({json:{write:!0}})],H.prototype,"name",void 0),a([u({json:{write:!0}})],H.prototype,"objectId",void 0),a([u({json:{write:!0}})],H.prototype,"processedValues",void 0),a([u({json:{write:!0}})],H.prototype,"properties",void 0),a([u({json:{write:!0}})],H.prototype,"value",void 0),H=a([J("esri.rest.support.ImageIdentifyResult")],H);const vi=H;let ge=class extends k{constructor(){super(...arguments),this.geometries=null}};a([u({json:{write:!0}})],ge.prototype,"geometries",void 0),ge=a([J("esri.rest.support.ImagePixelLocationResult")],ge);const bi=ge;let Z=class extends k{constructor(){super(...arguments),this.attributes=null,this.location=null,this.locationId=null,this.rasterId=null,this.resolution=null,this.pixelValue=null}};a([u({json:{write:!0}})],Z.prototype,"attributes",void 0),a([u({type:X,json:{write:!0}})],Z.prototype,"location",void 0),a([u({json:{write:!0}})],Z.prototype,"locationId",void 0),a([u({json:{write:!0}})],Z.prototype,"rasterId",void 0),a([u({json:{write:!0}})],Z.prototype,"resolution",void 0),a([u({json:{write:!0}})],Z.prototype,"pixelValue",void 0),Z=a([J("esri.rest.support.ImageSample")],Z);const wi=Z;let Re=class extends k{constructor(){super(...arguments),this.samples=null}};a([u({type:[wi],json:{write:!0}})],Re.prototype,"samples",void 0),Re=a([J("esri.rest.support.ImageSampleResult")],Re);const Si=Re;function it(s){const t=s==null?void 0:s.time;if(t&&(t.start!=null||t.end!=null)){const o=[];t.start!=null&&o.push(t.start),t.end==null||o.includes(t.end)||o.push(t.end),s.time=o.join(",")}}async function rt(s,t,o){const e=ee(s),i=t.geometry?[t.geometry]:[],r=await Ve(i),n=t.toJSON();it(n);const l=r&&r[0];F(l)&&(n.geometry=l.toJSON());const p=ue({...e.query,f:"json",...n});return pe(p,o)}async function xi(s,t,o){var p;const e=t.toJSON();F(e.angleName)&&(e.angleName=e.angleName.join(",")),F(t.point)&&((p=t.point.spatialReference)!=null&&p.imageCoordinateSystem)&&(e.point.spatialReference=Ae(t.point.spatialReference)),F(t.spatialReference)&&t.spatialReference.imageCoordinateSystem&&(e.spatialReference=st(t.spatialReference));const i=ee(s),r=ue({...i.query,f:"json",...e}),n=pe(r,o),{data:l}=await _(`${i.path}/computeAngles`,n);return l.spatialReference=l.spatialReference?l.spatialReference.geodataXform!=null?new ne({wkid:0,imageCoordinateSystem:l.spatialReference}):ne.fromJSON(l.spatialReference):null,l.north==="NaN"&&(l.north=null),l.up==="NaN"&&(l.up=null),new Ri(l)}async function Ii(s,t,o){var m;const e=t.toJSON(),{geometries:i}=t;if(i)for(let c=0;c<i.length;c++)(m=i[c].spatialReference)!=null&&m.imageCoordinateSystem&&(e.geometries.geometries[c].spatialReference=Ae(i[c].spatialReference));const r=ee(s),n=ue({...r.query,f:"json",...e}),l=pe(n,o),{data:p}=await _(`${r.path}/computePixelLocation`,l);return bi.fromJSON(p)}async function Fi(s,t,o){const e=await rt(s,t,o),i=ee(s),{data:r}=await _(`${i.path}/computeStatisticsHistograms`,e),{statistics:n}=r;return n!=null&&n.length&&n.forEach(l=>{l.avg=l.mean,l.stddev=l.standardDeviation}),{statistics:n,histograms:r.histograms}}async function Ti(s,t,o){const e=await rt(s,t,o),i=ee(s),{data:r}=await _(`${i.path}/computeHistograms`,e);return{histograms:r.histograms}}async function Di(s,t,o){var c,d,h;const e=t.toJSON();it(e),(c=e.outFields)!=null&&c.length&&(e.outFields=e.outFields.join(","));const i=(d=await Ve(t.geometry))==null?void 0:d[0];F(i)&&(e.geometry=i.toJSON());const r=ee(s),n=ue({...r.query,f:"json",...e}),l=pe(n,o),{data:p}=await _(`${r.path}/getSamples`,l),m=(h=p==null?void 0:p.samples)==null?void 0:h.map(R=>{const g=R.value==="NaN"||R.value===""?null:R.value.split(" ").map(y=>Number(y));return{...R,pixelValue:g}});return Si.fromJSON({samples:m})}async function ke(s,t,o){const e=ee(s),i=t.geometry?[t.geometry]:[];return Ve(i).then(r=>{const n=t.toJSON(),l=r&&r[0];F(l)&&(n.geometry=JSON.stringify(l.toJSON()));const p=ue({...e.query,f:"json",...n}),m=pe(p,o);return _(e.path+"/identify",m)}).then(r=>vi.fromJSON(r.data))}function Ae(s){const{imageCoordinateSystem:t}=s;if(t){const{id:o,referenceServiceName:e}=t;return o!=null?e?{icsid:o,icsns:e}:{icsid:o}:{ics:t}}return s.toJSON()}function st(s,t){const o=Ae(s),{icsid:e,icsns:i,wkid:r}=o;return e!=null?i==null||t!=null&&t.toLowerCase().includes("/"+i.toLowerCase()+"/")?`0:${e}`:JSON.stringify(o):r?r.toString():JSON.stringify(o)}async function Ni(s,t,o){var v,I;const e=ee(s),i=ue({...e==null?void 0:e.query,f:"json"}),r=pe(i,o),n=`${e==null?void 0:e.path}/${t}/info`,l=_(`${n}`,r),p=_(`${n}/keyProperties`,r),m=await Promise.allSettled([l,p]),c=m[0].status==="fulfilled"?m[0].value.data:null,d=m[1].status==="fulfilled"?m[1].value.data:null;let h=null;(v=c.statistics)!=null&&v.length&&(h=c.statistics.map(b=>({min:b[0],max:b[1],avg:b[2],stddev:b[3]})));const R=fe.fromJSON(c.extent),g=Math.ceil(R.width/c.pixelSizeX-.1),y=Math.ceil(R.height/c.pixelSizeY-.1),f=R.spatialReference,T=new X({x:c.pixelSizeX,y:c.pixelSizeY,spatialReference:f}),V=(I=c.histograms)!=null&&I.length?c.histograms:null,w=new $t({origin:c.origin,blockWidth:c.blockWidth,blockHeight:c.blockHeight,firstPyramidLevel:c.firstPyramidLevel,maximumPyramidLevel:c.maxPyramidLevel});return new We({width:g,height:y,bandCount:c.bandCount,extent:R,spatialReference:f,pixelSize:T,pixelType:c.pixelType.toLowerCase(),statistics:h,histograms:V,keyProperties:d,storageInfo:w})}var De;let se=De=class extends k{constructor(){super(...arguments),this.angleNames=null,this.point=null,this.spatialReference=null,this.rasterId=null}clone(){return new De($({angleNames:this.angleNames,point:this.point,spatialReference:this.spatialReference,rasterId:this.rasterId}))}};a([u({type:[String],json:{name:"angleName",write:!0}})],se.prototype,"angleNames",void 0),a([u({type:X,json:{write:!0}})],se.prototype,"point",void 0),a([u({type:ne,json:{write:!0}})],se.prototype,"spatialReference",void 0),a([u({type:le,json:{write:!0}})],se.prototype,"rasterId",void 0),se=De=a([J("esri.rest.support.ImageAngleParameters")],se);const Pi=se;var Ne;let B=Ne=class extends k{constructor(){super(...arguments),this.geometry=null,this.mosaicRule=null,this.renderingRule=null,this.pixelSize=null,this.raster=void 0,this.timeExtent=null}writeGeometry(s,t,o){s!=null&&(t.geometryType=Me(s),t[o]=s.toJSON())}clone(){return new Ne($({geometry:this.geometry,mosaicRule:this.mosaicRule,renderingRule:this.renderingRule,pixelSize:this.pixelSize,raster:this.raster,timeExtent:this.timeExtent}))}};a([u({types:Ue,json:{read:Ze}})],B.prototype,"geometry",void 0),a([O("geometry")],B.prototype,"writeGeometry",null),a([u({type:z,json:{write:!0}})],B.prototype,"mosaicRule",void 0),a([u({type:x,json:{write:!0}})],B.prototype,"renderingRule",void 0),a([u({type:X,json:{write:!0}})],B.prototype,"pixelSize",void 0),a([u({json:{write:!0}})],B.prototype,"raster",void 0),a([u({type:je,json:{read:{source:"time"},write:{target:"time"}}})],B.prototype,"timeExtent",void 0),B=Ne=a([J("esri.rest.support.ImageHistogramParameters")],B);const He=B;var Pe;let C=Pe=class extends k{constructor(){super(...arguments),this.geometry=null,this.renderingRules=null,this.pixelSize=null,this.returnGeometry=!0,this.returnCatalogItems=!0,this.returnPixelValues=!0,this.maxItemCount=null,this.timeExtent=null,this.raster=void 0,this.viewId=void 0,this.processAsMultidimensional=!1}writeGeometry(s,t,o){s!=null&&(t.geometryType=Me(s),t[o]=JSON.stringify(s.toJSON()))}set mosaicRule(s){let t=s;t&&t.mosaicMethod&&(t=z.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set("mosaicRule",t)}writeMosaicRule(s,t,o){s!=null&&(t[o]=JSON.stringify(s.toJSON()))}set renderingRule(s){let t=s;t&&t.rasterFunction&&(t=x.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set("renderingRule",t)}writeRenderingRule(s,t,o){s!=null&&(t[o]=JSON.stringify(s.toJSON())),s.rasterFunctionDefinition&&(t[o]=JSON.stringify(s.rasterFunctionDefinition))}writeRenderingRules(s,t,o){s!=null&&(t[o]=JSON.stringify(s.map(e=>e.rasterFunctionDefinition||e.toJSON())))}writePixelSize(s,t,o){s!=null&&(t[o]=JSON.stringify(s))}writeTimeExtent(s,t,o){if(s!=null){const e=F(s.start)?s.start.getTime():null,i=F(s.end)?s.end.getTime():null;t[o]=e!=null?i!=null?`${e},${i}`:`${e}`:null}}clone(){return new Pe($({geometry:this.geometry,mosaicRule:this.mosaicRule,renderingRule:this.renderingRule,pixelSize:this.pixelSize,returnGeometry:this.returnGeometry,returnCatalogItems:this.returnCatalogItems,returnPixelValues:this.returnPixelValues,maxItemCount:this.maxItemCount,processAsMultidimensional:this.processAsMultidimensional,raster:this.raster,viewId:this.viewId,timeExtent:this.timeExtent}))}};a([u({json:{write:!0}})],C.prototype,"geometry",void 0),a([O("geometry")],C.prototype,"writeGeometry",null),a([u({type:z,json:{write:!0}})],C.prototype,"mosaicRule",null),a([O("mosaicRule")],C.prototype,"writeMosaicRule",null),a([u({type:x,json:{write:!0}})],C.prototype,"renderingRule",null),a([O("renderingRule")],C.prototype,"writeRenderingRule",null),a([u({type:[x],json:{write:!0}})],C.prototype,"renderingRules",void 0),a([O("renderingRules")],C.prototype,"writeRenderingRules",null),a([u({type:X,json:{write:!0}})],C.prototype,"pixelSize",void 0),a([O("pixelSize")],C.prototype,"writePixelSize",null),a([u({type:Boolean,json:{write:!0}})],C.prototype,"returnGeometry",void 0),a([u({type:Boolean,json:{write:!0}})],C.prototype,"returnCatalogItems",void 0),a([u({type:Boolean,json:{write:!0}})],C.prototype,"returnPixelValues",void 0),a([u({type:Number,json:{write:!0}})],C.prototype,"maxItemCount",void 0),a([u({type:je,json:{write:{target:"time"}}})],C.prototype,"timeExtent",void 0),a([O("timeExtent")],C.prototype,"writeTimeExtent",null),a([u({json:{write:!0}})],C.prototype,"raster",void 0),a([u({json:{write:!0}})],C.prototype,"viewId",void 0),a([u({type:Boolean,json:{write:!0}})],C.prototype,"processAsMultidimensional",void 0),C=Pe=a([J("esri.rest.support.ImageIdentifyParameters")],C);const Qe=C;var Ce;let oe=Ce=class extends k{constructor(){super(...arguments),this.geometries=null,this.rasterId=null}writeGeometry(s,t,o){t.geometries={geometryType:"esriGeometryPoint",geometries:s.map(e=>e.toJSON())}}clone(){var s;return new Ce({geometries:((s=this.geometries)==null?void 0:s.map(t=>t.clone()))??[],rasterId:this.rasterId})}};a([u({type:[X],json:{write:!0}})],oe.prototype,"geometries",void 0),a([O("geometries")],oe.prototype,"writeGeometry",null),a([u({type:le,json:{write:!0}})],oe.prototype,"rasterId",void 0),oe=Ce=a([J("esri.rest.support.ImagePixelLocationParameters")],oe);const Ci=oe;var _e;let A=_e=class extends k{constructor(){super(...arguments),this.geometry=null,this.interpolation="nearest",this.mosaicRule=null,this.outFields=null,this.pixelSize=null,this.returnFirstValueOnly=!0,this.sampleDistance=null,this.sampleCount=null,this.sliceId=null,this.timeExtent=null}writeGeometry(s,t,o){s!=null&&(t.geometryType=Me(s),t[o]=s.toJSON())}set locations(s){if(s!=null&&s.length){const t=new Qt({spatialReference:s[0].spatialReference});t.points=s.map(o=>[o.x,o.y]),this._set("locations",s),this.geometry=t}}clone(){return new _e($({geometry:this.geometry,locations:this.locations,interpolation:this.interpolation,mosaicRule:this.mosaicRule,outFields:this.outFields,raster:this.raster,returnFirstValueOnly:this.returnFirstValueOnly,sampleDistance:this.sampleDistance,sampleCount:this.sampleCount,sliceId:this.sliceId,pixelSize:this.pixelSize,timeExtent:this.timeExtent}))}};a([u({types:Ue,json:{read:Ze}})],A.prototype,"geometry",void 0),a([O("geometry")],A.prototype,"writeGeometry",null),a([u()],A.prototype,"locations",null),a([u({type:String,json:{type:Y.jsonValues,read:Y.read,write:Y.write}})],A.prototype,"interpolation",void 0),a([u({type:z,json:{write:!0}})],A.prototype,"mosaicRule",void 0),a([u({type:[String],json:{write:!0}})],A.prototype,"outFields",void 0),a([u({type:X,json:{write:!0}})],A.prototype,"pixelSize",void 0),a([u({type:String,json:{write:!0}})],A.prototype,"raster",void 0),a([u({type:Boolean,json:{write:!0}})],A.prototype,"returnFirstValueOnly",void 0),a([u({type:Number,json:{write:!0}})],A.prototype,"sampleDistance",void 0),a([u({type:Number,json:{write:!0}})],A.prototype,"sampleCount",void 0),a([u({type:Number,json:{write:!0}})],A.prototype,"sliceId",void 0),a([u({type:je,json:{read:{source:"time"},write:{target:"time"}}})],A.prototype,"timeExtent",void 0),A=_e=a([J("esri.rest.support.ImageSampleParameters")],A);const _i=A,xe=Oe()({U1:"u1",U2:"u2",U4:"u4",U8:"u8",S8:"s8",U16:"u16",S16:"s16",U32:"u32",S32:"s32",F32:"f32",F64:"f64",C64:"c64",C128:"c128",UNKNOWN:"unknown"}),Oi=new Set(["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff"]),Vi=at(ct,{min:0,max:255});function ji(s){var o;if(!s)return null;const t=(o=JSON.stringify(s).match(/"rasterFunction":"(.*?")/gi))==null?void 0:o.map(e=>e.replace('"rasterFunction":"',"").replace('"',""));return t?t.join("/"):null}const Mi=s=>{let t=class extends s{constructor(){super(...arguments),this._functionRasterInfos={},this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this._cachedRendererJson=null,this._serviceSupportsMosaicRule=null,this._rasterAttributeTableFieldPrefix="Raster.",this.adjustAspectRatio=null,this.bandIds=void 0,this.capabilities=null,this.compressionQuality=void 0,this.compressionTolerance=.01,this.copyright=null,this.defaultMosaicRule=null,this.definitionExpression=null,this.exportImageServiceParameters=null,this.rasterInfo=null,this.fields=null,this.fullExtent=null,this.hasMultidimensions=!1,this.imageMaxHeight=4100,this.imageMaxWidth=4100,this.interpolation=void 0,this.minScale=0,this.maxScale=0,this.multidimensionalSubset=null,this.noData=null,this.noDataInterpretation=void 0,this.objectIdField=null,this.geometryType="polygon",this.typeIdField=null,this.types=[],this.pixelFilter=null,this.raster=void 0,this.sourceType=null,this.viewId=void 0,this.symbolizer=null,this.rasterFunctionInfos=null,this.serviceDataType=null,this.spatialReference=null,this.pixelType=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.url=null,this.version=void 0}initialize(){this._set("exportImageServiceParameters",new P({layer:this}))}readServiceSupportsMosaicRule(e,i){return this._isMosaicRuleSupported(i)}get _rasterFunctionNamesIndex(){const e=new Map;return!this.rasterFunctionInfos||F(this.rasterFunctionInfos)&&this.rasterFunctionInfos.length<1||F(this.rasterFunctionInfos)&&this.rasterFunctionInfos.forEach(i=>{e.set(i.name.toLowerCase().replace(/ /gi,"_"),i.name)}),e}readBandIds(e,i){if(Array.isArray(e)&&e.length>0&&e.every(r=>typeof r=="number"))return e}readCapabilities(e,i){return this._readCapabilities(i)}writeCompressionQuality(e,i,r){e!=null&&this.format!=="lerc"&&(i[r]=e)}writeCompressionTolerance(e,i,r){this.format==="lerc"&&e!=null&&(i[r]=e)}readDefaultMosaicRule(e,i){return this._serviceSupportsMosaicRule?z.fromJSON(i):null}get fieldsIndex(){return this.fields?new qt(this.fields):null}set format(e){e&&Oi.has(e.toLowerCase())&&this._set("format",e.toLowerCase())}readFormat(e,i){return i.serviceDataType==="esriImageServiceDataTypeVector-UV"||i.serviceDataType==="esriImageServiceDataTypeVector-MagDir"||this.pixelFilter!=null?"lerc":"jpgpng"}readMinScale(e,i){return i.minLOD!=null&&i.maxLOD!=null?e:0}readMaxScale(e,i){return i.minLOD!=null&&i.maxLOD!=null?e:0}set mosaicRule(e){let i=e;i&&i.mosaicMethod&&(i=z.fromJSON({...i.toJSON(),mosaicMethod:i.mosaicMethod,mosaicOperation:i.mosaicOperation})),this._set("mosaicRule",i)}readMosaicRule(e,i){const r=e||i.mosaicRule;return r?z.fromJSON(r):this._isMosaicRuleSupported(i)?z.fromJSON(i):null}writeMosaicRule(e,i,r){let n=this.mosaicRule;const l=this.definitionExpression;n?l&&l!==n.where&&(n=n.clone(),n.where=l):l&&(n=new z({where:l})),this._isValidCustomizedMosaicRule(n)&&(i[r]=n.toJSON())}get multidimensionalInfo(){return F(this.serviceRasterInfo)?this.serviceRasterInfo.multidimensionalInfo:null}writeNoData(e,i,r){e!=null&&typeof e=="number"&&(i[r]=Vi(e))}readObjectIdField(e,i){if(!e){const r=i.fields.filter(n=>n.type==="esriFieldTypeOID"||n.type==="oid");e=r&&r[0]&&r[0].name}return e}get parsedUrl(){return Ft(this.url)}readSourceType(e,i){return this._isMosaicDataset(i)?"mosaic-dataset":"raster-dataset"}set renderer(e){this.loaded&&(e=this._configRenderer(e)),this._set("renderer",e)}readRenderer(e,i,r){var p,m;const n=(m=(p=i==null?void 0:i.layerDefinition)==null?void 0:p.drawingInfo)==null?void 0:m.renderer,l=gt(n,r);return l==null?null:(l.type==="vector-field"&&i.symbolTileSize&&!n.symbolTileSize&&(l.symbolTileSize=i.symbolTileSize),Xe(l)||Le.getLogger(this.declaredClass).warn("ArcGISImageService","Imagery layer doesn't support given renderer type."),l)}writeRenderer(e,i,r){i.layerDefinition=i.layerDefinition||{},i.layerDefinition.drawingInfo=i.layerDefinition.drawingInfo||{},i.layerDefinition.drawingInfo.renderer=e.toJSON(),e.type==="vector-field"&&(i.symbolTileSize=e.symbolTileSize)}get rasterFields(){var m;const e=this._rasterAttributeTableFieldPrefix||"Raster.",i=new re({name:"Raster.ItemPixelValue",alias:"Item Pixel Value",domain:null,editable:!1,length:50,type:"string"}),r=new re({name:"Raster.ServicePixelValue",alias:"Service Pixel Value",domain:null,editable:!1,length:50,type:"string"}),n=new re({name:"Raster.ServicePixelValue.Raw",alias:"Raw Service Pixel Value",domain:null,editable:!1,length:50,type:"string"});let l=this.fields?$(this.fields):[];l.push(r),(m=this.capabilities)!=null&&m.operations.supportsQuery&&this.fields&&this.fields.length>0&&l.push(i),this.version>=10.4&&F(this.rasterFunctionInfos)&&this.rasterFunctionInfos.some(c=>c.name.toLowerCase()==="none")&&l.push(n),F(this.rasterFunctionInfos)&&this.rasterFunctionInfos.filter(c=>c.name.toLowerCase()!=="none").forEach(c=>{l.push(new re({name:"Raster.ServicePixelValue."+c.name,alias:c.name,domain:null,editable:!1,length:50,type:"string"}))}),this._isVectorDataSet()&&(l.push(new re({name:"Raster.Magnitude",alias:"Magnitude",domain:null,editable:!1,type:"double"})),l.push(new re({name:"Raster.Direction",alias:"Direction",domain:null,editable:!1,type:"double"})));const{attributeTable:p}=this.rasterInfo??{};if(F(p)){const c=p.fields.filter(d=>d.type!=="esriFieldTypeOID"&&d.name.toLowerCase()!=="value").map(d=>{const h=$(d);return h.name=e+d.name,h});l=l.concat(c)}return l}set renderingRule(e){let i=e;i&&i.rasterFunction&&(i=x.fromJSON({...i.toJSON(),rasterFunction:i.rasterFunction,rasterFunctionArguments:i.rasterFunctionArguments})),this._set("renderingRule",i)}readRenderingRule(e,i){const r=i.rasterFunctionInfos;return i.renderingRule||r&&r.length&&r[0].name!=="None"?this._isRFTJson(i.renderingRule)?x.fromJSON({rasterFunctionDefinition:i.renderingRule}):x.fromJSON(i.renderingRule||{rasterFunctionInfos:i.rasterFunctionInfos}):null}writeRenderingRule(e,i,r){const n=e.toJSON();n.rasterFunctionDefinition?i[r]=n.rasterFunctionDefinition:i[r]=n}readSpatialReference(e,i){const r=e||i.extent.spatialReference;return r?ne.fromJSON(r):null}readPixelType(e){return xe.fromJSON(e)||e}writePixelType(e,i,r){(L(this.serviceRasterInfo)||this.pixelType!==this.serviceRasterInfo.pixelType)&&(i[r]=xe.toJSON(e))}readVersion(e,i){let r=i.currentVersion;return r||(r=i.hasOwnProperty("fields")||i.hasOwnProperty("timeInfo")?10:9.3),r}applyFilter(e){let i=e;return this.pixelFilter&&(i=this._clonePixelData(e),this.pixelFilter(i)),i}async applyRenderer(e,i){let r=e;const{renderer:n,symbolizer:l,pixelFilter:p,bandIds:m}=this;if(!this._isPicture()&&n&&l&&!p){const c=JSON.stringify(this._cachedRendererJson)!==JSON.stringify(n.toJSON()),d=this._rasterJobHandler.instance;if(d){c&&(l.bind(),await d.updateSymbolizer(l,i),this._cachedRendererJson=n.toJSON());const h=await d.symbolize({bandIds:m,...e},i);r={extent:e.extent,pixelBlock:h}}else r={extent:e.extent,pixelBlock:l.symbolize({bandIds:m,...e})}}return r}destroy(){this._shutdownJobHandler()}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}async computeAngles(e,i){if(!(await this._fetchCapabilities(i==null?void 0:i.signal)).operations.supportsComputeAngles)throw new E("imagery-layer:compute-angles","this operation is not supported on the input image service");return e=ie(Pi,e).clone(),xi(this.url,e,this._getRequestOptions(i))}async computePixelSpaceLocations(e,i){if(!(await this._fetchCapabilities(i==null?void 0:i.signal)).operations.supportsComputePixelLocation)throw new E("imagery-layer:compute-pixel-space-locations","this operation is not supported on the input image service");return e=ie(Ci,e).clone(),Ii(this.url,e,this._getRequestOptions(i))}async computeHistograms(e,i){if(!(await this._fetchCapabilities(i==null?void 0:i.signal)).operations.supportsComputeHistograms)throw new E("imagery-layer:compute-histograms","this operation is not supported on the input image service");e=ie(He,e).clone();const{raster:r,mosaicRule:n,renderingRule:l}=this;return l&&e.renderingRule==null&&(e.renderingRule=l),n&&e.mosaicRule==null&&(e.mosaicRule=n),r&&e.raster==null&&(e.raster=r),Ti(this.url,e,this._getRequestOptions(i))}async computeStatisticsHistograms(e,i){if(!(await this._fetchCapabilities(i==null?void 0:i.signal)).operations.supportsComputeStatisticsHistograms)throw new E("imagery-layer:compute-statistics-histograms","this operation is not supported on the input image service");e=ie(He,e).clone();const{raster:r,mosaicRule:n,renderingRule:l}=this;return l&&e.renderingRule==null&&(e.renderingRule=l),n&&e.mosaicRule==null&&(e.mosaicRule=n),r&&e.raster==null&&(e.raster=r),Fi(this.url,e,this._getRequestOptions(i))}getField(e){const{fieldsIndex:i}=this;return F(i)?i.get(e):void 0}getFieldDomain(e,i){const r=this.getField(e);return r?r.domain:null}async fetchImage(e,i,r,n={}){var m,c,d;if(e==null||i==null||r==null)throw new E("imagery-layer:fetch-image","Insufficient parameters for requesting an image. A valid extent, width and height values are required.");if(this.renderer||this.symbolizer){const h=await this.generateRasterInfo(this.renderingRule,{signal:n.signal});h&&(this.rasterInfo=h)}const l=this.getExportImageServiceParameters(e,i,r,n.timeExtent);if(l==null){if(n.requestAsImageElement&&this._canRequestImageElement(this.format)){const f=document.createElement("canvas");return f.width=i,f.height=r,{imageOrCanvasElement:f}}const h=(((m=this.bandIds)==null?void 0:m.length)||((c=this.rasterInfo)==null?void 0:c.bandCount))??0,R=i*r,g=((d=this.rasterInfo)==null?void 0:d.pixelType)??"unknown",y=[];for(let f=0;f<h;f++)y.push(be.createEmptyBand(g,R));return{pixelData:{pixelBlock:new be({width:i,height:r,pixels:y,mask:new Uint8Array(R),pixelType:g}),extent:e}}}const p={imageServiceParameters:l,imageProps:{extent:e,width:i,height:r,format:this.format},requestAsImageElement:n.requestAsImageElement&&!this.pixelFilter||!1,signal:n.signal};return this._requestArrayBuffer(p)}fetchKeyProperties(e){return _(o(this.parsedUrl)+"/keyProperties",{query:this._getQueryParams({renderingRule:this.version>=10.3?e==null?void 0:e.renderingRule:null})}).then(i=>i.data)}fetchRasterAttributeTable(e){return this.version<10.1?Promise.reject(new E("#fetchRasterAttributeTable()","Failed to get rasterAttributeTable")):_(o(this.parsedUrl)+"/rasterAttributeTable",{query:this._getQueryParams({renderingRule:this.version>=10.3?e==null?void 0:e.renderingRule:null})}).then(i=>Ke.fromJSON(i.data))}getCatalogItemRasterInfo(e,i){const r={...i,query:this._getQueryParams()};return Ni(o(this.parsedUrl),e,r)}async getCatalogItemICSInfo(e,i){var $e,Je,Ee;const{data:r}=await _(o(this.parsedUrl)+"/"+e+"/info/ics",{query:this._getQueryParams(),...i}),n=r&&r.ics;if(!n)return;let l=null;try{l=(await _(o(this.parsedUrl)+"/"+e+"/info",{query:this._getQueryParams(),...i})).data.extent}catch{}if(!l||!l.spatialReference)return{ics:n,icsToPixelTransform:null,icsExtent:null,northDirection:null};const p=this.version>=10.7?_(o(this.parsedUrl)+"/"+e+"/info/icstopixel",{query:this._getQueryParams(),...i}).then(S=>S.data).catch(()=>({})):{},m=l.spatialReference,c={geometries:JSON.stringify({geometryType:"esriGeometryEnvelope",geometries:[l]}),inSR:m.wkid||JSON.stringify(m),outSR:"0:"+e},d=_(o(this.parsedUrl)+"/project",{query:this._getQueryParams(c),...i}).then(S=>S.data).catch(()=>({})),h=5,R=(l.xmin+l.xmax)/2,g=(l.ymax-l.ymin)/(h+1),y=l.ymin+g,f=[];for(let S=0;S<h;S++)f.push({x:R,y:y+g*S});const T={geometries:JSON.stringify({geometryType:"esriGeometryPoint",geometries:f}),inSR:m.wkid||JSON.stringify(m),outSR:"0:"+e},V=_(o(this.parsedUrl)+"/project",{query:this._getQueryParams(T),...i}).then(S=>S.data).catch(()=>({})),w=await Promise.all([p,d,V]);let v=w[0].ipxf;if(v==null){const S=($e=n.geodataXform)==null?void 0:$e.xf_0;((Je=S==null?void 0:S.name)==null?void 0:Je.toLowerCase())==="topup"&&((Ee=S==null?void 0:S.coefficients)==null?void 0:Ee.length)===6&&(v={affine:{name:"ics [sensor: Frame] to pixel (column, row) transformation",coefficients:S.coefficients,cellsizeRatio:0,type:"GeometricXform"}})}const I=fe.fromJSON(w[1]&&w[1].geometries&&w[1].geometries[0]);I&&(I.spatialReference=new ne({wkid:0,imageCoordinateSystem:n}));const b=w[2].geometries?w[2].geometries.filter(S=>S!=null&&S.x!=null&&S.y!=null&&S.x!=="NaN"&&S.y!=="NaN"):[],D=b.length;if(D<3)return{ics:n,icsToPixelTransform:v,icsExtent:I,northDirection:null};let N=0,Q=0,ce=0,ye=0;for(let S=0;S<D;S++)N+=b[S].x,Q+=b[S].y,ce+=b[S].x*b[S].x,ye+=b[S].x*b[S].y;const U=(D*ye-N*Q)/(D*ce-N*N);let G=0;const te=b[h-1].x>b[0].x,K=b[h-1].y>b[0].y;return U===1/0?G=K?90:270:U===0?G=te?0:180:U>0?G=te?180*Math.atan(U)/Math.PI:180*Math.atan(U)/Math.PI+180:U<0&&(G=K?180+180*Math.atan(U)/Math.PI:360+180*Math.atan(U)/Math.PI),{ics:n,icsToPixelTransform:v,icsExtent:I,northDirection:G}}async generateRasterInfo(e,i){var l;if(this.serviceRasterInfo&&(!e||((l=e.functionName)==null?void 0:l.toLowerCase())==="none"||this._isVectorFieldResampleFunction(e)))return this.serviceRasterInfo;const r=ji(e);if(!r)return null;if(this._functionRasterInfos[r])return this._functionRasterInfos[r];const n=this._generateRasterInfo(e,i);this._functionRasterInfos[r]=n;try{return await n}catch{return this._functionRasterInfos[r]=null,null}}getExportImageServiceParameters(e,i,r,n){var T,V;e=e.clone().shiftCentralMeridian();const l=st(e.spatialReference,o(this.parsedUrl));this.pixelType!==((T=this.serviceRasterInfo)==null?void 0:T.pixelType)&&(this.exportImageServiceParameters.pixelType=this.pixelType);const p=this.exportImageServiceParameters.toJSON(),{bandIds:m,noData:c}=p;let{renderingRule:d}=p;const h=(V=this.renderingRule)==null?void 0:V.rasterFunctionDefinition,R=!this.renderer||this.renderer.type==="raster-stretch";if(m!=null&&m.length&&this._hasRenderingRule(this.renderingRule)&&!h&&R){const w={rasterFunction:"ExtractBand",rasterFunctionArguments:{BandIds:m}};if(d.rasterFunction==="Stretch")w.rasterFunctionArguments.Raster=d.rasterFunctionArguments.Raster,d.rasterFunctionArguments.Raster=w;else if(d.rasterFunction==="Colormap"){const v=d.rasterFunctionArguments.Raster;(v==null?void 0:v.rasterFunction)==="Stretch"?(w.rasterFunctionArguments.Raster=v.rasterFunctionArguments.Raster,v.rasterFunctionArguments.Raster=w):(w.rasterFunctionArguments.Raster=v,d.rasterFunctionArguments.Raster=w)}else w.rasterFunctionArguments.Raster=d,d=w;p.bandIds=void 0}else p.bandIds=m==null?void 0:m.join(",");c instanceof Array&&c.length>0&&(p.noData=c.join(","));const g=this._serviceSupportsMosaicRule?this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,n):null;p.mosaicRule=F(g)?JSON.stringify(g):null;const{multidimensionalSubset:y}=this;if(y&&F(g)&&g.multidimensionalDefinition&&qe(g.multidimensionalDefinition,y,!0))return null;p.renderingRule=this._getRenderingRuleString(x.fromJSON(d));const f={};if(n){const{start:w,end:v}=n.toJSON();let I;if(w&&v&&w===v?(f.time=""+w,I=[w]):w==null&&v==null||(f.time=`${w??"null"},${v??"null"}`,I=w!=null&&v!=null?[w,v]:[w??v]),I&&y){const b=y.dimensions.find(({name:N})=>N==="StdTime");if(I.length===2&&b.extent.length){if(I[0]=Math.max(I[0],b.extent[0]),I[1]=Math.min(I[1],b.extent[1]??b.extent[0]),I[1]<I[0])return null;f.time=I.join()}const D=new Ie({variableName:"",dimensionName:"StdTime",isSlice:I.length===1,values:I});if(qe([D],y,!0))return null}}return{bbox:e.xmin+","+e.ymin+","+e.xmax+","+e.ymax,bboxSR:l,imageSR:l,size:i+","+r,...p,...f}}async getSamples(e,i){var n;if(!((n=await this._fetchCapabilities(i==null?void 0:i.signal))!=null&&n.operations.supportsGetSamples))throw new E("imagery-layer:get-samples","getSamples operation is not supported on the input image service");e=ie(_i,e).clone();const{raster:r}=this;return r&&e.raster==null&&(e.raster=r),Di(this.url,e,this._getRequestOptions(i))}async identify(e,i){if(!(await this._fetchCapabilities(i==null?void 0:i.signal)).operations.supportsIdentify)throw new E("imagery-layer:query-rasters","query operation is not supported on the input image service");e=ie(Qe,e).clone();const{raster:r,mosaicRule:n,renderingRule:l}=this;if(l&&e.renderingRule==null&&(e.renderingRule=l),n&&e.mosaicRule==null){const p=this._combineMosaicRuleWithTimeExtent(n,e.timeExtent);e.mosaicRule=lt(p)}return r&&e.raster==null&&(e.raster=r),ke(this.url,e,this._getRequestOptions(i))}createQuery(){const e=new we;return e.outFields=["*"],e.returnGeometry=!0,e.where=this.definitionExpression||"1=1",e}async queryRasters(e,i){return{query:e,requestOptions:i}=await this._prepareForQuery(e,i),Ht(this.url,e,i)}async queryObjectIds(e,i){return{query:e,requestOptions:i}=await this._prepareForQuery(e,i),Gt(this.url,e,i)}async queryRasterCount(e,i){return{query:e,requestOptions:i}=await this._prepareForQuery(e,i),Bt(this.url,e,i)}async queryVisibleRasters(e,i){var w,v,I;if(!e)throw new E("imagery-layer: query-visible-rasters","missing query parameter");await this.load();const{pixelSize:r,returnDomainValues:n,returnTopmostRaster:l,showNoDataRecords:p}=i||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1};let m=!1,c=null,d=null;const h="raster.servicepixelvalue",R=this._rasterFunctionNamesIndex;if(F(e.outFields)&&(m=e.outFields.some(b=>!b.toLowerCase().includes(h)),this.version>=10.4)){const b=e.outFields.filter(N=>N.toLowerCase().includes(h)&&N.length>h.length).map(N=>{const Q=N.slice(h.length+1);return[this._updateRenderingRulesFunctionName(Q,R),Q]});c=b.map(N=>new x({functionName:N[0]})),d=b.map(N=>N[1]);const{renderingRule:D}=this;c.length===0?D!=null&&D.functionName?(c.push(D),d.push(D.functionName)):c=null:D!=null&&D.functionName&&!c.some(N=>N.functionName===D.functionName)&&(c.push(D),d.push(D.functionName))}const g=L(e.outSpatialReference)||e.outSpatialReference.equals(this.spatialReference),y=e.timeExtent||this.timeExtent,f=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,y),T=this._getQueryParams({geometry:e.geometry,timeExtent:y,mosaicRule:f,renderingRule:this.version<10.4?this.renderingRule:null,renderingRules:c,pixelSize:r,returnCatalogItems:m,returnGeometry:g,raster:this.raster,maxItemCount:l?1:null});delete T.f;const V=new Qe(T);try{await this.generateRasterInfo(this.renderingRule);const b=await ke(this.url,V,{signal:i==null?void 0:i.signal,query:{...this.customParameters}}),D=e.outFields,N=b.value!=null&&b.value.toLowerCase().includes("nodata");if(!(m&&!g&&((w=b==null?void 0:b.catalogItems)!=null&&w.features.length)&&(p||!N)))return this._processVisibleRastersResponse(b,{returnDomainValues:n,templateRRFunctionNames:d,showNoDataRecords:p,templateFields:D});const Q=this.objectIdField||"ObjectId",ce=((v=b.catalogItems)==null?void 0:v.features)??[],ye=ce.map(te=>{var K;return(K=te.attributes)==null?void 0:K[Q]}),U=new we({objectIds:ye,returnGeometry:!0,outSpatialReference:e.outSpatialReference,outFields:[Q]}),G=await this.queryRasters(U);return(I=G==null?void 0:G.features)!=null&&I.length&&G.features.forEach(te=>{ce.forEach(K=>{K.attributes[Q]===te.attributes[Q]&&(K.geometry=new Ut(te.geometry),F(e.outSpatialReference)&&(K.geometry.spatialReference=e.outSpatialReference))})}),this._processVisibleRastersResponse(b,{returnDomainValues:n,templateRRFunctionNames:d,showNoDataRecords:p,templateFields:D})}catch{throw new E("imagery-layer:query-visible-rasters","encountered error when querying visible rasters")}}async fetchVariableStatisticsHistograms(e,i){const r=_(o(this.parsedUrl)+"/statistics",{query:this._getQueryParams({variable:e}),signal:i}).then(p=>{var m;return(m=p.data)==null?void 0:m.statistics}),n=_(o(this.parsedUrl)+"/histograms",{query:this._getQueryParams({variable:e}),signal:i}).then(p=>{var m;return(m=p.data)==null?void 0:m.histograms}),l=await Promise.all([r,n]);return l[0]&&l[0].forEach(p=>{p.avg=p.mean,p.stddev=p.standardDeviation}),{statistics:l[0]||null,histograms:l[1]||null}}async createFlowMesh(e,i){const r=this._rasterJobHandler.instance;return r?r.createFlowMesh(e,i):zt(e.meshType,e.simulationSettings,e.flowData,F(i.signal)?i.signal:new AbortController().signal)}getMultidimensionalSubsetVariables(e){const i=e??this.multidimensionalInfo;return Ot(this.multidimensionalSubset,i)}async _fetchService(e){await this._fetchServiceInfo(e),this.rasterInfo||(this.rasterInfo=this.serviceRasterInfo);const i=this.sourceJSON,r=F(this.serviceRasterInfo)?Promise.resolve(this.serviceRasterInfo):Rt(o(this.parsedUrl),i,{signal:e,query:this._getQueryParams()}).then(p=>(this._set("serviceRasterInfo",p),p)),n=this._hasRenderingRule(this.renderingRule)?this.generateRasterInfo(this.renderingRule,{signal:e}):null,l=this._getRasterFunctionInfos();return Promise.all([r,n,l]).then(p=>{p[1]?this._set("rasterInfo",p[1]):this._set("rasterInfo",p[0]),p[2]&&this._set("rasterFunctionInfos",p[2]),this.renderer&&!this._isSupportedRenderer(this.renderer)&&(this._set("renderer",null),Le.getLogger(this.declaredClass).warn("ArcGISImageService","Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")),this._set("renderer",this._configRenderer(this.renderer)),this.addHandles([Tt(()=>this.renderingRule,c=>{(this.renderer||this.symbolizer||this.popupEnabled&&this.popupTemplate)&&this.generateRasterInfo(c).then(d=>{d&&(this.rasterInfo=d)})})]);const{serviceRasterInfo:m}=this;m&&F(m.multidimensionalInfo)&&this._updateMultidimensionalDefinition(m)})}_combineMosaicRuleWithTimeExtent(e,i){var g;const r=this.timeInfo;if(L(e)||L(this.multidimensionalInfo)||L(i)||L(r==null?void 0:r.startField))return e;const{startField:n}=r,l=this.multidimensionalInfo.variables.some(y=>y.dimensions.some(f=>f.name===n))?n:"StdTime";if(e=e.clone(),this.sourceType==="mosaic-dataset")return e.multidimensionalDefinition=(g=e.multidimensionalDefinition)==null?void 0:g.filter(y=>y.dimensionName!==l),this._cleanupMultidimensionalDefinition(e);e.multidimensionalDefinition=e.multidimensionalDefinition||[];const p=e.multidimensionalDefinition.filter(y=>y.dimensionName===l),m=F(i.start)?i.start.getTime():null,c=F(i.end)?i.end.getTime():null,d=m==null||c==null||m===c,h=d?[m||c]:[[m,c]],R=this.version>=10.8;if(p.length)p.forEach(y=>{y.dimensionName===l&&(R?(y.dimensionName=null,y.isSlice=!1,y.values=[]):(y.isSlice=d,y.values=h))});else if(!R){const y=e.multidimensionalDefinition.filter(f=>f.variableName!=null&&f.dimensionName==null);y.length?y.forEach(f=>{f.dimensionName=l,f.isSlice=d,f.values=h}):e.multidimensionalDefinition.push(new Ie({variableName:"",dimensionName:l,isSlice:d,values:h}))}return this._cleanupMultidimensionalDefinition(e)}_cleanupMultidimensionalDefinition(e){return L(e)?null:(e.multidimensionalDefinition&&(e.multidimensionalDefinition=e.multidimensionalDefinition.filter(i=>!(!i.variableName&&!i.dimensionName)),e.multidimensionalDefinition.length===0&&(e.multidimensionalDefinition=null)),this.sourceType!=="mosaic-dataset"&&e.multidimensionalDefinition==null?null:e)}async _prepareForQuery(e,i){if(!(await this._fetchCapabilities(i==null?void 0:i.signal)).operations.supportsQuery)throw new E("imagery-layer:query-rasters","query operation is not supported on the input image service");return e=F(e)?ie(we,e):this.createQuery(),i=this._getRequestOptions(i),this.raster&&(i.query={...i.query,raster:this.raster}),{query:e,requestOptions:i}}async _initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;const e=new It;this._rasterJobHandler.connectionPromise=e.initialize().then(()=>{this._rasterJobHandler.instance=e},()=>{}),await this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null}_isSupportedRenderer(e){const{rasterInfo:i,renderingRule:r}=this;return e.type==="unique-value"&&this._hasRenderingRule(r)&&(i==null?void 0:i.bandCount)===1&&["u8","s8"].includes(i.pixelType)||i!=null&&e!=null&&vt(i).includes(e.type)}async _fetchCapabilities(e){return this.capabilities||await this._fetchServiceInfo(e),this.capabilities}async _fetchServiceInfo(e){var r;let i=this.sourceJSON;if(!i){const{data:n,ssl:l}=await _(o(this.parsedUrl),{query:this._getQueryParams(),signal:e});i=n,this.sourceJSON=i,l&&(this.url=this.url.replace(/^http:/i,"https:"))}if(((r=i.capabilities)==null?void 0:r.toLowerCase().split(",").map(n=>n.trim()).indexOf("tilesonly"))>-1)throw new E("imagery-layer:fetch-service-info","use ImageryTileLayer to open tiles-only image services");this.read(i,{origin:"service",url:this.parsedUrl})}_isMosaicDataset(e){var i;return e.serviceSourceType?e.serviceSourceType==="esriImageServiceSourceTypeMosaicDataset":((i=e.fields)==null?void 0:i.length)>0}_isMosaicRuleSupported(e){var n;if(!e)return!1;const i=this._isMosaicDataset(e),r=e.currentVersion>=10.71&&e.hasMultidimensions&&!(((n=e.fields)==null?void 0:n.length)>1);return i||r}_isVectorFieldResampleFunction(e){if(L(e))return!1;const{functionName:i,functionArguments:r}=e,n=(i==null?void 0:i.toLowerCase())==="resample",l=(r==null?void 0:r.ResampleType)||(r==null?void 0:r.resampleType);return n&&(l===7||l===10)}_isPicture(){return!this.format||this.format.includes("jpg")||this.format.includes("png")}_configRenderer(e){var i,r;if(!this._isPicture()&&!this.pixelFilter||this._isVectorDataSet()){if(!this.bandIds&&this.rasterInfo&&this.rasterInfo.bandCount>=3){const l=bt(this.rasterInfo);!l||this.rasterInfo.bandCount===3&&l[0]===0&&l[1]===1&&l[2]===2||(this.bandIds=l)}e||(e=wt(this.rasterInfo,{bandIds:this.bandIds,variableName:this.renderingRule?null:(r=(i=this.mosaicRule)==null?void 0:i.multidimensionalDefinition)==null?void 0:r[0].variableName}));const n=St(e.toJSON());this.symbolizer?(this.symbolizer.rendererJSON=n,this.symbolizer.rasterInfo=this.rasterInfo):this.symbolizer=new Jt({rendererJSON:n,rasterInfo:this.rasterInfo}),this.symbolizer.bind().success||(this.symbolizer=null)}return e}_clonePixelData(e){return e==null?e:{extent:e.extent&&e.extent.clone(),pixelBlock:F(e.pixelBlock)?e.pixelBlock.clone():null}}_getQueryParams(e){e&&F(e.renderingRule)&&typeof e.renderingRule!="string"&&(e.renderingRule=this._getRenderingRuleString(e.renderingRule));const{raster:i,viewId:r}=this;return{raster:i,viewId:r,f:"json",...e,...this.customParameters}}_getRequestOptions(e){return{...e,query:{...e==null?void 0:e.query,...this.customParameters}}}_decodePixelBlock(e,i,r){return this._rasterJobHandler.instance?this._rasterJobHandler.instance.decode({data:e,options:i}):ze(e,i,r)}async _getRasterFunctionInfos(e){var r;const i=this.sourceJSON.rasterFunctionInfos;return this.loaded?i:i&&this.version>=10.3?i.length===1&&i[0].name.toLowerCase()==="none"?i:(r=(await _(o(this.parsedUrl)+"/rasterFunctionInfos",{query:this._getQueryParams(),signal:e})).data)==null?void 0:r.rasterFunctionInfos:null}_canRequestImageElement(e){return!this.pixelFilter&&(!e||e.includes("png"))}async _requestArrayBuffer(e){const{imageProps:i,requestAsImageElement:r,signal:n}=e;if(r&&this._canRequestImageElement(i.format))return{imageOrCanvasElement:(await _(o(this.parsedUrl)+"/exportImage",{responseType:"image",query:this._getQueryParams({f:"image",...this.refreshParameters,...e.imageServiceParameters}),signal:n})).data,params:i};const l=this._initJobHandler(),p=_(o(this.parsedUrl)+"/exportImage",{responseType:"array-buffer",query:this._getQueryParams({f:"image",...e.imageServiceParameters}),signal:n}),m=(await Promise.all([p,l]))[0].data,c=i.format||"jpgpng";let d=c;if(d!=="bsq"&&d!=="bip"&&(d=Et(m)),!d)throw new E("imagery-layer:fetch-image","unsupported format signature "+String.fromCharCode.apply(null,new Uint8Array(m)));const h={signal:n};return{pixelData:{pixelBlock:await(c==="gif"||c==="bmp"||c.includes("png")&&(d==="png"||d==="jpg")?ze(m,{useCanvas:!0,...i},h):this._decodePixelBlock(m,{width:i.width,height:i.height,planes:null,pixelType:null,noDataValue:null,format:c},h)),extent:i.extent},params:i}}_generateRasterInfo(e,i){const r={...i,query:this._getQueryParams()};return xt(o(this.parsedUrl),e,r)}_isValidCustomizedMosaicRule(e){var i;return e&&JSON.stringify(e.toJSON())!==JSON.stringify((i=this.defaultMosaicRule)==null?void 0:i.toJSON())}_updateMultidimensionalDefinition(e){var r;if(this._isValidCustomizedMosaicRule(this.mosaicRule))return;const i=Vt(e,{multidimensionalSubset:this.multidimensionalSubset});if(F(i)&&i.length>0){this.mosaicRule=this.mosaicRule||new z;const n=this.mosaicRule.multidimensionalDefinition;!this.sourceJSON.defaultVariableName&&this.renderingRule&&((r=this.renderingRule.functionName)==null?void 0:r.toLowerCase())!=="none"&&i.forEach(l=>l.variableName=""),(!n||n&&n.length<=0)&&(this.mosaicRule.multidimensionalDefinition=i)}}_processVisibleRastersResponse(e,i){var w;i=i||{};const r=e.value,{templateRRFunctionNames:n,showNoDataRecords:l,returnDomainValues:p,templateFields:m}=i,c=e.processedValues;let d=e.catalogItems&&e.catalogItems.features,h=e.properties&&e.properties.Values&&e.properties.Values.map(v=>v.replace(/ /gi,", "))||[];const R=this.objectIdField||"ObjectId",g=typeof r=="string"&&r.toLowerCase().includes("nodata"),y=[];if(r&&!d&&!g){const v={};v[R]=0,h=[r],d=[new dt(this.fullExtent,null,v)]}if(!d)return[];let f,T,V;this._updateResponseFieldNames(d,m),g&&!l&&(d=[]);for(let v=0;v<d.length;v++){if(f=d[v],r!=null){if(T=h[v],V=this.renderingRule&&c&&c.length>0&&n&&n.length>0&&n.includes(this.renderingRule.functionName)?c[n.indexOf(this.renderingRule.functionName)]:r,T.toLowerCase()==="nodata"&&!l)continue;const I="Raster.ItemPixelValue",b="Raster.ServicePixelValue";f.attributes[I]=T,f.attributes[b]=V,this._updateFeatureWithMagDirValues(f,T);const D=this.fields&&this.fields.length>0;let N=this.renderingRule&&F((w=this.serviceRasterInfo)==null?void 0:w.attributeTable)?D?T:r:V;this.renderingRule||(N=D?T:r),this._updateFeatureWithRasterAttributeTableValues(f,N)}if(f.sourceLayer=f.layer=this,p&&this._updateFeatureWithDomainValues(f),n&&c&&n.length===c.length)for(let I=0;I<n.length;I++){const b="Raster.ServicePixelValue."+n[I];f.attributes[b]=c[I]}y.push(d[v])}return y}_updateFeatureWithRasterAttributeTableValues(e,i){var d;const r=this.rasterInfo&&this.rasterInfo.attributeTable||((d=this.serviceRasterInfo)==null?void 0:d.attributeTable);if(L(r))return;const{features:n,fields:l}=r,p=l.map(h=>h.name).filter(h=>h.toLowerCase()==="value"),m=p&&p[0];if(!m)return;const c=n.filter(h=>h.attributes[m]===(i!=null?parseInt(i,10):null));c&&c[0]&&l.forEach(h=>{const R=this._rasterAttributeTableFieldPrefix+h.name;e.attributes[R]=c[0].attributes[h.name]})}_updateFeatureWithMagDirValues(e,i){if(!this._isVectorDataSet())return;const r=i.split(/,\s*/).map(c=>parseFloat(c)),n=r.map(c=>[c]),l=r.map(c=>({minValue:c,maxValue:c,noDataValue:null})),p=new be({height:1,width:1,pixelType:"f32",pixels:n,statistics:l});this.pixelFilter!=null&&this.pixelFilter({pixelBlock:p,extent:new fe(0,0,0,0,this.spatialReference)});const m=this.serviceDataType==="esriImageServiceDataTypeVector-MagDir"?[p.pixels[0][0],p.pixels[1][0]]:kt([p.pixels[0][0],p.pixels[1][0]]);e.attributes["Raster.Magnitude"]=m[0],e.attributes["Raster.Direction"]=m[1]}_updateFeatureWithDomainValues(e){const i=this.fields&&this.fields.filter(r=>r.domain&&r.domain.type==="coded-value");i!=null&&i.forEach(r=>{const n=e.attributes[r.name];if(n!=null){const l=r.domain.codedValues.find(p=>p.code===n);l&&(e.attributes[r.name]=l.name)}})}_updateResponseFieldNames(e,i){if(!i||i.length<1)return;const r=this.fieldsIndex;L(r)||e.forEach(n=>{var l;if(n&&n.attributes)for(const p of i){const m=(l=r.get(p))==null?void 0:l.name;m&&m!==p&&(n.attributes[p]=n.attributes[m],delete n.attributes[m])}})}_getRenderingRuleString(e){if(this._hasRenderingRule(e)){let i=e.toJSON();return i=i.rasterFunctionDefinition??i,(i.thumbnail||i.thumbnailEx)&&(i.thumbnail=i.thumbnailEx=null),JSON.stringify(i)}return null}_hasRenderingRule(e){return e!=null&&e.functionName!=null&&e.functionName.toLowerCase()!=="none"}_updateRenderingRulesFunctionName(e,i){if(!e||e.length<1)return;if(e==="Raw")return e.replace("Raw","None");const r=e.toLowerCase().replace(/ /gi,"_");return i.has(r)?i.get(r):e}_isRFTJson(e){return e&&e.name&&e.arguments&&e.function&&e.hasOwnProperty("functionType")}_isVectorDataSet(){return this.serviceDataType==="esriImageServiceDataTypeVector-UV"||this.serviceDataType==="esriImageServiceDataTypeVector-MagDir"}_readCapabilities(e){const i=e.capabilities?e.capabilities.toLowerCase().split(",").map(h=>h.trim()):["image","catalog"],{currentVersion:r,advancedQueryCapabilities:n,maxRecordCount:l}=e,p=i.includes("image"),m=e.serviceDataType==="esriImageServiceDataTypeElevation",c=!!(e.spatialReference||e.extent&&e.extent.spatialReference),d=i.includes("edit");return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:p,supportsExportImage:p,supportsIdentify:p,supportsMeasure:i.includes("mensuration")&&c,supportsDownload:i.includes("download"),supportsQuery:i.includes("catalog")&&e.fields&&e.fields.length>0,supportsGetSamples:r>=10.2&&p,supportsProject:r>=10.3&&p,supportsComputeStatisticsHistograms:r>=10.4&&p,supportsQueryBoundary:r>=10.6&&p,supportsCalculateVolume:r>=10.7&&m,supportsComputePixelLocation:r>=10.7&&i.includes("catalog"),supportsComputeAngles:r>=10.91,supportsAdd:d,supportsDelete:d,supportsEditing:d,supportsUpdate:d,supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1,supportsQueryAnalytics:!1,supportsQueryTopFeatures:!1},query:{maxRecordCount:l,maxRecordCountFactor:void 0,supportsStatistics:!!(n!=null&&n.supportsStatistics),supportsOrderBy:!!(n!=null&&n.supportsOrderBy),supportsDistinct:!!(n!=null&&n.supportsDistinct),supportsPagination:!!(n!=null&&n.supportsPagination),supportsStandardizedQueriesOnly:!!(n!=null&&n.useStandardizedQueries),supportsPercentileStatistics:!!(n!=null&&n.supportsPercentileStatistics),supportsCentroid:!!(n!=null&&n.supportsReturningGeometryCentroid),supportsDistance:!!(n!=null&&n.supportsQueryWithDistance),supportsExtent:!!(n!=null&&n.supportsReturningQueryExtent),supportsGeometryProperties:!!(n!=null&&n.supportsReturningGeometryProperties),supportsHavingClause:!!(n!=null&&n.supportsHavingClause),supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:!1,supportsTopFeaturesQuery:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsDefaultSpatialReference:!!(n!=null&&n.supportsDefaultSR),supportsFullTextSearch:!1,supportsCompactGeometry:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0}}}};function o(e){return(e==null?void 0:e.path)??""}return a([u()],t.prototype,"_functionRasterInfos",void 0),a([u()],t.prototype,"_rasterJobHandler",void 0),a([u()],t.prototype,"_cachedRendererJson",void 0),a([u({readOnly:!0})],t.prototype,"_serviceSupportsMosaicRule",void 0),a([M("_serviceSupportsMosaicRule",["currentVersion","fields"])],t.prototype,"readServiceSupportsMosaicRule",null),a([u()],t.prototype,"_rasterAttributeTableFieldPrefix",void 0),a([u({readOnly:!0})],t.prototype,"_rasterFunctionNamesIndex",null),a([u()],t.prototype,"adjustAspectRatio",void 0),a([u({type:[le],json:{write:!0}})],t.prototype,"bandIds",void 0),a([M("bandIds")],t.prototype,"readBandIds",null),a([u({readOnly:!0,json:{read:!1}})],t.prototype,"capabilities",void 0),a([M("service","capabilities",["capabilities","currentVersion","serviceDataType"])],t.prototype,"readCapabilities",null),a([u({type:Number})],t.prototype,"compressionQuality",void 0),a([O("compressionQuality")],t.prototype,"writeCompressionQuality",null),a([u({type:Number})],t.prototype,"compressionTolerance",void 0),a([O("compressionTolerance")],t.prototype,"writeCompressionTolerance",null),a([u({json:{read:{source:"copyrightText"}}})],t.prototype,"copyright",void 0),a([u({readOnly:!0,dependsOn:["_serviceSupportsMosaicRule"]})],t.prototype,"defaultMosaicRule",void 0),a([M("defaultMosaicRule",["defaultMosaicMethod"])],t.prototype,"readDefaultMosaicRule",null),a([u({type:String,json:{name:"layerDefinition.definitionExpression",write:{enabled:!0,allowNull:!0}}})],t.prototype,"definitionExpression",void 0),a([u({readOnly:!0,constructOnly:!0})],t.prototype,"exportImageServiceParameters",void 0),a([u()],t.prototype,"rasterInfo",void 0),a([u({readOnly:!0,type:[re]})],t.prototype,"fields",void 0),a([u({readOnly:!0})],t.prototype,"fieldsIndex",null),a([u({type:["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff"],json:{write:!0}})],t.prototype,"format",null),a([M("service","format",["serviceDataType"])],t.prototype,"readFormat",null),a([u({type:fe})],t.prototype,"fullExtent",void 0),a([u({readOnly:!0})],t.prototype,"hasMultidimensions",void 0),a([u({json:{read:{source:"maxImageHeight"}}})],t.prototype,"imageMaxHeight",void 0),a([u({json:{read:{source:"maxImageWidth"}}})],t.prototype,"imageMaxWidth",void 0),a([u({type:String,json:{type:Y.jsonValues,read:Y.read,write:Y.write}})],t.prototype,"interpolation",void 0),a([u()],t.prototype,"minScale",void 0),a([M("service","minScale")],t.prototype,"readMinScale",null),a([u()],t.prototype,"maxScale",void 0),a([M("service","maxScale")],t.prototype,"readMaxScale",null),a([u({type:z})],t.prototype,"mosaicRule",null),a([M("mosaicRule",["mosaicRule","defaultMosaicMethod"])],t.prototype,"readMosaicRule",null),a([O("mosaicRule")],t.prototype,"writeMosaicRule",null),a([u()],t.prototype,"multidimensionalInfo",null),a([u({type:ht,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),a([u({json:{type:le}})],t.prototype,"noData",void 0),a([O("noData")],t.prototype,"writeNoData",null),a([u({type:String,json:{type:de.jsonValues,read:de.read,write:de.write}})],t.prototype,"noDataInterpretation",void 0),a([u({type:String,readOnly:!0,json:{read:{source:["fields"]}}})],t.prototype,"objectIdField",void 0),a([M("objectIdField")],t.prototype,"readObjectIdField",null),a([u({})],t.prototype,"geometryType",void 0),a([u({})],t.prototype,"typeIdField",void 0),a([u({})],t.prototype,"types",void 0),a([u({readOnly:!0})],t.prototype,"parsedUrl",null),a([u({type:Function})],t.prototype,"pixelFilter",void 0),a([u()],t.prototype,"raster",void 0),a([u({readOnly:!0})],t.prototype,"sourceType",void 0),a([M("sourceType",["serviceSourceType","fields"])],t.prototype,"readSourceType",null),a([u()],t.prototype,"viewId",void 0),a([u({types:yt,json:{name:"layerDefinition.drawingInfo.renderer",origins:{"web-scene":{types:ft,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],t.prototype,"renderer",null),a([M("renderer")],t.prototype,"readRenderer",null),a([O("renderer")],t.prototype,"writeRenderer",null),a([u()],t.prototype,"symbolizer",void 0),a([u(Dt)],t.prototype,"opacity",void 0),a([u({readOnly:!0})],t.prototype,"rasterFields",null),a([u({constructOnly:!0})],t.prototype,"rasterFunctionInfos",void 0),a([u({type:x})],t.prototype,"renderingRule",null),a([M("renderingRule",["renderingRule","rasterFunctionInfos"])],t.prototype,"readRenderingRule",null),a([O("renderingRule")],t.prototype,"writeRenderingRule",null),a([u()],t.prototype,"serviceDataType",void 0),a([u({readOnly:!0,type:ne})],t.prototype,"spatialReference",void 0),a([M("spatialReference",["spatialReference","extent"])],t.prototype,"readSpatialReference",null),a([u({json:{type:xe.jsonValues}})],t.prototype,"pixelType",void 0),a([M("pixelType")],t.prototype,"readPixelType",null),a([O("pixelType")],t.prototype,"writePixelType",null),a([u({constructOnly:!0,type:We})],t.prototype,"serviceRasterInfo",void 0),a([u()],t.prototype,"sourceJSON",void 0),a([u(Nt)],t.prototype,"url",void 0),a([u({readOnly:!0})],t.prototype,"version",void 0),a([M("version",["currentVersion","fields","timeInfo"])],t.prototype,"readVersion",null),t=a([J("esri.layers.mixins.ArcGISImageService")],t),t};let q=class extends Kt(ti(ei(Pt(Xt(Mi(Yt(Zt(Wt(ut(mt)))))))))){constructor(...s){super(...s),this.legendEnabled=!0,this.isReference=null,this.operationalLayerType="ArcGISImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.type="imagery"}normalizeCtorArgs(s,t){return typeof s=="string"?{url:s,...t}:s}load(s){const t=F(s)?s.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},s).catch(pt).then(()=>this._fetchService(t))),Promise.resolve(this)}writeOperationalLayerType(s,t,o){var i;const e=((i=this.renderer)==null?void 0:i.type)==="vector-field";t[o]=e?"ArcGISImageServiceVectorLayer":"ArcGISImageServiceLayer"}get defaultPopupTemplate(){return this.createPopupTemplate()}createPopupTemplate(s){const t=this.rasterFields,o=this.title,e=new Set;let i=!1,r=!1;this.capabilities&&(i=this.capabilities.operations.supportsQuery&&this.fields&&this.fields.length>0,r=this.serviceDataType==="esriImageServiceDataTypeVector-UV"||this.serviceDataType==="esriImageServiceDataTypeVector-MagDir");const n=new Set;i&&n.add("raster.itempixelvalue");for(const l of t){const p=l.name.toLowerCase();n.has(p)||p.includes("raster.servicepixelvalue.")||e.add(l.name)}return r&&e.add("raster.magnitude").add("raster.direction"),ri({fields:t,title:o},{...s,visibleFieldNames:e})}queryFeatures(s,t){return this.queryRasters(s,t).then(o=>{if(o!=null&&o.features)for(const e of o.features)e.layer=e.sourceLayer=this;return o})}queryFeatureCount(s,t){return this.queryRasterCount(s,t)}redraw(){this.emit("redraw")}serviceSupportsSpatialReference(s){return ii(this,s)}};a([u(Ct)],q.prototype,"legendEnabled",void 0),a([u({type:["show","hide"]})],q.prototype,"listMode",void 0),a([u({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],q.prototype,"isReference",void 0),a([u({type:["ArcGISImageServiceLayer"],json:{origins:{"web-map":{type:["ArcGISImageServiceLayer","ArcGISImageServiceVectorLayer"],read:!1,write:{target:"layerType",ignoreOrigin:!0}}}}})],q.prototype,"operationalLayerType",void 0),a([O("web-map","operationalLayerType")],q.prototype,"writeOperationalLayerType",null),a([u(_t)],q.prototype,"popupEnabled",void 0),a([u({type:ot,json:{read:{source:"popupInfo"},write:{target:"popupInfo"}}})],q.prototype,"popupTemplate",void 0),a([u({readOnly:!0})],q.prototype,"defaultPopupTemplate",null),a([u({readOnly:!0,json:{read:!1}})],q.prototype,"type",void 0),q=a([J("esri.layers.ImageryLayer")],q);const qs=q;export{qs as default};
