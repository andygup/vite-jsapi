import{L as P,be as y,iR as x,E as s,iS as R,I as _,P as K,dt as q,ev as M,iT as U}from"./index-fb3bdf4f.js";import{u as w}from"./originUtils-dad1432b.js";import D from"./FeatureLayer-68e80759.js";import{a as W}from"./fetchService-0c2fe270.js";import{a as v}from"./jsonContext-416ca38c.js";import{a as f,b as z,r as g,T as c}from"./portalItemUtils-dd754f4b.js";import"./multiOriginJSONSupportUtils-ad07e08e.js";import"./UniqueValueRenderer-55012b53.js";import"./LegendOptions-a28747c0.js";import"./diffUtils-64bbc518.js";import"./SizeVariable-74abd6da.js";import"./colorRamps-81a71b30.js";import"./sizeVariableUtils-2914222a.js";import"./lengthUtils-1e4d8fd6.js";import"./ColorStop-b29cec61.js";import"./jsonUtils-3a34d9bc.js";import"./styleUtils-572710a0.js";import"./featureFlags-4ba2b89f.js";import"./jsonUtils-e6785b6d.js";import"./DictionaryLoader-0b6ffeed.js";import"./LRUCache-59f262f3.js";import"./MemCache-3f213196.js";import"./FieldsIndex-56690a21.js";import"./heatmapUtils-a281406f.js";import"./vec4-3dd523e8.js";import"./vec4f64-efdcb593.js";import"./MultiOriginJSONSupport-ea9beeba.js";import"./sql-0af83f60.js";import"./FeatureLayerBase-f47ab54b.js";import"./Field-f5f1ebb3.js";import"./fieldType-d335b740.js";import"./commonProperties-a5bf3577.js";import"./ElevationInfo-2af660b1.js";import"./AttachmentQuery-60b44dd6.js";import"./Query-476cb6f1.js";import"./RelationshipQuery-b61588d7.js";import"./serviceCapabilitiesUtils-2aaa1333.js";import"./editsZScale-a68f4aa0.js";import"./queryZScale-46b0ae7d.js";import"./FeatureSet-4f5601d6.js";import"./APIKeyMixin-9c9fbfaf.js";import"./ArcGISService-61e08bf7.js";import"./BlendLayer-2ddbe670.js";import"./jsonUtils-93f2c64d.js";import"./parser-77953c84.js";import"./_commonjsHelpers-725317a4.js";import"./CustomParametersMixin-3a61540d.js";import"./EditBusLayer-373c3cca.js";import"./FeatureReductionLayer-71c72362.js";import"./FeatureEffect-2fdde62f.js";import"./clusterUtils-c169a684.js";import"./labelingInfo-3bb75bee.js";import"./labelUtils-5f0b2e6a.js";import"./defaultsJSON-b396ba80.js";import"./OperationalLayer-914d208b.js";import"./OrderedLayer-9e11b7fe.js";import"./PortalLayer-d73148b9.js";import"./RefreshableLayer-3b03bf7b.js";import"./ScaleRangeLayer-77c2a39c.js";import"./TemporalLayer-a15af708.js";import"./FeatureTemplate-33a4a082.js";import"./FeatureType-9a9366e5.js";import"./fieldProperties-dcd9d2f8.js";import"./versionUtils-5af0a6f3.js";import"./styleUtils-6e60a30e.js";import"./TopFeaturesQuery-9293a704.js";import"./popupUtils-0e01ee8b.js";const C=P.getLogger("esri.layers.FeatureLayer"),d="Feature Service";function m(e,t){return`Layer (title: ${e.title}, id: ${e.id}) of type '${e.declaredClass}' ${t}`}function T(e,t){if(t.type!==d)throw new s("feature-layer:portal-item-wrong-type",m(e,`should have portal item of type "${d}"`))}async function O(e){if(await e.load(),x(e))throw new s("feature-layer:save",m(e,"using an in-memory source cannot be saved to a portal item"))}function Y(e,t){let r=(e.messages??[]).filter(({type:a})=>a==="error").map(({name:a,message:i,details:o})=>new s(a,i,o));if(t!=null&&t.ignoreUnsupported&&(r=r.filter(({name:a})=>a!=="layer:unsupported"&&a!=="symbol:unsupported"&&a!=="symbol-layer:unsupported"&&a!=="property:unsupported"&&a!=="url:unsupported")),r.length>0)throw new s("feature-layer:save","Failed to save feature layer due to unsupported or invalid content. See 'details.errors' for more detailed information",{errors:r})}async function I(e,t,r){"beforeSave"in e&&typeof e.beforeSave=="function"&&await e.beforeSave();const a=e.write({},t);return Y(t,r),a}function A(e){const{layer:t,layerJSON:r}=e;return t.isTable?{layers:[],tables:[r]}:{layers:[r],tables:[]}}function S(e){f(e,c.JSAPI),e.typeKeywords&&(e.typeKeywords=e.typeKeywords.filter((t,r,a)=>a.indexOf(t)===r))}function G(e){const t=e.portalItem;if(!t)throw C.error("save: requires the portalItem property to be set"),new s("feature-layer:portal-item-not-set",m(e,"requires the portalItem property to be set"));if(!t.loaded)throw new s("feature-layer:portal-item-not-loaded",m(e,"cannot be saved to a portal item that does not exist or is inaccessible"));T(e,t)}async function F(e,t){return/\/\d+\/?$/.test(e.url??"")?A(t[0]):j(e,t)}async function j(e,t){const{layer:{url:r,customParameters:a,apiKey:i}}=t[0];let o=await e.fetchData("json");(!o||o.layers==null||o.tables==null)&&(o=await B(o,{url:r??"",customParameters:a,apiKey:i},t.map(n=>n.layer.layerId)));for(const n of t)J(n.layer,n.layerJSON,o);return o}async function B(e,t,r){var a,i;e||(e={}),(a=e).layers||(a.layers=[]),(i=e).tables||(i.tables=[]);const{url:o,customParameters:n,apiKey:l}=t,{serviceJSON:p,layersJSON:u}=await W(o,{customParameters:n,apiKey:l}),h=L(e.layers,p.layers,r),b=L(e.tables,p.tables,r);e.layers=h.itemResources,e.tables=b.itemResources;const N=[...h.added,...b.added],$=u?[...u.layers,...u.tables]:[];return await V(e,N,o,$),e}function L(e,t,r){const a=R(e,t,(o,n)=>o.id===n.id);e=e.filter(o=>!a.removed.some(n=>n.id===o.id));const i=a.added.map(({id:o})=>({id:o}));return i.forEach(({id:o})=>{e.push({id:o})}),{itemResources:e,added:i.filter(({id:o})=>!r.includes(o))}}async function V(e,t,r,a){const i=t.map(({id:o})=>new D({url:r,layerId:o,sourceJSON:a.find(({id:n})=>n===o)}));await _(i.map(o=>o.load())),i.forEach(o=>{const{layerId:n,loaded:l,defaultPopupTemplate:p}=o;if(!l||p==null)return;const u={id:n,popupInfo:p.toJSON()};J(o,u,e)})}function J(e,t,r){e.isTable?E(r.tables,t):E(r.layers,t)}function E(e,t){if(!e)return;const r=e.findIndex(({id:a})=>a===t.id);r===-1?e.push(t):e[r]=t}function k(e){const{portalItem:t}=e;return U(e)&&!e.dynamicDataSource&&!!(t!=null&&t.loaded)&&t.type===d}async function H(e){if(!(e!=null&&e.length))throw new s("feature-layer-utils-saveall:missing-parameters","'layers' array should contain at least one feature layer");await Promise.all(e.map(o=>o.load()));for(const o of e)if(!k(o))throw new s("feature-layer-utils-saveall:invalid-parameters",`'layers' array should only contain layers or tables in a feature service loaded from 'Feature Service' item. ${m(o,"does not conform")}`,{layer:o});const t=e.map(o=>o.portalItem.id);if(new Set(t).size>1)throw new s("feature-layer-utils-saveall:invalid-parameters","All layers in the 'layers' array should be loaded from the same portal item");const a=e.map(o=>o.layerId);if(new Set(a).size!==a.length)throw new s("feature-layer-utils-saveall:invalid-parameters","'layers' array should contain only one instance each of layer or table in a feature service")}function Q(e,t){var r,a;let i=K.from(t);return i.id&&(i=i.clone(),i.id=null),(r=i).type??(r.type=d),(a=i).portal??(a.portal=q.getDefault()),T(e,i),i}async function X(e,t){const{url:r,layerId:a,title:i,fullExtent:o,isTable:n}=e,l=M(r),p=l!=null&&l.serverType==="FeatureServer";t.url=p?r:`${r}/${a}`,t.title||(t.title=i),t.extent=null,!n&&o!=null&&(t.extent=await z(o)),g(t,c.METADATA),g(t,c.MULTI_LAYER),f(t,c.SINGLE_LAYER),n&&f(t,c.TABLE),S(t)}async function Z(e,t,r){var i;const a=e.portal;await(a==null?void 0:a.signIn()),await((i=a==null?void 0:a.user)==null?void 0:i.addItem({item:e,data:t,folder:r==null?void 0:r.folder}))}const wt=y(ee);async function ee(e,t){await O(e),G(e);const r=e.portalItem,a=v(r),i=await I(e,a,t),o=await F(r,[{layer:e,layerJSON:i}]);return S(r),await r.update({data:o}),w(a),r}const te=async(e,t)=>{await H(e);const r=e[0].portalItem,a=v(r),i=await Promise.all(e.map(n=>I(n,a,t))),o=await F(r,e.map((n,l)=>({layer:n,layerJSON:i[l]})));return S(r),await r.update({data:o}),await Promise.all(e.slice(1).map(n=>n.portalItem.reload())),w(a),r.clone()},vt=y(te),It=y(re);async function re(e,t,r){await O(e);const a=Q(e,t),i=v(a),o=await I(e,i,r),n=A({layer:e,layerJSON:o});return await X(e,a),await Z(a,n,r),e.portalItem=a,w(i),a}export{wt as save,vt as saveAll,It as saveAs};
