import{e as w,y as b,n as K,l as nt}from"./cast-daef7652.js";import{k as at}from"./PopupTemplate-343851b8.js";import{c as ot,w as lt,l as qe,$ as Be,V as ct,L as ut,j as ft,n as ht,m as mt,u as pt,o as dt,a as yt}from"./fetchRasterInfo-61d2b0ab.js";import{s as Ue,a as $}from"./Error-bd05b442.js";import{r as k,e as U,t as M,f as gt,E as xt}from"./typedArrayUtil-2bcf3cee.js";import{O as It}from"./MultiOriginJSONSupport-03b5d89b.js";import{v as wt,E as Ve,a as bt,w as St}from"./promiseUtils-29120e0a.js";import{l as vt}from"./reactiveUtils-3c1b281e.js";import{v as Tt,T as Rt}from"./ensureType-fa162cfc.js";import{r as _t}from"./enumeration-e46f3fd4.js";import{w as N,a as W,k as J,b as kt,o as Ct}from"./Extent-7f29a1bb.js";import{b as Ft}from"./Layer-8a472a77.js";import{n as Pt}from"./BlendLayer-1b58b599.js";import{o as Mt}from"./CustomParametersMixin-35ce1754.js";import"./geometry-4b789d90.js";import{U as Xe,j as $t}from"./request-c2b0ab45.js";import{S as Ye}from"./arcgisLayerUrl-269cc7a9.js";import{f as Ke,c as Ot,a as Bt}from"./OperationalLayer-7b681a2a.js";import{f as Qe,g as Dt,i as Et,s as zt,p as Ze,c as De,m as Nt,d as Jt}from"./multidimensionalUtils-5ae835b1.js";import{j as he}from"./TileInfo-2e5a94dc.js";import{m as Ht}from"./Promise-088a0e17.js";import{S as Lt,b as me,T as At,r as Ee,e as pe,p as Wt,j as Fe,P as jt,l as Gt,N as qt,D as Ut,m as ye,G as Vt,q as Xt,O as Yt}from"./RasterSymbolizer-9d8f2f14.js";import{a as ze,x as Ne,h as Je,d as Kt,m as Qt}from"./RawBlockCache-204337b6.js";import{T as ve,D as Zt,j as ei,W as ti,b as ii,g as ri}from"./pixelUtils-5f39bd45.js";import{T as He,U as ge,j as Le,o as Ae,n as si,Q as Te,J as Re,$ as ni,V as ai,C as oi}from"./rasterProjectionHelper-0bcfa8ae.js";import{m as li,b as ci,d as ui,f as fi}from"./dataUtils-0f7e9d2b.js";import{l as et,f as hi,i as mi,m as Pe,c as pi}from"./utils-4006e1d8.js";import{v as di}from"./PortalLayer-4d594091.js";import{p as yi}from"./RefreshableLayer-b2e977af.js";import{t as gi}from"./ScaleRangeLayer-d12362d4.js";import{a as xi}from"./TemporalLayer-e6ec9fbe.js";import{y as fe}from"./Field-0ac3c9d2.js";import tt from"./FeatureSet-9ea00c01.js";import{h as Ii}from"./string-3d0ebcd3.js";import{n as wi,z as bi}from"./TilemapCache-a687a02a.js";import{p as Si}from"./popupUtils-aa41216c.js";import"./nextTick-3ee5a785.js";import"./Clonable-f249bc0f.js";import"./Collection-e2259e32.js";import"./Evented-d8fc77f0.js";import"./SimpleObservable-7c382d01.js";import"./fieldUtils-021fea8a.js";import"./preload-helper-101896b7.js";import"./arcadeOnDemand-87969052.js";import"./jsonMap-a9c94baf.js";import"./number-53937715.js";import"./locale-30120714.js";import"./Identifiable-e3a09883.js";import"./Polyline-c56eca9b.js";import"./jsonUtils-8bd548d9.js";import"./workers-125ce03d.js";import"./Connection-98b56925.js";import"./Queue-e839cb6a.js";import"./assets-4cb15247.js";import"./intl-afc91037.js";import"./messages-03a939ad.js";import"./Color-2245b966.js";import"./colorUtils-639f4d25.js";import"./mathUtils-daf59e84.js";import"./common-701a4199.js";import"./UniqueValueRenderer-83bbe8b7.js";import"./symbols-fce921a6.js";import"./CIMSymbol-d0e12b74.js";import"./Symbol-f45dc441.js";import"./screenUtils-7afeb41c.js";import"./opacityUtils-94fd2faa.js";import"./aaBoundingBox-6fbd5972.js";import"./persistableUrlUtils-7e525def.js";import"./collectionUtils-09289d8f.js";import"./Portal-ac0dca24.js";import"./Loadable-7c89bd10.js";import"./PortalGroup-f3dee6d8.js";import"./PortalUser-cdb4116b.js";import"./LegendOptions-54bbb61a.js";import"./diffUtils-58fbd195.js";import"./colorRamps-3439e132.js";import"./sizeVariableUtils-d4870b0d.js";import"./Graphic-cf98a91a.js";import"./compilerUtils-06ced1a6.js";import"./lengthUtils-5215af35.js";import"./unitUtils-43365914.js";import"./jsonUtils-f34afef9.js";import"./styleUtils-84c98663.js";import"./normalizeUtils-d322ac85.js";import"./utils-95450d21.js";import"./asyncUtils-59234081.js";import"./parser-e6166e34.js";import"./mat4-62d5e6a4.js";import"./ItemCache-9a7b0057.js";import"./MemCache-5bd66e9c.js";import"./generateRendererUtils-92e71197.js";import"./typeUtils-d7b057b5.js";import"./TimeExtent-84882adb.js";import"./ElevationInfo-4e7fad68.js";import"./aaBoundingRect-45a7fe45.js";import"./colorUtils-0c057879.js";import"./projection-33a6cba9.js";import"./zscale-a508c8e5.js";import"./PortalItem-07c1e88d.js";import"./TimeInfo-cbe37d4e.js";import"./fieldType-4ec45634.js";import"./byteSizeEstimations-90c5a50d.js";import"./HandleOwner-78d35324.js";import"./LRUCache-36379339.js";const xe=8;let q=class extends Ht(nt){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const t=He();this.addResolvingPromise(t),await this.when()}normalizeCtorArgs(t){return t&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:he.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,e=ge(t.spatialReference);return k(e)&&t.extent.width>=e/2}set url(t){this._set("url",Ye(t,Ue.getLogger(this.declaredClass)))}async open(t){throw new $("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(t,e,s,i={}){const r=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(t,e,s,r);return this.fetchPixels(n,r.size[0],r.size[1],i)}async identify(t,e={}){var _;t=Tt(N,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:i}=e,{hasMultidimensionalTranspose:r,multidimensionalInfo:n}=this.rasterInfo;let{transposedVariableName:a}=e;const l=k(n)&&r&&(i!=null||Qe(s));l&&!a&&(a=k(s)&&s.length>0?s[0].variableName??void 0:n.variables[0].name,e={...e,transposedVariableName:a}),e=this._getRequestOptionsWithSliceId(e);const{spatialReference:o,extent:c}=this.rasterInfo,{datumTransformation:u}=e;let h=Le(t,o,u);if(!c.intersects(h))return{location:h,value:null};if(k(this.rasterInfo.transform)){const P=this.rasterInfo.transform.inverseTransform(h);if(!this.rasterInfo.nativeExtent.intersects(P))return{location:P,value:null};h=P}let m=0;const f=k(a)&&k(n)&&this.rasterInfo.hasMultidimensionalTranspose;if(!f){if(e.srcResolution)m=Ae(e.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel;else if(m=await this.computeBestPyramidLevelForLocation(t,e),m==null)return{location:h,value:null}}const y=this.identifyPixelLocation(h,m,null,f);if(y===null)return{location:h,value:null};const{row:d,col:p,rowOffset:g,colOffset:x,blockWidth:I}=y,C=a??U(e.sliceId),F=ze(this.url,C),T=`${m}/${d}/${p}`;let v=Ne(F,null,T);M(v)&&(v=this.fetchRawTile(m,d,p,e),Je(F,null,T,v));const R=await v;if(M(R)||!((_=R.pixels)!=null&&_.length))return{location:h,value:null};const S=g*I+x;return this._processIdentifyResult(R,{srcLocation:h,position:S,pyramidLevel:m,useTransposedTile:!!f,requestSomeSlices:l,identifyOptions:e})}async fetchPixels(t,e,s,i={}){if(t=si(t),(i=this._getRequestOptionsWithSliceId(i)).requestRawData)return this._fetchPixels(t,e,s,i);const r=ge(t.spatialReference),n=Te(t);if(M(r)||n===0||n===1&&this._isGlobalWrappableSource)return this._fetchPixels(t,e,s,i);if(n>=3)return{extent:t,pixelBlock:null};const a=[],{xmin:l,xmax:o}=t,c=Math.round(r/(o-l)*e),u=c-Math.round((r/2-l)/(o-l)*e);let h=0;const m=[];for(let p=0;p<=n;p++){const g=new W({xmin:p===0?l:-r/2,xmax:p===n?o-r*p:r/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),x=p===0?c-u:p===n?e-h:c;h+=x,m.push(x);const I=i.disableWrapAround&&p>0?null:this._fetchPixels(g,x,s,i);a.push(I)}const f=(await Promise.all(a)).map(p=>p==null?void 0:p.pixelBlock);let y=null;const d={width:e,height:s};return this.rasterJobHandler?y=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:f,srcMosaicSize:d,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:m},i)).pixelBlock:y=ve(f,d,{blockWidths:m}),{extent:t,srcExtent:Re(t,this.rasterInfo.spatialReference,i.datumTransformation),pixelBlock:y}}async fetchRawPixels(t,e,s,i={}){e={x:Math.floor(e.x),y:Math.floor(e.y)};const r=await this._fetchRawTiles(t,e,s,i),{nativeExtent:n,nativePixelSize:a,storageInfo:l}=this.rasterInfo,o=2**t,c=a.x*o,u=a.y*o,h=new W({xmin:n.xmin+c*e.x,xmax:n.xmin+c*(e.x+s.width-1),ymin:n.ymax-u*(e.y+s.height-1),ymax:n.ymax-u*e.y,spatialReference:n.spatialReference});if(!r)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:m,mosaicSize:f}=r;if(m.length===1&&k(m[0])&&m[0].width===s.width&&m[0].height===s.height)return{extent:h,srcExtent:h,pixelBlock:r.pixelBlocks[0]};const y=t>0?l.pyramidBlockWidth:l.blockWidth,d=t>0?l.pyramidBlockHeight:l.blockHeight,p={x:e.x%y,y:e.y%d};let g;return this.rasterJobHandler?g=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:m,srcMosaicSize:f,destDimension:s,clipOffset:p,clipSize:s,coefs:null,sampleSpacing:null,interpolation:i.interpolation,alignmentInfo:null,blockWidths:null},i)).pixelBlock:g=ve(m,f,{clipOffset:p,clipSize:s}),{extent:h,srcExtent:h,pixelBlock:g}}fetchRawTile(t,e,s,i){throw new $("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Re(this.rasterInfo.extent,t)}decodePixelBlock(t,e){return!this.rasterJobHandler||e.useCanvas?Lt(t,e):this.rasterJobHandler.decode({data:t,options:e})}async request(t,e,s=0){const{customFetchParameters:i}=this.ioConfig,{range:r,query:n,headers:a}=e;s=s??e.retryCount??this.ioConfig.retryCount;const l=r?{Range:`bytes=${r.from}-${r.to}`}:null;try{return await Xe(t,{...e,query:{...n,...i},headers:{...a,...l}})}catch(o){if(s>0)return s--,this.request(t,e,s);throw o}}getSliceIndex(t){const{multidimensionalInfo:e}=this.rasterInfo;return M(e)||M(t)||t.length===0?null:Dt(t,e)}getTileExtentFromTileInfo(t,e,s,i){const r=gt(i.lodAt(t));return this.getTileExtent({x:r.resolution,y:r.resolution},e,s,i.origin,i.spatialReference,i.size)}updateTileInfo(){const{storageInfo:t,spatialReference:e,extent:s,pixelSize:i}=this.rasterInfo;if(!t.tileInfo){const r=[],n=t.maximumPyramidLevel||0;let a=Math.max(i.x,i.y),l=1/.0254*96*a;for(let c=0;c<=n;c++)r.push({level:n-c,resolution:a,scale:l}),a*=2,l*=2;const o=new N({x:s.xmin,y:s.ymax,spatialReference:e});t.tileInfo=new he({origin:o,size:[t.blockWidth,t.blockHeight],spatialReference:e,lods:r}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,e=512,s=512,i){const{width:r,height:n,nativeExtent:a,pixelSize:l,spatialReference:o}=t,c=new N({x:a.xmin,y:a.ymax,spatialReference:o});i==null&&(i=Math.max(0,Math.round(Math.log(Math.max(r,n))/Math.LN2-8)));const u=this.computeBlockBoundary(a,512,512,{x:a.xmin,y:a.ymax},[l],i);t.storageInfo=new me({blockWidth:e,blockHeight:s,pyramidBlockWidth:e,pyramidBlockHeight:s,origin:c,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,e={}){return 0}computeBlockBoundary(t,e,s,i,r,n=0,a=2){if(r.length===1&&n>0){r=[...r];let{x:u,y:h}=r[0];for(let m=0;m<n;m++)u*=a,h*=a,r.push({x:u,y:h})}const l=[],{x:o,y:c}=i;for(let u=0;u<r.length;u++){const{x:h,y:m}=r[u];l.push({minCol:Math.floor((t.xmin-o+.1*h)/e/h),maxCol:Math.floor((t.xmax-o-.1*h)/e/h),minRow:Math.floor((c-t.ymax+.1*m)/s/m),maxRow:Math.floor((c-t.ymin-.1*m)/s/m)})}return l}getPyramidPixelSize(t){const{nativePixelSize:e}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:i}=this.rasterInfo.storageInfo;if(t===0)return e;if(k(s)&&s.length)return s[t-1];const r=i**t;return{x:e.x*r,y:e.y*r}}identifyPixelLocation(t,e,s,i){const{spatialReference:r,nativeExtent:n,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:l,origin:o,transposeInfo:c}=a,u=i&&k(c)?c.tileSize[0]:a.blockWidth,h=i&&k(c)?c.tileSize[1]:a.blockHeight,m=Le(t,r,s);if(!n.intersects(m)||e<0||e>l)return null;const f=this.getPyramidPixelSize(e),{x:y,y:d}=f,p=(o.y-m.y)/d/h,g=(m.x-o.x)/y/u,x=Math.min(h-1,Math.floor((p-Math.floor(p))*h)),I=Math.min(u-1,Math.floor((g-Math.floor(g))*u));return{pyramidLevel:e,row:Math.floor(p),col:Math.floor(g),rowOffset:x,colOffset:I,blockWidth:u,srcLocation:m}}getTileExtent(t,e,s,i,r,n){const[a,l]=n,o=i.x+s*a*t.x,c=o+a*t.x,u=i.y-e*l*t.y,h=u-l*t.y;return new W({xmin:o,xmax:c,ymin:h,ymax:u,spatialReference:r})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,e,s){const i=this.rasterInfo.storageInfo.blockBoundary[t];return!i||i.maxRow<e||i.maxCol<s||i.minRow>e||i.minCol>s}async _fetchPixels(t,e,s,i={}){let r=Te(t);if(r>=2)return{extent:t,pixelBlock:null};const n=this._getSourceDataInfo(t,e,s,i),{pyramidLevel:a,pyramidResolution:l,srcResolution:o,srcExtent:c,srcWidth:u,srcHeight:h}=n;if(u===0||h===0)return{extent:t,srcExtent:c,pixelBlock:null};const m=U(this.rasterInfo.transform),f=(m==null?void 0:m.type)==="gcs-shift",y=k(ge(t.spatialReference));!f&&y||(r=Te(n.srcExtent,f));const d=this.rasterInfo.storageInfo,p={x:Math.floor((c.xmin-d.origin.x)/l.x+.1),y:Math.floor((d.origin.y-c.ymax)/l.y+.1)},g=await this._fetchRawTiles(a,p,{width:u,height:h,wrapCount:r},i);if(!g)return{extent:t,srcExtent:c,pixelBlock:null};const x=a>0?d.pyramidBlockWidth:d.blockWidth,I=a>0?d.pyramidBlockHeight:d.blockHeight,C=x===u&&I===h&&p.x%x==0&&p.y%I==0,F=new N({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),T=!t.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:v}=i;if(!T&&C&&g.pixelBlocks.length===1&&x===e&&I===s&&o.x===F.x&&o.y===F.y)return{extent:t,srcExtent:c,pixelBlock:g.pixelBlocks[0]};const R=y&&k(ge(c.spatialReference)),S=i.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");S&&!this.rasterJobHandler&&await He();const _=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:F.toJSON(),datumTransformation:v,rasterTransform:m,hasWrapAround:r>0||R,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:S},i):ni({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:F,datumTransformation:v,rasterTransform:m,hasWrapAround:r>0||R,isAdaptive:!1,includeGCSGrid:S});let P;const E=!i.requestRawData,j={rows:_.spacing[0],cols:_.spacing[1]},H=U(this._getRasterTileAlignmentInfo(a,g.extent.xmin)),{pixelBlocks:B,mosaicSize:L,isPartiallyFilled:G}=g;let V=null;if(this.rasterJobHandler)({pixelBlock:P,localNorthDirections:V}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:L,destDimension:E?{width:e,height:s}:null,coefs:E?_.coefficients:null,sampleSpacing:E?j:null,projectDirections:S,gcsGrid:S?_.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:i.interpolation,alignmentInfo:H,blockWidths:null},i));else{const D=ve(B,L,{alignmentInfo:H});P=E?Zt(D,{width:e,height:s},_.coefficients,j,i.interpolation):D,S&&_.gcsGrid&&(V=ei({width:e,height:s},_.gcsGrid),P=li(P,this.rasterInfo.dataType,V))}return i.requestRawData||S?{srcExtent:c,pixelBlock:P,transformGrid:_,localNorthDirections:V,extent:t,isPartiallyFilled:G}:{srcExtent:c,extent:t,pixelBlock:P}}async _fetchRawTiles(t,e,s,i){const{origin:r,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:l}=this.getBlockWidthHeight(t);let{x:o,y:c}=e,{width:u,height:h,wrapCount:m}=s;const f=this._getRasterTileAlignmentInfo(t,0);i.buffer&&(o-=i.buffer.cols,c-=i.buffer.rows,u+=2*i.buffer.cols,h+=2*i.buffer.rows);let y=0,d=0,p=0;m&&k(f)&&({worldColumnCountFromOrigin:d,originColumnOffset:p,rightPadding:y}=f,d*f.blockWidth-y>=o+u&&(y=0));const g=Math.floor(o/a),x=Math.floor(c/l),I=Math.floor((o+u+y-1)/a),C=Math.floor((c+h+y-1)/l),F=n[t];if(!F)return null;const{minRow:T,minCol:v,maxCol:R,maxRow:S}=F;if(m===0&&(C<T||I<v||x>S||g>R))return null;const _=new Array;let P=!1;const E=this.ioConfig.allowPartialFill==null?i.allowPartialFill:this.ioConfig.allowPartialFill;for(let D=x;D<=C;D++)for(let ae=g;ae<=I;ae++){let de=ae;if(!i.disableWrapAround&&m&&k(f)&&d<=ae&&(de=ae-d-p),D>=T&&de>=v&&S>=D&&R>=de){const $e=this._fetchRawTile(t,D,de,i);E?_.push(new Promise(Oe=>{$e.then(st=>Oe(st)).catch(()=>{P=!0,Oe(null)})})):_.push($e)}else _.push(Promise.resolve(null))}if(_.length===0)return null;const j=await Promise.all(_),H={height:(C-x+1)*l,width:(I-g+1)*a},{spatialReference:B}=this.rasterInfo,L=this.getPyramidPixelSize(t),{x:G,y:V}=L;return{extent:new W({xmin:r.x+g*a*G,xmax:r.x+(I+1)*a*G,ymin:r.y-(C+1)*l*V,ymax:r.y-x*l*V,spatialReference:B}),pixelBlocks:j,mosaicSize:H,isPartiallyFilled:P}}_fetchRawTile(t,e,s,i){const r=this.rasterInfo.storageInfo.blockBoundary[t];if(!r)return Promise.resolve(null);const{minRow:n,minCol:a,maxCol:l,maxRow:o}=r;if(e<n||s<a||e>o||s>l)return Promise.resolve(null);const c=ze(this.url,i.sliceId),u=`${t}/${e}/${s}`;let h=Ne(c,i.registryId,u);if(M(h)){const m=new AbortController;h=this.fetchRawTile(t,e,s,{...i,signal:m.signal}),Je(c,i.registryId,u,h,m),h.catch(()=>Kt(c,i.registryId,u))}return i.signal&&wt(i,()=>{Qt(c,i.registryId,u)}),h}_computeMagDirValues(t){var o;const{bandCount:e,dataType:s}=this.rasterInfo;if(!(e===2&&s==="vector-magdir"||s==="vector-uv")||(t==null?void 0:t.length)!==2||!((o=t[0])!=null&&o.length))return null;const i=t[0].length;if(s==="vector-magdir"){const c=t[1].map(u=>(u+360)%360);return[t[0],c]}const[r,n]=t,a=[],l=[];for(let c=0;c<i;c++){const[u,h]=ci([r[c],n[c]]);a.push(u),l.push(h)}return[a,l]}_getRasterTileAlignmentInfo(t,e){return this._rasterTileAlighmentInfo==null&&(this._rasterTileAlighmentInfo=ai(this.rasterInfo)),M(this._rasterTileAlighmentInfo.pyramidsInfo)?null:{startX:e,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,e,s,i={}){const r={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};i.srcResolution&&(r.srcResolution=i.srcResolution,this._updateSourceDataInfo(t,r));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:a,srcHeight:l,pyramidLevel:o}=r,c=a/e,u=l/s,h=o<n&&c*u>=16;if(h||o===n&&(c>xe||u>xe)||a===0||l===0){const m=new N({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let f=oi(m,this.rasterInfo.spatialReference,t,r.datumTransformation);const y=!f||i.srcResolution&&f.x+f.y<i.srcResolution.x+i.srcResolution.y;if(h&&i.srcResolution&&y){const d=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(n-o+3>=d){const p=2**d;f={x:i.srcResolution.x*p,y:i.srcResolution.y*p}}}f&&(r.srcResolution=f,this._updateSourceDataInfo(t,r))}return(r.srcWidth/e>xe||r.srcHeight/s>xe)&&(r.srcWidth=0,r.srcHeight=0),r}_updateSourceDataInfo(t,e){e.srcWidth=0,e.srcHeight=0;const s=this.rasterInfo.spatialReference,{srcResolution:i,datumTransformation:r}=e,{pyramidLevel:n,pyramidResolution:a,excessiveReading:l}=Ae(i,this.rasterInfo,this.ioConfig.sampling);if(l)return;let o=e.srcExtent||Re(t,s,r);if(o==null)return;const c=U(this.rasterInfo.transform);c&&(o=c.inverseTransform(o)),e.srcExtent=o;const u=Math.ceil((o.xmax-o.xmin)/a.x-.1),h=Math.ceil((o.ymax-o.ymin)/a.y-.1);e.pyramidLevel=n,e.pyramidResolution=a,e.srcWidth=u,e.srcHeight=h}_getRequestOptionsWithSliceId(t){return k(this.rasterInfo.multidimensionalInfo)&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,e){const{srcLocation:s,position:i,pyramidLevel:r,useTransposedTile:n}=e,a=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[i]))return{location:s,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(M(l)||!n){const f=t.pixels.map(p=>p[i]),y={location:s,value:f,pyramidLevel:r},d=this._computeMagDirValues(f.map(p=>[p]));return d!=null&&d.length&&(y.magdirValue=d.map(p=>p[0])),y}let o=t.pixels.map(f=>Array.prototype.slice.call(f,i*a,i*a+a)),c=this._computeMagDirValues(o);const{requestSomeSlices:u,identifyOptions:h}=e;let m=Et(l,h.transposedVariableName);if(u){const f=zt(m,U(h.multidimensionalDefinition),U(h.timeExtent));o=o.map(y=>f.map(d=>y[d])),c=c==null?void 0:c.map(y=>f.map(d=>y[d])),m=f.map(y=>m[y])}return{location:s,value:null,dataSeries:m.map((f,y)=>{const d={value:o.map(p=>p[y]),multidimensionalDefinition:f.multidimensionalDefinition.map(p=>new Ze({...p,isSlice:!0}))};return c!=null&&c.length&&(d.magdirValue=[c[0][y],c[1][y]]),d}),pyramidLevel:r}}};w([b()],q.prototype,"_rasterTileAlighmentInfo",void 0),w([b({readOnly:!0})],q.prototype,"_isGlobalWrappableSource",null),w([b(Ke)],q.prototype,"url",null),w([b({type:String,json:{write:!0}})],q.prototype,"datasetName",void 0),w([b({type:String,json:{write:!0}})],q.prototype,"datasetFormat",void 0),w([b()],q.prototype,"rasterInfo",void 0),w([b()],q.prototype,"ioConfig",void 0),w([b()],q.prototype,"sourceJSON",void 0),q=w([K("esri.layers.support.rasterDatasets.BaseRaster")],q);const ie=q;let re=class extends ie{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._primaryRasters=null}async open(e){await this.init();const{rasterFunction:s}=this,{rasters:i,rasterIds:r}=s.getPrimaryRasters(),n=i.map(o=>o.rasterInfo?void 0:o.open(e));await Promise.all(n);const a=i.map(({rasterInfo:o})=>o),l=s.bind({rasterInfos:a,rasterIds:r});if(!l.success)throw new $("raster-function:open",`cannot bind the function: ${l.error??""}`);await this.syncJobHandler(),this.set("sourceJSON",i[0].sourceJSON),this.set("rasterInfo",s.rasterInfo)}async syncJobHandler(){const{rasterFunction:e}=this;if(this._primaryRasters=e.getPrimaryRasters(),this.rasterJobHandler)return this.rasterJobHandler.updateRasterFunction(e)}async fetchPixels(e,s,i,r={}){var m;const{rasters:n,rasterIds:a}=this._primaryRasters,l=n.map(f=>f.fetchPixels(e,s,i,r)),o=await Promise.all(l),c=o.map(f=>f.pixelBlock);if(c.every(f=>M(f)))return o[0];const u=((m=o.find(f=>k(f.pixelBlock)))==null?void 0:m.extent)??e,h=this.rasterJobHandler?await this.rasterJobHandler.process({extent:u,primaryPixelBlocks:c,primaryRasterIds:a}):this.rasterFunction.process({extent:u,primaryPixelBlocks:c,primaryRasterIds:a});return{...o[0],pixelBlock:h}}};w([b({type:String,json:{write:!0}})],re.prototype,"datasetFormat",void 0),w([b()],re.prototype,"tileType",void 0),w([b()],re.prototype,"rasterFunction",void 0),re=w([K("esri.layers.support.rasterDatasets.FunctionRaster")],re);const it=re,We=Ue.getLogger("esri.layers.mixins.ImageryTileMixin"),vi=t=>{let e=class extends t{constructor(){super(...arguments),this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalDefinition=null,this.multidimensionalSubset=null,this.raster=null,this.rasterFunction=null,this.sourceJSON=null,this.symbolizer=null}get fullExtent(){var i;return(i=this.rasterInfo)==null?void 0:i.extent}get rasterInfo(){var i;return(i=this.raster)==null?void 0:i.rasterInfo}get spatialReference(){var i;return((i=this.rasterInfo)==null?void 0:i.spatialReference)??J.WGS84}get tileInfo(){var i;return(i=this.rasterInfo)==null?void 0:i.storageInfo.tileInfo}set url(i){this._set("url",Ye(i,We))}set renderer(i){this._set("renderer",i),this.updateRenderer()}async convertVectorFieldData(i,r){if(M(i)||!this.rasterInfo)return null;const n=this._rasterJobHandler.instance,a=this.rasterInfo.dataType;return n?n.convertVectorFieldData({pixelBlock:i,dataType:a},r):ui(i,a)}async createFlowMesh(i,r){const n=this._rasterJobHandler.instance;return n?n.createFlowMesh(i,r):fi(i.meshType,i.simulationSettings,i.flowData,k(r.signal)?r.signal:new AbortController().signal)}normalizeRasterFetchOptions(i){var l,o;const{multidimensionalInfo:r}=this.rasterInfo??{};if(M(r))return i;let n=i.multidimensionalDefinition||this.multidimensionalDefinition;!M(n)&&n.length||(n=De(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const a=i.timeExtent||this.timeExtent;if(k(n)&&k(a)&&(k(a.start)||k(a.end))){n=n.map(g=>g.clone());const c=(o=(l=r.variables.find(({name:g})=>g===n[0].variableName))==null?void 0:l.dimensions)==null?void 0:o.find(({name:g})=>g==="StdTime"),u=n.find(({dimensionName:g})=>g==="StdTime");if(!c||!u)return{...i,multidimensionalDefinition:null};const{start:h,end:m}=a,f=M(h)?null:h.getTime(),y=M(m)?null:m.getTime(),d=f??y,p=y??f;if(k(c.values)){const g=c.values.filter(x=>{if(Array.isArray(x)){if(d===p)return x[0]<=d&&x[1]>=d;const I=x[0]<=d&&x[1]>d||x[0]<p&&x[1]>=p,C=x[0]>=d&&x[1]<=p||x[0]<d&&x[1]>p;return I||C}return d===p?x===d:x>=d&&x<=p});if(g.length){const x=g.sort((I,C)=>d===p?(I[0]??I)-(C[0]??C):Math.abs((I[1]??I)-p)-Math.abs((C[1]??C)-p))[0];u.values=[x]}else n=null}else if(c.hasRegularIntervals&&c.extent){const[g,x]=c.extent;d>x||p<g?n=null:u.values=d===p?[d]:[Math.max(g,d),Math.min(x,p)]}}return k(n)&&Nt(n,this.multidimensionalSubset)?{...i,multidimensionalDefinition:null}:{...i,multidimensionalDefinition:n}}async updateRenderer(){const{loaded:i,symbolizer:r}=this;if(!i||!r||JSON.stringify(this._cachedRendererJson)===JSON.stringify(this.renderer))return;const n=this._rasterJobHandler.instance;n&&(r.rendererJSON=Be(this.renderer.toJSON()),r.bind(),await n.updateSymbolizer(r),this._cachedRendererJson=this.renderer.toJSON())}async applyRenderer(i,r){const n=i&&i.pixelBlock;if(!(k(n)&&n.pixels&&n.pixels.length>0))return null;let a;await this.updateRenderer();const l=this._rasterJobHandler.instance,o=this.bandIds??[];return a=l?await l.symbolize({...i,simpleStretchParams:r,bandIds:o}):this.symbolizer.symbolize({...i,simpleStretchParams:r,bandIds:o}),a}getTileUrl(i,r,n){var a;return((a=this.raster)==null?void 0:a.datasetFormat)==="RasterTileServer"?`${this.url}/tile/${i}/${r}/${n}`:""}getCompatibleTileInfo(i,r,n=!1){if(!this.loaded||M(r))return null;if(n&&i.equals(this.spatialReference))return this.tileInfo;const a=kt(i);return he.create({size:256,spatialReference:i,origin:a?{x:a.origin[0],y:a.origin[1]}:{x:r.xmin,y:r.ymax}})}getCompatibleFullExtent(i){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(i)||(this._compatibleFullExtent=this.raster.computeExtent(i)),this._compatibleFullExtent):null}async fetchTile(i,r,n,a={}){if(s(this),a.requestAsImageElement){const l=this.getTileUrl(i,r,n);return Xe(l,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:a.signal}).then(o=>o.data)}if(k(this.rasterInfo.multidimensionalInfo)&&(a=this.normalizeRasterFetchOptions(a),M(a.multidimensionalDefinition))){const l=a.tileInfo||this.rasterInfo.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(i,r,n,l),pixelBlock:null}}return await this._initJobHandler(),await this._updateRasterFunction(),this.renderer.type==="raster-shaded-relief"&&(a={...a,buffer:{cols:1,rows:1}}),this.raster.fetchTile(i,r,n,a)}async fetchPixels(i,r,n,a={}){return k(this.rasterInfo.multidimensionalInfo)&&(a=this.normalizeRasterFetchOptions(a),M(a.multidimensionalDefinition))?{extent:i,pixelBlock:null}:(await this._initJobHandler(),await this._updateRasterFunction(),this.raster.fetchPixels(i,r,n,a))}async identify(i,r={}){return s(this),k(this.rasterInfo.multidimensionalInfo)&&!(this.rasterInfo.hasMultidimensionalTranspose&&(Qe(r.multidimensionalDefinition)||r.transposedVariableName||r.timeExtent))&&(r=this.normalizeRasterFetchOptions(r),M(r.multidimensionalDefinition))?{location:i,value:null}:this.raster.identify(i,r)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){var a,l,o;const i=(a=this.rasterInfo)==null?void 0:a.multidimensionalInfo;if(M(i)||((l=this.rasterInfo)==null?void 0:l.dataType)!=="standard-time")return!1;const r=this.multidimensionalDefinition,n=(o=r==null?void 0:r[0])==null?void 0:o.variableName;return i.variables.some(c=>c.name===n&&(!(r!=null&&r[0].dimensionName)||c.dimensions.some(u=>u.name==="StdTime")))}getStandardTimeValue(i){return new Date(24*(i-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(i){const r=i??this.rasterInfo.multidimensionalInfo;return Jt(this.multidimensionalSubset,r)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=De(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this._configDefaultRenderer()}_initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;const i=new ht;return this._rasterJobHandler.connectionPromise=i.initialize().then(()=>{s(this),this._rasterJobHandler.instance=i,this.raster.rasterJobHandler=i,this.renderer&&this.updateRenderer(),this.raster.datasetFormat==="Function"&&this.raster.syncJobHandler()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){var i;if(this.interpolation==null){s(this);const r=ct(this.rasterInfo,this.raster.tileType,(i=this.sourceJSON)==null?void 0:i.defaultResamplingMethod);this._set("interpolation",r)}}_configDefaultRenderer(){var n,a,l;s(this);const i=this.raster.rasterInfo;if(this.bandIds||(this.bandIds=ut(i)),!this.renderer){const o=ft(i,{bandIds:this.bandIds,variableName:k(this.multidimensionalDefinition)?(n=this.multidimensionalDefinition[0])==null?void 0:n.variableName:null});this.raster.datasetFormat==="WCSServer"&&o.type==="raster-stretch"&&((((a=i.statistics)==null?void 0:a[0].max)??0)>1e24||(((l=i.statistics)==null?void 0:l[0].min)??0)<-1e24)&&(o.dynamicRangeAdjustment=!0,o.statistics=null,o.stretchType==="none"&&(o.stretchType="min-max")),this.renderer=o}this.symbolizer?(this.symbolizer.rendererJSON=Be(this.renderer.toJSON()),this.symbolizer.rasterInfo=i):this.symbolizer=new At({rendererJSON:this.renderer.toJSON(),rasterInfo:i});const r=this.symbolizer.bind();r.success||We.warn("imagery-tile-mixin",r.error||"The given renderer is not supported by the layer.")}async _updateRasterFunction(){var n;if(this.type!=="imagery-tile"||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;let i=this.raster;(i==null?void 0:i.datasetFormat)==="Function"&&(i=i.rasterFunction.getPrimaryRasters().rasters[0]);const{rasterFunction:r}=this;if(r){const a=et(r.toJSON(),{raster:i}),l=new it({rasterFunction:a});l.rasterJobHandler=this._rasterJobHandler.instance,await l.open(),this._cachedRasterFunctionJson=(n=this.rasterFunction)==null?void 0:n.toJSON(),this.raster=l}else this.raster=i}};function s(i){if(!i.raster||!i.rasterInfo)throw new $("imagery-tile","no raster")}return w([b()],e.prototype,"_cachedRendererJson",void 0),w([b()],e.prototype,"_cachedRasterFunctionJson",void 0),w([b()],e.prototype,"_compatibleFullExtent",void 0),w([b()],e.prototype,"_rasterJobHandler",void 0),w([b()],e.prototype,"bandIds",void 0),w([b({json:{origins:{service:{read:{source:"copyrightText"}}}}})],e.prototype,"copyright",void 0),w([b({json:{read:!1}})],e.prototype,"fullExtent",null),w([b()],e.prototype,"interpolation",void 0),w([b()],e.prototype,"ioConfig",void 0),w([b({type:[Ze]})],e.prototype,"multidimensionalDefinition",void 0),w([b({type:ot,json:{write:!0}})],e.prototype,"multidimensionalSubset",void 0),w([b()],e.prototype,"raster",void 0),w([b({type:lt})],e.prototype,"rasterFunction",void 0),w([b()],e.prototype,"rasterInfo",null),w([b()],e.prototype,"sourceJSON",void 0),w([b({json:{read:!1}})],e.prototype,"spatialReference",null),w([b({json:{read:!1}})],e.prototype,"tileInfo",null),w([b(Ke)],e.prototype,"url",null),w([b({types:qe})],e.prototype,"renderer",null),w([b()],e.prototype,"symbolizer",void 0),e=w([K("esri.layers.ImageryTileMixin")],e),e};function Ti(t){const e=t.fields,s=t.records,i=e.some(c=>c.name.toLowerCase()==="oid")?"OBJECTID":"OID",r=[{name:i,type:"esriFieldTypeOID",alias:"OID"}].concat(e.map(c=>({name:c.name,type:"esriFieldType"+c.typeName,alias:c.name}))),n=r.map(c=>c.name),a=[];let l=0,o=0;return s.forEach(c=>{const u={};for(u[i]=l++,o=1;o<n.length;o++)u[n[o]]=c[o-1];a.push({attributes:u})}),{displayFieldName:"",fields:r,features:a}}class rt{static get supportedVersions(){return[5]}static parse(e){const s=new DataView(e),i=3&s.getUint8(0);if(i!==3)return{header:{version:i},recordSet:null};const r=s.getUint32(4,!0),n=s.getUint16(8,!0),a=s.getUint16(10,!0),l={version:i,recordCount:r,headerByteCount:n,recordByteCount:a};let o=32;const c=[],u=[];let h;if(i===3){for(;s.getUint8(o)!==13;)h=String.fromCharCode(s.getUint8(o+11)).trim(),c.push({name:Ee(new Uint8Array(e,o,11)),type:h,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(h)],length:s.getUint8(o+16)}),o+=32;if(o+=1,c.length>0)for(;u.length<r&&e.byteLength-o>a;){const m=[];s.getUint8(o)===32?(o+=1,c.forEach(f=>{if(f.type==="C")m.push(Ee(new Uint8Array(e,o,f.length)).trim());else if(f.type==="N")m.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(e,o,f.length)).trim(),10));else if(f.type==="F")m.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(e,o,f.length)).trim()));else if(f.type==="D"){const y=String.fromCharCode.apply(null,new Uint8Array(e,o,f.length)).trim();m.push(new Date(parseInt(y.substring(0,4),10),parseInt(y.substring(4,6),10)-1,parseInt(y.substring(6,8),10)))}o+=f.length}),u.push(m)):o+=a}}return{header:l,fields:c,records:u,recordSet:Ti({fields:c,records:u})}}}const Z=new Map;Z.set("int16","esriFieldTypeSmallInteger"),Z.set("int32","esriFieldTypeInteger"),Z.set("int64","esriFieldTypeInteger"),Z.set("float32","esriFieldTypeSingle"),Z.set("float64","esriFieldTypeDouble"),Z.set("text","esriFieldTypeString");const je=8;let le=class extends ie{constructor(){super(...arguments),this.storageInfo=null,this.datasetFormat="CRF"}async open(t){await this.init();const{data:e}=await this.request(this.url+"/conf.json",{signal:t==null?void 0:t.signal});if(!this._validateHeader(e))throw new $("cloudraster:open","Invalid or unsupported conf.json.");this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{storageInfo:s,rasterInfo:i}=this._parseHeader(e);if(i.dataType==="thematic"){const r=await this._fetchAuxiliaryInformation();i.attributeTable=r}this._set("storageInfo",s),this._set("rasterInfo",i),this.ioConfig.retryCount=this.ioConfig.retryCount||0}async fetchRawTile(t,e,s,i={}){const{transposeInfo:r}=this.rasterInfo.storageInfo,{transposedVariableName:n}=i,a=!(!r||!n),l=a?0:this.rasterInfo.storageInfo.maximumPyramidLevel-t;if(l<0)return null;const o=this._buildCacheFilePath(l,e,s,i.multidimensionalDefinition,n),c=this._getIndexRecordFromBundle(e,s,a),u=await this.request(o,{range:{from:0,to:this.storageInfo.headerSize-1},responseType:"array-buffer",signal:i.signal});if(!u)return null;const h=new Uint8Array(u.data),m=this._getTileEndAndContentType(h,c);if(m.recordSize===0)return null;const f=await this.request(o,{range:{from:m.position,to:m.position+m.recordSize},responseType:"array-buffer",signal:i.signal});if(!f)return null;const[y,d]=this._getTileSize(a);return this.decodePixelBlock(f.data,{width:y,height:d,planes:null,pixelType:null,returnInterleaved:a})}_validateHeader(t){const e=["origin","extent","geodataXform","LODInfos","blockWidth","blockHeight","bandCount","pixelType","pixelSizeX","pixelSizeY","format","packetSize"];return t&&t.type==="RasterInfo"&&!e.some(s=>!t[s])}_parseHeader(t){var V;const e=["u1","u2","u4","u8","s8","u16","s16","u32","s32","f32","f64"][t.pixelType],{bandCount:s,histograms:i,colormap:r,blockWidth:n,blockHeight:a,firstPyramidLevel:l,maximumPyramidLevel:o}=t,c=t.statistics&&t.statistics.map(D=>({min:D.min,max:D.max,avg:D.mean,stddev:D.standardDeviation,median:D.median,mode:D.mode})),u=t.extent.spatialReference,h=(V=t.geodataXform)==null?void 0:V.spatialReference,m=new J(u!=null&&u.wkid||u!=null&&u.wkt?u:h);let f=new W({xmin:t.extent.xmin,ymin:t.extent.ymin,xmax:t.extent.xmax,ymax:t.extent.ymax,spatialReference:m});const y=new N({x:t.pixelSizeX,y:t.pixelSizeY,spatialReference:m}),d=Math.round((f.xmax-f.xmin)/y.x),p=Math.round((f.ymax-f.ymin)/y.y),g=this._parseTransform(t.geodataXform),x=g?f:null;g&&(f=g.forwardTransform(f),y.x=(f.xmax-f.xmin)/d,y.y=(f.ymax-f.ymin)/p);const I=t.properties??{},C=t.format.toLowerCase().replace("cache/",""),F=new N(t.origin.x,t.origin.y,m);let T,v,R,S;if(r&&r.colors)for(T=[],v=0;v<r.colors.length;v++)R=r.colors[v],S=r.values?r.values[v]:v,T.push([S,255&R,R<<16>>>24,R<<8>>>24,R>>>24]);const _=t.LODInfos,P=[];for(v=0;v<_.levels.length;v++)P.push({level:_.levels[v],resolution:_.resolutions[v],scale:96/.0254*_.resolutions[v]});const E=new he({dpi:96,lods:P,format:C,origin:F,size:[n,a],spatialReference:m}),j={recordSize:je,packetSize:t.packetSize,headerSize:t.packetSize*t.packetSize*je+64},H=[{maxCol:Math.ceil(d/n)-1,maxRow:Math.ceil(p/a)-1,minCol:0,minRow:0}];let B=2;if(o>0)for(v=0;v<o;v++)H.push({maxCol:Math.ceil(d/B/n)-1,maxRow:Math.ceil(p/B/a)-1,minCol:0,minRow:0}),B*=2;const L=t.mdInfo;let G=null;if(L&&I._yxs){const D=I._yxs;G={packetSize:D.PacketSize,tileSize:[D.TileXSize,D.TileYSize]}}return{storageInfo:j,rasterInfo:new pe({width:d,height:p,pixelType:e,bandCount:s,extent:f,nativeExtent:x,transform:g,spatialReference:m,pixelSize:y,keyProperties:I,statistics:c,histograms:i,multidimensionalInfo:L,colormap:T,storageInfo:new me({blockWidth:n,blockHeight:a,pyramidBlockWidth:n,pyramidBlockHeight:a,origin:F,tileInfo:E,transposeInfo:G,firstPyramidLevel:l,maximumPyramidLevel:o,blockBoundary:H})})}}_parseTransform(t){var s,i;if(!hi(t))throw new $("cloudraster:open","the data contains unsupported geodata transform types");const e=mi(t);if(e.type==="identity")return null;if(e.type!=="polynomial"||!((s=e.forwardCoefficients)!=null&&s.length)||!((i=e.inverseCoefficients)!=null&&i.length))throw new $("cloudraster:open","the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");return e}async _fetchAuxiliaryInformation(t){const e=this.request(this.url+"/conf.vat.json",{signal:t}).then(n=>n.data).catch(()=>null),s=this.request(this.url+"/conf.vat.dbf",{responseType:"array-buffer",signal:t}).then(n=>n.data).catch(()=>null),i=await Promise.all([e,s]);let r;if(i[0]){let n=i[0].fields;const a=i[0].values;if(n&&a){n=n.map(o=>({type:o.name==="OID"?"esriFieldTypeOID":Z.get(o.type),name:o.name,alias:o.alias||o.name}));const l=a.map(o=>({attributes:o}));n&&a&&(r={fields:n,features:l})}}return!r&&i[1]&&(r=rt.parse(i[1]).recordSet),tt.fromJSON(r)}_buildCacheFilePath(t,e,s,i,r){const n=this._getPackageSize(!!r),a=Math.floor(e/n)*n,l=Math.floor(s/n)*n,o="R"+this._toHexString4(a)+"C"+this._toHexString4(l);let c="L";c+=t>=10?t.toString():"0"+t.toString();const{multidimensionalInfo:u}=this.rasterInfo,h=i==null?void 0:i[0];if(M(u)||!h)return`${this.url}/_alllayers/${c}/${o}.bundle`;let m="_yxs";if(!r){m=u.variables.find(d=>d.name===h.variableName).dimensions[0].values.indexOf(h.values[0]).toString(16);const y=4-m.length;for(let d=0;d<y;d++)m="0"+m;m="S"+m}const f=this._getVariableFolderName(r||h.variableName);return`${this.url}/_alllayers/${f}/${m}/${c}/${o}.bundle`}_getPackageSize(t=!1){const{transposeInfo:e}=this.rasterInfo.storageInfo;return t&&k(e)?e.packetSize??0:this.storageInfo.packetSize}_getTileSize(t=!1){const{storageInfo:e}=this.rasterInfo,{transposeInfo:s}=e;return t&&k(s)?s.tileSize:e.tileInfo.size}_getVariableFolderName(t){return(t=t.trim())===""?"_v":t.replace(/[\{|\}\-]/g,"_").replace("\\*","_v")}_getIndexRecordFromBundle(t,e,s=!1){const i=this._getPackageSize(s),r=i*(t%i)+e%i;if(r<0)throw"Invalid level / row / col";return 20+r*this.storageInfo.recordSize+44}_getTileEndAndContentType(t,e){const s=t.subarray(e,e+8);let i,r=0;for(i=0;i<5;i++)r|=(255&s[i])<<8*i;const n=0xffffffffff&r;for(r=0,i=5;i<8;i++)r|=(255&s[i])<<8*(i-5);return{position:n,recordSize:0xffffffffff&r}}_toHexString4(t){let e=t.toString(16);if(e.length!==4){let s=4-e.length;for(;s-- >0;)e="0"+e}return e}};w([b({readOnly:!0})],le.prototype,"storageInfo",void 0),w([b({type:String,json:{write:!0}})],le.prototype,"datasetFormat",void 0),le=w([K("esri.layers.support.rasterDatasets.CloudRaster")],le);const Ri=le;let ce=class extends ie{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.data=null}async open(t){await this.init();const e=this.data,{pixelBlock:s,statistics:i,histograms:r,name:n,keyProperties:a,nativeExtent:l,transform:o}=this.data,{width:c,height:u,pixelType:h}=s,m=e.extent??new W({xmin:-.5,ymin:.5,xmax:c-.5,ymax:u-.5,spatialReference:new J({wkid:3857})}),f=e.isPseudoSpatialReference??!e.extent,y={x:m.width/c,y:m.height/u},d=new pe({width:c,height:u,pixelType:h,extent:m,nativeExtent:l,transform:o,pixelSize:y,spatialReference:m.spatialReference,bandCount:3,keyProperties:a||{},statistics:i,isPseudoSpatialReference:f,histograms:r});this.createRemoteDatasetStorageInfo(d,512,512),this._set("rasterInfo",d),this.updateTileInfo(),await this._buildInMemoryRaster(s,{width:512,height:512},t),this.datasetName=n,this.url="/InMemory/"+n}fetchRawTile(t,e,s,i={}){const r=this._pixelBlockTiles.get(`${t}/${e}/${s}`);return Promise.resolve(r)}async _buildInMemoryRaster(t,e,s){var c,u;const i=this.rasterInfo.storageInfo.maximumPyramidLevel,r=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:t,tileSize:e,maximumPyramidLevel:i},s):Promise.resolve(ti(t,e,i)),n=k(this.rasterInfo.statistics),a=k(this.rasterInfo.histograms),l=n?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:t},s):Promise.resolve(Wt(t)),o=await Ve([r,l]);if(!o[0].value&&o[1].value)throw new $("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=o[0].value,n||(this.rasterInfo.statistics=(c=o[1].value)==null?void 0:c.statistics),a||(this.rasterInfo.histograms=(u=o[1].value)==null?void 0:u.histograms)}};w([b({type:String,json:{write:!0}})],ce.prototype,"datasetFormat",void 0),w([b()],ce.prototype,"data",void 0),ce=w([K("esri.layers.support.rasterDatasets.InMemoryRaster")],ce);const _i=ce;function ne(t,e){if(!t||!e)return[];let s=e;e.includes("/")?(s=e.slice(0,e.indexOf("/")),e=e.slice(e.indexOf("/")+1)):e="";const i=[];if(e){const n=ne(t,s);for(let a=0;a<n.length;a++)ne(n[a],e).forEach(l=>i.push(l));return i}const r=t.getElementsByTagNameNS("*",s);if(!r||r.length===0)return[];for(let n=0;n<r.length;n++)i.push(r[n]||r.item[n]);return i}function A(t,e){if(!t||!e)return null;let s=e;e.includes("/")?(s=e.slice(0,e.indexOf("/")),e=e.slice(e.indexOf("/")+1)):e="";const i=ne(t,s);return i.length>0?e?A(i[0],e):i[0]:null}function Y(t,e=null){const s=e?A(t,e):t;let i;return s?(i=s.textContent||s.nodeValue,i?i.trim():null):null}function ki(t,e){const s=ne(t,e),i=[];let r;for(let n=0;n<s.length;n++)r=s[n].textContent||s[n].nodeValue,r&&(r=r.trim(),r!==""&&i.push(r));return i}function Ie(t,e){return ki(t,e).map(s=>Number(s))}function te(t,e){const s=Y(t,e);return Number(s)}function _e(t,e){var r;const s=(r=t==null?void 0:t.nodeName)==null?void 0:r.toLowerCase(),i=e.toLowerCase();return s.slice(s.lastIndexOf(":")+1)===i}function Ge(t,e){if(!t||!e)return null;const s=[];for(let i=0;i<t.length;i++)s.push(t[i]),s.push(e[i]);return s}function Ci(t){const e=A(t,"GeodataXform"),s=Se(te(e,"SpatialReference/WKID")||Y(e,"SpatialReference/WKT"));if(e.getAttribute("xsi:type")!=="typens:PolynomialXform")return{spatialReference:s,transform:null};const i=te(e,"PolynomialOrder")??1,r=Ie(e,"CoeffX/Double"),n=Ie(e,"CoeffY/Double"),a=Ie(e,"InverseCoeffX/Double"),l=Ie(e,"InverseCoeffY/Double"),o=Ge(r,n),c=Ge(a,l);return{spatialReference:s,transform:o&&c&&o.length&&c.length?new Pe({spatialReference:s,polynomialOrder:i,forwardCoefficients:o,inverseCoefficients:c}):null}}function Fi(t){var m;const e=te(t,"NoDataValue"),s=A(t,"Histograms/HistItem"),i=te(s,"HistMin"),r=te(s,"HistMax"),n=te(s,"BucketCount"),a=(m=Y(s,"HistCounts"))==null?void 0:m.split("|").map(f=>Number(f));let l,o,c,u;ne(t,"Metadata/MDI").forEach(f=>{const y=Number(f.textContent??f.nodeValue);switch(f.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":l=y;break;case"STATISTICS_MAXIMUM":o=y;break;case"STATISTICS_MEAN":c=y;break;case"STATISTICS_STDDEV":u=y}});const h=te(t,"Metadata/SourceBandIndex");return{noDataValue:e,histogram:a!=null&&a.length&&i!=null&&r!=null?{min:i,max:r,size:n||a.length,counts:a}:null,sourceBandIndex:h,statistics:l!=null&&o!=null?{min:l,max:o,avg:c,stddev:u}:null}}function Se(t){if(!t)return null;let e=Number(t);if(!isNaN(e)&&e!==0)return new J({wkid:e});if((t=String(t)).startsWith("COMPD_CS")){if(!t.includes("VERTCS")||!t.includes("GEOGCS")&&!t.startsWith("PROJCS"))return null;const s=t.indexOf("VERTCS"),i=t.indexOf("PROJCS"),r=i>-1?i:t.indexOf("GEOGCS");if(r===-1)return null;const n=t.slice(r,t.lastIndexOf("]",s)+1).trim(),a=t.slice(s,t.lastIndexOf("]")).trim();e=ke(n);const l=new J(e?{wkid:e}:{wkt:n}),o=ke(a);return o&&(l.vcsWkid=o),l}return t.startsWith("GEOGCS")||t.startsWith("PROJCS")?(e=ke(t),new J(e!==0?{wkid:e}:{wkt:t})):null}function ke(t){var r;const e=t.replace(/\]/g,"[").replace(/\"/g,"").split("[").map(n=>n.trim()).filter(n=>n!==""),s=e[e.length-1].split(","),i=(r=s[0])==null?void 0:r.toLowerCase();if((i==="epsg"||i==="esri")&&t.endsWith('"]]')){const n=Number(s[1]);if(!isNaN(n)&&n!==0)return n}return 0}function Me(t){var i;if(((i=t==null?void 0:t.documentElement.tagName)==null?void 0:i.toLowerCase())!=="pamdataset")return{};const e={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};t.documentElement.childNodes.forEach(r=>{if(r.nodeType===1){if(_e(r,"SRS")){if(!e.spatialReference){const n=Y(r);e.spatialReference=Se(n)}}else if(_e(r,"Metadata"))if(r.getAttribute("domain")==="xml:ESRI"){const{spatialReference:n,transform:a}=Ci(r);e.transform=a,e.spatialReference||(e.spatialReference=n)}else ne(r,"MDI").forEach(n=>e.metadata[n.getAttribute("key")]=Y(n));else if(_e(r,"PAMRasterBand")){const n=Fi(r);n.sourceBandIndex!=null&&e.rasterBands[n.sourceBandIndex]==null?e.rasterBands[n.sourceBandIndex]=n:e.rasterBands.push(n)}}});const s=e.rasterBands;if(s.length){const r=!!s[0].statistics;e.statistics=r?s.map(a=>a.statistics).filter(k):null;const n=!!s[0].histogram;e.histograms=n?s.map(a=>a.histogram).filter(k):null}return e}let be=class extends ie{async open(t){await this.init();const e=await this._fetchData(t);let{spatialReference:s,statistics:i,histograms:r,transform:n}=await this._fetchAuxiliaryData(t);const a=!s;a&&(s=new J({wkid:3857})),r!=null&&r.length&&i==null&&(i=Fe(r));const{width:l,height:o}=e;let c=new W({xmin:-.5,ymin:.5-o,xmax:l-.5,ymax:.5,spatialReference:s});const u=n?n.forwardTransform(c):c;let h=!0;if(n){const f=n.forwardCoefficients;h=f&&f[1]===0&&f[2]===0,h&&(n=null,c=u)}const m=new _i({data:{extent:u,nativeExtent:c,transform:n,pixelBlock:e,statistics:i,histograms:r,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:a}});await m.open(),m.data=null,this._set("rasterInfo",m.rasterInfo),this._inMemoryRaster=m}fetchRawTile(t,e,s,i={}){return this._inMemoryRaster.fetchRawTile(t,e,s,i)}async _fetchData(t){const{data:e}=await this.request(this.url,{responseType:"array-buffer",signal:t==null?void 0:t.signal}),s=jt(e).toUpperCase();if(s!=="JPG"&&s!=="PNG"&&s!=="GIF"&&s!=="BMP")throw new $("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",s);const i=s.toLowerCase(),r=i==="gif"||i==="bmp"||!Ii("ios");return await this.decodePixelBlock(e,{format:i,useCanvas:r,hasNoZlibMask:!0})}async _fetchAuxiliaryData(t){var c;const e=U(t==null?void 0:t.signal),s=this.ioConfig.skipExtensions??[],i=s.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:e}),r=this.datasetFormat,n=r==="JPG"?"jgw":r==="PNG"?"pgw":r==="BMP"?"bpw":null,a=n&&s.includes(n)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+n,{responseType:"text",signal:e}),l=await Ve([i,a]);if(e!=null&&e.aborted)throw bt();const o=Me((c=l[0].value)==null?void 0:c.data);if(!o.transform){const u=l[1].value?l[1].value.data.split(`
`).slice(0,6).map(h=>Number(h)):null;o.transform=(u==null?void 0:u.length)===6?new Pe({forwardCoefficients:[u[4],u[5],u[0],-u[1],u[2],-u[3]]}):null}return o}};w([b({type:String,json:{write:!0}})],be.prototype,"datasetFormat",void 0),be=w([K("esri.layers.support.rasterDatasets.ImageAuxRaster")],be);const we=be;let ue=class extends ie{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async open(e){var T,v;await this.init();const s=e&&e.signal,i=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:s});i.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const r=i.data;if(this.sourceJSON=r,!r)throw new $("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!r.tileInfo)throw new $("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();const n=["jpg","jpeg","png","png8","png24","png32","mixed"];this.tileType=r.cacheType,this.tileType==null&&(n.includes(r.tileInfo.format.toLowerCase())?this.tileType="Map":r.tileInfo.format.toLowerCase()==="lerc"?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=((T=r.name)==null?void 0:T.slice(r.name.indexOf("/")+1))??"";const a=await this._fetchRasterInfo({signal:s});if(M(a))throw new $("image-server-raster:open","cannot initialize image service");const l=this.tileType==="Map"?wi(r.tileInfo,r):he.fromJSON(r.tileInfo);xt(l);const[o,c]=this._computeMinMaxLOD(a,l),{extent:u,pixelSize:h}=a,m=.5/a.width*h.x,f=Math.max(h.x,h.y),{lods:y}=l;(this.tileType!=="Map"&&r.maxScale!==0||Math.abs(h.x-h.y)>m||!y.some(R=>Math.abs(R.resolution-f)<m))&&(h.x=h.y=o.resolution,a.width=Math.ceil((u.xmax-u.xmin)/h.x-.1),a.height=Math.ceil((u.ymax-u.ymin)/h.y-.1));const d=o.level-c.level,[p,g]=l.size,x=[];y.forEach(R=>{R.level>=c.level&&R.level<=o.level&&x.push({x:R.resolution,y:R.resolution})}),x.sort((R,S)=>R.x-S.x);const I=this.computeBlockBoundary(u,p,g,l.origin,x,d),C=x.length>1?x.slice(1):null;let F;if(r.transposeInfo&&(F={tileSize:[r.transposeInfo.rows,r.transposeInfo.cols],packetSize:((v=a.keyProperties)==null?void 0:v._yxs.PacketSize)??0}),a.storageInfo=new me({blockWidth:l.size[0],blockHeight:l.size[1],pyramidBlockWidth:l.size[0],pyramidBlockHeight:l.size[1],pyramidResolutions:C,compression:l.format,origin:l.origin,firstPyramidLevel:1,maximumPyramidLevel:d,tileInfo:l,transposeInfo:F,blockBoundary:I}),this._fixGCSShift(a),this._set("rasterInfo",a),r.capabilities.toLowerCase().includes("tilemap")){const R={tileInfo:a.storageInfo.tileInfo,parsedUrl:$t(this.url),url:this.url,tileServers:[],type:"tile"};this._tilemapCache=new bi({layer:R})}}async fetchRawTile(e,s,i,r={}){const{storageInfo:n,extent:a}=this.rasterInfo,{transposeInfo:l}=n,o=k(l)&&!!r.transposedVariableName;if(this._slices&&!o&&r.sliceId==null)return null;const c=o?0:n.maximumPyramidLevel-e+this._levelOffset,u=`${this.url}/tile/${c}/${s}/${i}`,h=this._slices?o?{variable:r.transposedVariableName}:{sliceId:r.sliceId||0}:null,{data:m}=await this.request(u,{query:h,responseType:"array-buffer",signal:r.signal});if(!m)return null;const f=o?l.tileSize:n.tileInfo.size,y=await this.decodePixelBlock(m,{width:f[0],height:f[1],planes:null,pixelType:null,isPoint:this.tileType==="Elevation",returnInterleaved:o}),d=n.blockBoundary[e];if(n.compression!=="jpg"||i>d.minCol&&i<d.maxCol&&s>d.minRow&&s<d.maxRow)return y;const{origin:p,blockWidth:g,blockHeight:x}=n,{x:I,y:C}=this.getPyramidPixelSize(e),F=Math.round((a.xmin-p.x)/I)%g,T=Math.round((a.xmax-p.x)/I)%g||g,v=Math.round((p.y-a.ymax)/C)%x,R=Math.round((p.y-a.ymin)/C)%x||x,S=i===d.minCol?F:0,_=s===d.minRow?v:0,P=i===d.maxCol?T:g,E=s===d.maxRow?R:x;return ii(y,{x:S,y:_},{width:P-S,height:E-_}),y}getSliceIndex(e){if(!this._slices||M(e)||e.length===0)return null;const s=e;for(let i=0;i<this._slices.length;i++){const r=this._slices[i].multidimensionalDefinition;if(r.length===s.length&&!r.some(n=>{const a=s.find(l=>n.variableName===l.variableName&&l.dimensionName===n.dimensionName);return a?(Array.isArray(n.values[0])?`${n.values[0][0]}-${n.values[0][1]}`:n.values[0])!==(Array.isArray(a.values[0])?`${a.values[0][0]}-${a.values[0][1]}`:a.values[0]):!0}))return i}return null}async fetchVariableStatisticsHistograms(e,s){const i=this.request(this.url+"/statistics",{query:{variable:e,f:"json"},signal:s}).then(a=>{var l;return(l=a.data)==null?void 0:l.statistics}),r=this.request(this.url+"/histograms",{query:{variable:e,f:"json"},signal:s}).then(a=>{var l;return(l=a.data)==null?void 0:l.histograms}),n=await Promise.all([i,r]);return n[0]&&n[0].forEach(a=>{a.avg=a.mean,a.stddev=a.standardDeviation}),{statistics:n[0]||null,histograms:n[1]||null}}async computeBestPyramidLevelForLocation(e,s={}){if(!this._tilemapCache)return 0;let i=this.identifyPixelLocation(e,0,U(s.datumTransformation));if(i===null)return null;let r=0;const{maximumPyramidLevel:n}=this.rasterInfo.storageInfo;let a=n-r+this._levelOffset;const l=i.srcLocation;for(;a>=0;){try{if(await this._tilemapCache.fetchAvailability(a,i.row,i.col,s)==="available")break}catch{}if(a--,r++,i=this.identifyPixelLocation(l,r,U(s.datumTransformation)),i===null)return null}return a===-1||i==null?null:r}async _fetchRasterInfo(e){const s=this.sourceJSON;if(this.tileType==="Map"){const l=s.fullExtent||s.extent,o=Math.ceil((l.xmax-l.xmin)/s.pixelSizeX-.1),c=Math.ceil((l.ymax-l.ymin)/s.pixelSizeY-.1),u=J.fromJSON(s.spatialReference||l.spatialReference),h=new N({x:s.pixelSizeX,y:s.pixelSizeY,spatialReference:u});return new pe({width:o,height:c,bandCount:3,extent:W.fromJSON(l),spatialReference:u,pixelSize:h,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:i}=e,r=mt(this.url,this.sourceJSON,{signal:i,query:this.ioConfig.customFetchParameters}),n=s.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:i}).then(l=>l.data&&l.data.slices).catch(()=>null):null,a=await Promise.all([r,n]);return this._slices=a[1],a[0]}_fixScaleInServiceInfo(){const{sourceJSON:e}=this;e.minScale&&e.minScale<0&&(e.minScale=0),e.maxScale&&e.maxScale<0&&(e.maxScale=0)}_fixGCSShift(e){const{extent:s,spatialReference:i}=e;s.xmin>-1&&s.xmax>181&&(i!=null&&i.wkid)&&i.isGeographic&&(e.nativeExtent=e.extent,e.transform=new pi,e.extent=e.transform.forwardTransform(s))}_computeMinMaxLOD(e,s){const{pixelSize:i}=e,r=.5/e.width*i.x,{lods:n}=s,a=s.lodAt(Math.max.apply(null,n.map(f=>f.level))),l=s.lodAt(Math.min.apply(null,n.map(f=>f.level))),{tileType:o}=this;if(o==="Map")return this._levelOffset=n[0].level,[a,l];if(o==="Raster")return[n.find(f=>f.resolution===i.x)??a,l];const{minScale:c,maxScale:u}=this.sourceJSON;let h=a;u>0&&(h=n.find(f=>Math.abs(f.scale-u)<r),h||(h=n.filter(f=>f.scale>u).sort((f,y)=>f.scale>y.scale?1:-1)[0]??a));let m=l;return c>0&&(m=n.find(f=>Math.abs(f.scale-c)<r)??l,this._levelOffset=m.level-l.level),[h,m]}};w([b({type:String,json:{write:!0}})],ue.prototype,"datasetFormat",void 0),w([b()],ue.prototype,"tileType",void 0),ue=w([K("esri.layers.support.rasterDatasets.ImageServerRaster")],ue);const Pi=ue,X=new Map;X.set("Int8","s8"),X.set("UInt8","u8"),X.set("Int16","s16"),X.set("UInt16","u16"),X.set("Int32","s32"),X.set("UInt32","u32"),X.set("Float32","f32"),X.set("Float64","f32"),X.set("Double64","f32");const Q=new Map;Q.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),Q.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),Q.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),Q.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let se=class extends ie{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(t){var d;await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const e=t?U(t.signal):null,s=await this.request(this.url,{responseType:"xml",signal:e}),{rasterInfo:i,files:r}=this._parseHeader(s.data);if(((d=this.ioConfig.skipExtensions)==null?void 0:d.indexOf("aux.xml"))===-1){const p=await this._fetchAuxiliaryData(t);p!=null&&(i.statistics=p.statistics??i.statistics,i.histograms=p.histograms,p.histograms&&M(i.statistics)&&(i.statistics=Fe(p.histograms)))}this._set("rasterInfo",i),this._files=r;const n=await this.request(r.index,{responseType:"array-buffer",signal:e});this._storageIndex=this._parseIndex(n.data);const{blockWidth:a,blockHeight:l}=this.rasterInfo.storageInfo,o=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:c,height:u}=this.rasterInfo,h=[],m=this._getBandSegmentCount();let f=0,y=-1;for(;f<this._storageIndex.length;){y++;const p=Math.ceil(c/a/o**y)-1,g=Math.ceil(u/l/o**y)-1;f+=(p+1)*(g+1)*m*4,h.push({maxRow:g,maxCol:p,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=h,y>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=y),this.updateTileInfo()}async fetchRawTile(t,e,s,i={}){const{blockWidth:r,blockHeight:n,blockBoundary:a}=this.rasterInfo.storageInfo,l=a[t];if(!l||l.maxRow<e||l.maxCol<s||l.minRow>e||l.minCol>s)return null;const{bandCount:o,pixelType:c}=this.rasterInfo,{ranges:u,actualTileWidth:h,actualTileHeight:m}=this._getTileLocation(t,e,s);if(!u||u.length===0)return null;if(u[0].from===0&&u[0].to===0){const S=new Uint8Array(r*n);return new ri({width:r,height:n,pixels:null,mask:S,validPixelCount:0})}const{bandIds:f}=this.ioConfig,y=this._getBandSegmentCount(),d=[];let p=0;for(p=0;p<y;p++)(!f||f.indexOf[p]>-1)&&d.push(this.request(this._files.data,{range:{from:u[p].from,to:u[p].to},responseType:"array-buffer",signal:i.signal}));const g=await Promise.all(d),x=g.map(S=>S.data.byteLength).reduce((S,_)=>S+_),I=new Uint8Array(x);let C=0;for(p=0;p<y;p++)I.set(new Uint8Array(g[p].data),C),C+=g[p].data.byteLength;const F=Q.get(this.rasterInfo.storageInfo.compression).decoderFormat,T=await this.decodePixelBlock(I.buffer,{width:r,height:n,format:F,planes:(f==null?void 0:f.length)||o,pixelType:c});if(k(this.rasterInfo.noDataValue)&&F!=="lerc"&&!T.mask){const S=this.rasterInfo.noDataValue[0];if(S!=null){const _=T.width*T.height,P=new Uint8Array(_);if(Math.abs(S)>1e24)for(p=0;p<_;p++)Math.abs((T.pixels[0][p]-S)/S)>1e-6&&(P[p]=1);else for(p=0;p<_;p++)T.pixels[0][p]!==S&&(P[p]=1);T.mask=P}}let v=0,R=0;if(h!==r||m!==n){let S=T.mask;if(S)for(p=0;p<n;p++)if(R=p*r,p<m)for(v=h;v<r;v++)S[R+v]=0;else for(v=0;v<r;v++)S[R+v]=0;else for(S=new Uint8Array(r*n),T.mask=S,p=0;p<m;p++)for(R=p*r,v=0;v<h;v++)S[R+v]=1}return T}_parseIndex(t){if(t.byteLength%16>0)throw"invalid array buffer must be multiples of 16";let e,s,i,r,n,a;if(Gt){for(s=new Uint8Array(t),r=new ArrayBuffer(t.byteLength),i=new Uint8Array(r),n=0;n<t.byteLength/4;n++)for(a=0;a<4;a++)i[4*n+a]=s[4*n+3-a];e=new Uint32Array(r)}else e=new Uint32Array(t);return e}_getBandSegmentCount(){return Q.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(t,e,s){const{blockWidth:i,blockHeight:r,pyramidScalingFactor:n}=this.rasterInfo.storageInfo,{width:a,height:l}=this.rasterInfo,o=this._getBandSegmentCount();let c,u,h,m=0,f=0;for(h=0;h<t;h++)f=n**h,c=Math.ceil(a/i/f),u=Math.ceil(l/r/f),m+=c*u;f=n**t,c=Math.ceil(a/i/f),u=Math.ceil(l/r/f),m+=e*c+s,m*=4*o;const y=this._storageIndex.subarray(m,m+4*o);let d=0,p=0;const g=[];for(let x=0;x<o;x++)d=y[4*x+0]*2**32+y[4*x+1],p=d+y[4*x+2]*2**32+y[4*x+3],g.push({from:d,to:p});return{ranges:g,actualTileWidth:s<c-1?i:Math.ceil(a/f)-i*(c-1),actualTileHeight:e<u-1?r:Math.ceil(l/f)-r*(u-1)}}_parseHeader(t){const e=A(t,"MRF_META/Raster");if(!e)throw new $("mrf:open","not a valid MRF format");const s=A(e,"Size"),i=parseInt(s.getAttribute("x"),10),r=parseInt(s.getAttribute("y"),10),n=parseInt(s.getAttribute("c"),10),a=(Y(e,"Compression")||"none").toLowerCase();if(!Q.has(a))throw new $("mrf:open","currently does not support compression "+a);const l=Y(e,"DataType")||"UInt8",o=X.get(l);if(o==null)throw new $("mrf:open","currently does not support pixel type "+l);const c=A(e,"PageSize"),u=parseInt(c.getAttribute("x"),10),h=parseInt(c.getAttribute("y"),10),m=A(e,"DataValues");let f,y;if(m&&(y=m.getAttribute("NoData"),y!=null&&(f=y.trim().split(" ").map(P=>parseFloat(P)))),A(t,"MRF_META/CachedSource"))throw new $("mrf:open","currently does not support MRF referencing other data files");const d=A(t,"MRF_META/GeoTags"),p=A(d,"BoundingBox");let g,x=!1;if(p!=null){const P=parseFloat(p.getAttribute("minx")),E=parseFloat(p.getAttribute("miny")),j=parseFloat(p.getAttribute("maxx")),H=parseFloat(p.getAttribute("maxy")),B=Y(d,"Projection")||"";let L=J.WGS84;if(B!=="LOCAL_CS[]")if(B.toLowerCase().startsWith("epsg:")){const G=Number(B.slice(5));isNaN(G)||G===0||(L=new J({wkid:G}))}else L=Se(B)??J.WGS84;else x=!0,L=new J({wkid:3857});g=new W(P,E,j,H),g.spatialReference=L}else x=!0,g=new W({xmin:-.5,ymin:.5-r,xmax:i-.5,ymax:.5,spatialReference:new J({wkid:3857})});const I=A(t,"MRF_META/Rsets"),C=parseInt(I&&I.getAttribute("scale")||"2",10),F=g.spatialReference,T=new me({origin:new N({x:g.xmin,y:g.ymax,spatialReference:F}),blockWidth:u,blockHeight:h,pyramidBlockWidth:u,pyramidBlockHeight:h,compression:a,pyramidScalingFactor:C}),v=new N({x:g.width/i,y:g.height/r,spatialReference:F}),R=new pe({width:i,height:r,extent:g,isPseudoSpatialReference:x,spatialReference:F,bandCount:n,pixelType:o,pixelSize:v,noDataValue:f,storageInfo:T}),S=Y(t,"datafile"),_=Y(t,"IndexFile");return{rasterInfo:R,files:{mrf:this.url,index:_||this.url.replace(".mrf",".idx"),data:S||this.url.replace(".mrf",Q.get(a).blobExtension)}}}async _fetchAuxiliaryData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:t==null?void 0:t.signal});return Me(e)}catch{return null}}};w([b()],se.prototype,"_files",void 0),w([b()],se.prototype,"_storageIndex",void 0),w([b({type:String,json:{write:!0}})],se.prototype,"datasetFormat",void 0),se=w([K("esri.layers.support.rasterIO.MRFRaster")],se);const Mi=se,Ce=(t,e)=>{var s;return(s=t.get(e))==null?void 0:s.values},oe=(t,e)=>{var s,i;return(i=(s=t.get(e))==null?void 0:s.values)==null?void 0:i[0]};let ee=class extends ie{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async open(t){await this.init();const e=t?U(t.signal):null,{data:s}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:e});if(!s)throw new $("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{littleEndian:i,firstIFDPos:r,isBigTiff:n}=qt(s),a=[];await this._readIFDs(a,s,i,r,0,n?8:4,e);const{imageInfo:l,rasterInfo:o}=this._parseIFDs(a);if(this._headerInfo={littleEndian:i,isBigTiff:n,ifds:a,...l},this._set("rasterInfo",o),!l.isSupported)throw new $("tiffraster:open","this tiff is not supported: "+l.message);if(!l.tileWidth)throw new $("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");const{skipExtensions:c=[]}=this.ioConfig;if(!c.includes("aux.xml")){const u=await this._fetchAuxiliaryMetaData(t);u!=null&&this._processPAMInfo(u,o)}c.includes("vat.dbf")||o.bandCount!==1||o.pixelType!=="u8"||(o.attributeTable=await this._fetchAuxiliaryTable(t),k(o.attributeTable)&&(o.keyProperties.DataType="thematic")),this.updateTileInfo()}async fetchRawTile(t,e,s,i={}){var F;if(!((F=this._headerInfo)!=null&&F.isSupported)||this.isBlockOutside(t,e,s))return null;const r=this._getTileLocation(t,e,s);if(!r)return null;const{ranges:n,actualTileWidth:a,actualTileHeight:l,ifd:o}=r,c=n.map(T=>this.request(this.url,{range:T,responseType:"array-buffer",signal:i.signal})),u=await Promise.all(c),h=u.map(T=>T.data.byteLength).reduce((T,v)=>T+v),m=u.length===1?u[0].data:new ArrayBuffer(h),f=[0],y=[0];if(u.length>1){const T=new Uint8Array(m);for(let v=0,R=0;v<u.length;v++){const S=u[v].data;T.set(new Uint8Array(S),R),f[v]=R,R+=S.byteLength,y[v]=S.byteLength}}const{blockWidth:d,blockHeight:p}=this.getBlockWidthHeight(t),g=await this.decodePixelBlock(m,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:o,offsets:f,sizes:y},width:d,height:p,planes:null,pixelType:null});let x,I,C;if(a!==d||l!==p){let T=g.mask;if(T)for(x=0;x<p;x++)if(C=x*d,x<l)for(I=a;I<d;I++)T[C+I]=0;else for(I=0;I<d;I++)T[C+I]=0;else for(T=new Uint8Array(d*p),g.mask=T,x=0;x<l;x++)for(C=x*d,I=0;I<a;I++)T[C+I]=1}return g}_parseIFDs(t){var E,j;const e=Ut(t),{width:s,height:i,tileWidth:r,tileHeight:n,planes:a,pixelType:l,compression:o,firstPyramidLevel:c,maximumPyramidLevel:u,pyramidBlockWidth:h,pyramidBlockHeight:m,tileBoundary:f,affine:y,metadata:d}=e,p=((E=e.extent.spatialReference)==null?void 0:E.wkt)||((j=e.extent.spatialReference)==null?void 0:j.wkid);let g=Se(p),x=!1;g==null&&(x=!0,g=new J({wkid:3857}));const I=new W({...e.extent,spatialReference:g}),C=new N(I?{x:I.xmin,y:I.ymax,spatialReference:g}:{x:0,y:0}),F=new me({blockWidth:r,blockHeight:n,pyramidBlockWidth:h,pyramidBlockHeight:m,compression:o,origin:C,firstPyramidLevel:c,maximumPyramidLevel:u,blockBoundary:f}),T=new N({x:(I.xmax-I.xmin)/s,y:(I.ymax-I.ymin)/i,spatialReference:g}),v=d?{BandProperties:d.bandProperties,DataType:d.dataType}:{};let R=null;const S=oe(t[0],"PHOTOMETRICINTERPRETATION"),_=Ce(t[0],"COLORMAP");if(S===3&&(_==null?void 0:_.length)>3&&_.length%3==0){R=[];const H=_.length/3;for(let B=0;B<H;B++)R.push([B,_[B]>>>8,_[B+H]>>>8,_[B+2*H]>>>8])}const P=new pe({width:s,height:i,bandCount:a,pixelType:l,pixelSize:T,storageInfo:F,spatialReference:g,isPseudoSpatialReference:x,keyProperties:v,extent:I,colormap:R,statistics:d?d.statistics:null});return y!=null&&y.length&&(P.nativeExtent=new W({xmin:-.5,ymin:.5-i,xmax:s-.5,ymax:.5,spatialReference:g}),P.transform=new Pe({polynomialOrder:1,forwardCoefficients:[y[2]+y[0]/2,y[5]-y[3]/2,y[0],y[3],-y[1],-y[4]]}),P.extent=P.transform.forwardTransform(P.nativeExtent),P.pixelSize=new N({x:(I.xmax-I.xmin)/s,y:(I.ymax-I.ymin)/i,spatialReference:g}),F.origin.x=-.5,F.origin.y=.5),{imageInfo:e,rasterInfo:P}}_processPAMInfo(t,e){if(e.statistics=t.statistics??e.statistics,e.histograms=t.histograms,t.histograms&&M(e.statistics)&&(e.statistics=Fe(t.histograms)),t.transform&&M(e.transform)){e.transform=t.transform,e.nativeExtent=e.extent;const s=e.transform.forwardTransform(e.nativeExtent);e.pixelSize=new N({x:(s.xmax-s.xmin)/e.width,y:(s.ymax-s.ymin)/e.height,spatialReference:e.spatialReference}),e.extent=s}e.spatialReference||(e.spatialReference=t.spatialReference)}async _readIFDs(t,e,s,i,r,n=4,a){if(!i)return null;(i>=e.byteLength||i<0)&&(e=(await this.request(this.url,{range:{from:i+r,to:i+r+this._bufferSize},responseType:"array-buffer",signal:a})).data,r=i+r,i=0);const l=await this._readIFD(e,s,i,r,ye.TIFF_TAGS,n,a);if(t.push(l.ifd),!l.nextIFD)return null;await this._readIFDs(t,e,s,l.nextIFD-r,r,n,a)}async _readIFD(t,e,s,i,r=ye.TIFF_TAGS,n=4,a){var o,c;if(!t)return null;const l=Vt(t,e,s,i,r,n);if(l.success){const u=[];if((o=l.ifd)==null||o.forEach(h=>{h.values||u.push(h)}),u.length>0){const h=u.map(f=>f.offlineOffsetSize).filter(k),m=Math.min.apply(null,h.map(f=>f[0]));if(Math.min.apply(null,h.map(f=>f[0]+f[1]))-m<=this._bufferSize){const{data:f}=await this.request(this.url,{range:{from:m,to:m+this._bufferSize},responseType:"array-buffer",signal:a});t=f,i=m,u.forEach(y=>Xt(t,e,y,i))}}if((c=l.ifd)!=null&&c.has("GEOKEYDIRECTORY")){const h=l.ifd.get("GEOKEYDIRECTORY"),m=h==null?void 0:h.values;if(m&&m.length>4){const f=m[0]+"."+m[1]+"."+m[2],y=await this._readIFD(t,e,h.valueOffset+6-i,i,ye.GEO_KEYS,2,a);h.data=y.ifd,h.data&&h.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[f]})}}return l}if(l.requiredBufferSize&&l.requiredBufferSize!==t.byteLength)return(t=(await this.request(this.url,{range:{from:i,to:i+l.requiredBufferSize+4},responseType:"array-buffer",signal:a})).data).byteLength<l.requiredBufferSize?null:this._readIFD(t,e,0,i,ye.TIFF_TAGS,4,a)}_getTileLocation(t,e,s){var v;const{firstPyramidLevel:i,blockBoundary:r}=this.rasterInfo.storageInfo,n=t===0?0:t-(i-1),a=(v=this._headerInfo)==null?void 0:v.ifds[n];if(!a)return null;const l=Yt(a,this._headerInfo),o=Ce(a,"TILEOFFSETS");if(o===void 0)return null;const c=Ce(a,"TILEBYTECOUNTS"),{minRow:u,minCol:h,maxRow:m,maxCol:f}=r[n];if(e>m||s>f||e<u||s<h)return null;const y=oe(a,"IMAGEWIDTH"),d=oe(a,"IMAGELENGTH"),p=oe(a,"TILEWIDTH"),g=oe(a,"TILELENGTH"),x=l?this.rasterInfo.bandCount:1,I=x*e*(f+1)+s,C=[{from:o[I],to:o[I+x-1]+c[I+x-1]-1}];if(l){let R=!0;for(let S=0;S<x;S++)if(o[I+S]+c[I+S]!==o[I+S+1]){R=!1;break}if(!R)for(let S=0;S<x;S++)C[S]={from:o[I+S],to:o[I+S]+c[I+S]-1}}const F=o[I],T=c[I];return F==null||T==null?null:{ranges:C,ifd:a,actualTileWidth:s===f&&y%p||p,actualTileHeight:e===m&&d%g||g}}async _fetchAuxiliaryMetaData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:t==null?void 0:t.signal});return Me(e)}catch{return null}}async _fetchAuxiliaryTable(t){try{const{data:e}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:t==null?void 0:t.signal}),s=rt.parse(e);return s!=null&&s.recordSet?tt.fromJSON(s.recordSet):null}catch{return null}}};w([b()],ee.prototype,"_files",void 0),w([b()],ee.prototype,"_headerInfo",void 0),w([b()],ee.prototype,"_bufferSize",void 0),w([b({type:String,json:{write:!0}})],ee.prototype,"datasetFormat",void 0),ee=w([K("esri.layers.support.rasterDatasets.TIFFRaster")],ee);const $i=ee,z=new Map;z.set("CRF",{desc:"Cloud Raster Format",constructor:Ri}),z.set("MRF",{desc:"Meta Raster Format",constructor:Mi}),z.set("TIFF",{desc:"GeoTIFF",constructor:$i}),z.set("RasterTileServer",{desc:"Raster Tile Server",constructor:Pi}),z.set("JPG",{desc:"JPG Raster Format",constructor:we}),z.set("PNG",{desc:"PNG Raster Format",constructor:we}),z.set("GIF",{desc:"GIF Raster Format",constructor:we}),z.set("BMP",{desc:"BMP Raster Format",constructor:we});class Oi{static get supportedFormats(){const e=new Set;return z.forEach((s,i)=>e.add(i)),e}static async open(e){const{url:s,ioConfig:i,sourceJSON:r}=e;let n=e.datasetFormat;n==null&&s.lastIndexOf(".")&&(n=s.slice(s.lastIndexOf(".")+1).toUpperCase()),n==="OVR"||n==="TIF"?n="TIFF":n!=="JPG"&&n!=="JPEG"&&n!=="JFIF"||(n="JPG"),s.toLowerCase().includes("/imageserver")&&!s.toLowerCase().includes("/wcsserver")&&(n="RasterTileServer");const a={url:s,sourceJSON:r,datasetFormat:n,ioConfig:i??{bandIds:null,sampling:null}};let l,o;if(n&&this.supportedFormats.has(n)){if(n==="CRF"&&!(i!=null&&i.enableCRF))throw new $("rasterfactory:open",`cannot open raster: ${s}`);return l=z.get(n).constructor,o=new l(a),await o.open({signal:e.signal}),o}if(n)throw new $("rasterfactory:open","not a supported format "+n);const c=Array.from(z.keys());let u=0;const h=()=>(n=c[u++],n&&(n!=="CRF"||i!=null&&i.enableCRF)?(l=z.get(n).constructor,o=new l(a),o.open({signal:e.signal}).then(()=>o).catch(()=>h())):null);return h()}static register(e,s,i){z.has(e.toUpperCase())||z.set(e.toUpperCase(),{desc:s,constructor:i})}}let O=class extends Pt(gi(Ot(di(Mt(vi(xi(yi(It(Ft))))))))){constructor(...t){super(...t),this.bandIds=null,this.interpolation=null,this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.title=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null}normalizeCtorArgs(t,e){return typeof t=="string"?{url:t,...e}:t}load(t){const e=k(t)?t.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},t).catch(St).then(()=>this._openRaster(e))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){var l;let t=[new fe({name:"Raster.ServicePixelValue",alias:"Pixel Value",domain:null,editable:!1,length:50,type:"string"})];const{rasterInfo:e}=this,{attributeTable:s}=e,i=k(s)?s.fields:null,r="Raster.";if(i){const o=i.filter(c=>c.type!=="oid"&&c.name.toLowerCase()!=="value").map(c=>{const u=c.clone();return u.name=r+c.name,u});t=t.concat(o)}const{dataType:n,multidimensionalInfo:a}=e;if((n==="vector-magdir"||n==="vector-uv")&&k(a)){const o=(l=a.variables[0].unit)==null?void 0:l.trim(),c="Magnitude"+(o?` (${o})`:"");t.push(new fe({name:"Raster.Magnitude",alias:c,domain:null,editable:!1,type:"double"})),t.push(new fe({name:"Raster.Direction",alias:"Direction (°)",domain:null,editable:!1,type:"double"}))}return t}set renderer(t){this._set("renderer",t),this.updateRenderer()}readRenderer(t,e,s){const i=e&&e.layerDefinition&&e.layerDefinition.drawingInfo&&e.layerDefinition.drawingInfo.renderer,r=pt(i,s)||void 0;if(r!=null)return r}createPopupTemplate(t){return Si({fields:this.rasterFields,title:this.title},t)}write(t,e){const{raster:s}=this;if(this.loaded?s.datasetFormat==="RasterTileServer"&&(s.tileType==="Raster"||s.tileType==="Map"):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(t,e);if(e&&e.messages){const i=`${e.origin}/${e.layerContainerType||"operational-layers"}`;e.messages.push(new $("layer:unsupported",`Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${i}'`,{layer:this}))}return null}async _openRaster(t){if(this.raster)this.raster.rasterInfo||await this.raster.open(),this.url=this.raster.url;else{const s=await Oi.open({url:this.url,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:t});if(this.rasterFunction){const i=et(this.rasterFunction.toJSON(),{raster:s}),r=new it({rasterFunction:i});await r.open(),this.raster=r}else this.raster=s}const{rasterInfo:e}=this.raster;if(!e)throw new $("imagery-tile-layer:load","cannot load resources on "+this.url);if(this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,this.sourceJSON!=null){const s=this.raster.tileType==="Map"&&this.sourceJSON.minLOD!=null&&this.sourceJSON.maxLOD!=null?this.sourceJSON:{...this.sourceJSON,minScale:0,maxScale:0};this.read(s,{origin:"service"})}this.title==null&&(this.title=this.raster.datasetName),this.raster.tileType==="Map"&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles(vt(()=>this.customParameters,s=>{this.raster.ioConfig.customFetchParameters=s}))}};w([b({type:[Rt],json:{write:{overridePolicy(){var t;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((t=this.bandIds)==null?void 0:t.join(","))!=="0,1,2"}}}}})],O.prototype,"bandIds",void 0),w([b({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),_t(dt)],O.prototype,"interpolation",void 0),w([b({json:{write:!0}})],O.prototype,"multidimensionalDefinition",void 0),w([b(Bt)],O.prototype,"legendEnabled",void 0),w([b({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],O.prototype,"isReference",void 0),w([b({type:["show","hide"]})],O.prototype,"listMode",void 0),w([b({json:{read:!0,write:!0}})],O.prototype,"blendMode",void 0),w([b()],O.prototype,"sourceJSON",void 0),w([b({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],O.prototype,"version",void 0),w([b()],O.prototype,"title",void 0),w([b({readOnly:!0,json:{read:!1}})],O.prototype,"type",void 0),w([b({type:["ArcGISTiledImageServiceLayer"]})],O.prototype,"operationalLayerType",void 0),w([b({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(t,e)=>!e.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}},writer(t,e,s){e[s]=!t}}}})],O.prototype,"popupEnabled",void 0),w([b({type:at,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}}}}})],O.prototype,"popupTemplate",void 0),w([b({readOnly:!0})],O.prototype,"defaultPopupTemplate",null),w([b({readOnly:!0,type:[fe]})],O.prototype,"fields",void 0),w([b({readOnly:!0,type:[fe]})],O.prototype,"rasterFields",null),w([b({types:qe,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var e;const t=((e=this.renderer)==null?void 0:e.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!t}}},origins:{"web-scene":{types:yt,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:t=>({enabled:t&&t.type!=="vector-field"&&t.type!=="flow"})}}}}})],O.prototype,"renderer",null),w([Ct("renderer")],O.prototype,"readRenderer",null),O=w([K("esri.layers.ImageryTileLayer")],O);const $s=O;export{$s as default};
