import{B as p,a as V,b as w,c as B,d as _,e as y,f as F,g as m,h as g,i as E,j as T,k as v,l as A,m as b,n as I,o as M,p as C,q as N,r as P,s as U,t as z,u as R,v as j,w as q,x,y as $,z as D,A as G,C as H,D as k,E as J,F as K,G as O,H as Q,I as W,J as X}from"./BufferView-8a646050.js";import{e as o}from"./types-c657ebd9.js";class Y{constructor(e){this.message=e}toString(){return`AssertException: ${this.message}`}}function Z(f,e){if(!f){e=e||"Assertion";const t=new Error(e).stack;throw new Y(`${e} at ${t}`)}}function re(f,e,t,i){let s,r=(t[0]-f[0])/e[0],n=(i[0]-f[0])/e[0];r>n&&(s=r,r=n,n=s);let u=(t[1]-f[1])/e[1],a=(i[1]-f[1])/e[1];if(u>a&&(s=u,u=a,a=s),r>a||u>n)return!1;u>r&&(r=u),a<n&&(n=a);let c=(t[2]-f[2])/e[2],h=(i[2]-f[2])/e[2];return c>h&&(s=c,c=h,h=s),!(r>h||c>n||(h<n&&(n=h),n<0))}class d{constructor(e,t){this.layout=e,this.buffer=typeof t=="number"?new ArrayBuffer(t*e.stride):t;for(const i of e.fields.keys()){const s=e.fields.get(i);this[i]=new s.constructor(this.buffer,s.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(e,t){const i=this[e];return i&&i.elementCount===t.ElementCount&&i.elementType===t.ElementType?i:null}slice(e,t){return new d(this.layout,this.buffer.slice(e*this.stride,t*this.stride))}copyFrom(e,t=0,i=0,s=e.count){const r=this.stride;if(r%4===0){const n=new Uint32Array(e.buffer,t*r,s*r/4);new Uint32Array(this.buffer,i*r,s*r/4).set(n)}else{const n=new Uint8Array(e.buffer,t*r,s*r);new Uint8Array(this.buffer,i*r,s*r).set(n)}return this}}class l{constructor(e=null){this._stride=0,this._lastAligned=0,this._fields=new Map,e&&(this._stride=e.stride,e.fields.forEach(t=>this._fields.set(t[0],{...t[1],constructor:te(t[1].constructor)})))}vec2f(e,t){return this._appendField(e,V,t),this}vec2f64(e,t){return this._appendField(e,m,t),this}vec3f(e,t){return this._appendField(e,w,t),this}vec3f64(e,t){return this._appendField(e,g,t),this}vec4f(e,t){return this._appendField(e,B,t),this}vec4f64(e,t){return this._appendField(e,E,t),this}mat3f(e,t){return this._appendField(e,_,t),this}mat3f64(e,t){return this._appendField(e,T,t),this}mat4f(e,t){return this._appendField(e,y,t),this}mat4f64(e,t){return this._appendField(e,v,t),this}vec4u8(e,t){return this._appendField(e,M,t),this}f32(e,t){return this._appendField(e,p,t),this}f64(e,t){return this._appendField(e,F,t),this}u8(e,t){return this._appendField(e,A,t),this}u16(e,t){return this._appendField(e,C,t),this}i8(e,t){return this._appendField(e,x,t),this}vec2i8(e,t){return this._appendField(e,$,t),this}vec2i16(e,t){return this._appendField(e,k,t),this}vec2u8(e,t){return this._appendField(e,b,t),this}vec4u16(e,t){return this._appendField(e,U,t),this}u32(e,t){return this._appendField(e,z,t),this}_appendField(e,t,i){if(this._fields.has(e)){Z(!1,`${e} already added to vertex buffer layout`);return}const s=t.ElementCount*o(t.ElementType),r=this._stride;this._stride+=s,this._fields.set(e,{size:s,constructor:t,offset:r,optional:i})}createBuffer(e){return new d(this,e)}createView(e){return new d(this,e)}clone(){const e=new l;return e._stride=this._stride,e._fields=new Map,this._fields.forEach((t,i)=>e._fields.set(i,t)),e.BufferType=this.BufferType,e}get stride(){if(this._lastAligned!==this._fields.size){let e=1;this._fields.forEach(t=>e=Math.max(e,o(t.constructor.ElementType))),this._stride=Math.floor((this._stride+e-1)/e)*e,this._lastAligned=this._fields.size}return this._stride}get fields(){return this._fields}}function fe(){return new l}class ne{constructor(e){this.fields=new Array,e.fields.forEach((t,i)=>{const s={...t,constructor:L(t.constructor)};this.fields.push([i,s])}),this.stride=e.stride}}const ee=[p,V,w,B,_,y,F,m,g,E,T,v,A,b,I,M,C,N,P,U,z,R,j,q,x,$,D,G,H,k,J,K,O,Q,W,X];function L(f){return`${f.ElementType}_${f.ElementCount}`}function te(f){return S.get(f)}const S=new Map;ee.forEach(f=>S.set(L(f),f));export{ne as P,Z as a,fe as n,re as r};
