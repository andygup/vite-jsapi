import{bf as l,K as c,h9 as m}from"./index-6dc9db96.js";import{P as i,c as f,f as a,g as p,h as u,i as S,j as x,k as h}from"./dataUtils-2098fde1.js";import{c as y,d as O,R as N,e as k}from"./RasterSymbolizer-1ba0fafa.js";import{c as B,r as J}from"./utils-13219b9c.js";import{r as P,l as g,d as b}from"./rasterProjectionHelper-d5b0f9a2.js";import"./colorUtils-6f72410e.js";import"./colorRamps-41492d1d.js";class G{convertVectorFieldData(e){const r=i.fromJSON(e.pixelBlock),o=f(r,e.type);return Promise.resolve(o!=null?o.toJSON():null)}computeStatisticsHistograms(e){const r=i.fromJSON(e.pixelBlock),o=y(r);return Promise.resolve(o)}async decode(e){const r=await O(e.data,e.options);return r&&r.toJSON()}symbolize(e){e.pixelBlock=i.fromJSON(e.pixelBlock),e.extent=e.extent?l.fromJSON(e.extent):null;const r=this.symbolizer.symbolize(e);return Promise.resolve(r!=null?r.toJSON():null)}async updateSymbolizer(e){var r;this.symbolizer=N.fromJSON(e.symbolizerJSON),e.histograms&&((r=this.symbolizer)==null?void 0:r.rendererJSON.type)==="rasterStretch"&&(this.symbolizer.rendererJSON.histograms=e.histograms)}async updateRasterFunction(e){this.rasterFunction=B(e.rasterFunctionJSON)}async process(e){var o;const r=this.rasterFunction.process({extent:l.fromJSON(e.extent),primaryPixelBlocks:e.primaryPixelBlocks.map(s=>s!=null?i.fromJSON(s):null),primaryPixelSizes:(o=e.primaryPixelSizes)==null?void 0:o.map(s=>s!=null?c.fromJSON(s):null),primaryRasterIds:e.primaryRasterIds});return r!=null?r.toJSON():null}stretch(e){const r=this.symbolizer.simpleStretch(i.fromJSON(e.srcPixelBlock),e.stretchParams);return Promise.resolve(r!=null&&r.toJSON())}estimateStatisticsHistograms(e){const r=k(i.fromJSON(e.srcPixelBlock));return Promise.resolve(r)}split(e){const r=a(i.fromJSON(e.srcPixelBlock),e.tileSize,e.maximumPyramidLevel);return r&&r.forEach((o,s)=>{r.set(s,o==null?void 0:o.toJSON())}),Promise.resolve(r)}async mosaicAndTransform(e){const r=e.srcPixelBlocks.map(n=>n?new i(n):null),o=p(r,e.srcMosaicSize,{blockWidths:e.blockWidths,alignmentInfo:e.alignmentInfo,clipOffset:e.clipOffset,clipSize:e.clipSize});let s=o;e.coefs&&(s=u(o,e.destDimension,e.coefs,e.sampleSpacing,e.interpolation));let t;return e.projectDirections&&e.gcsGrid&&(t=S(e.destDimension,e.gcsGrid),s=x(s,e.isUV?"vector-uv":"vector-magdir",t)),{pixelBlock:s==null?void 0:s.toJSON(),localNorthDirections:t}}async createFlowMesh(e,r){const o={data:new Float32Array(e.flowData.buffer),mask:new Uint8Array(e.flowData.maskBuffer),width:e.flowData.width,height:e.flowData.height},{vertexData:s,indexData:t}=await h(e.meshType,e.simulationSettings,o,r.signal);return{result:{vertexBuffer:s.buffer,indexBuffer:t.buffer},transferList:[s.buffer,t.buffer]}}async getProjectionOffsetGrid(e){const r=l.fromJSON(e.projectedExtent),o=l.fromJSON(e.srcBufferExtent);let s=null;e.datumTransformationSteps&&(s=new m({steps:e.datumTransformationSteps})),(e.includeGCSGrid||P(r.spatialReference,o.spatialReference,s))&&await g();const t=e.rasterTransform?J(e.rasterTransform):null;return b({...e,projectedExtent:r,srcBufferExtent:o,datumTransformation:s,rasterTransform:t})}}export{G as default};
