class a{constructor(t=null,s={},e,h){this.geometry=t,this.attributes=s,this.centroid=e,this.objectId=h,this.displayId=0,this.geohashX=0,this.geohashY=0}weakClone(){const t=new a(this.geometry,this.attributes,this.centroid,this.objectId);return t.displayId=this.displayId,t.geohashX=this.geohashX,t.geohashY=this.geohashY,t}}function d(i){return!(i.geometry==null||!i.geometry.coords||!i.geometry.coords.length)}class u extends a{}class r{constructor(t=[],s=[],e=!1){this.lengths=t??[],this.coords=s??[],this.hasIndeterminateRingOrder=e}static fromRect(t){const[s,e,h,n]=t,c=[5],o=h-s,g=n-e,l=[s,e,o,0,0,g,-o,0,0,-g];return new r(c,l)}get isPoint(){return this.lengths.length===0}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((t,s)=>t+s)}forEachVertex(t){let s=0;this.lengths.length||t(this.coords[0],this.coords[1]);for(let e=0;e<this.lengths.length;e++){const h=this.lengths[e];for(let n=0;n<h;n++){const c=this.coords[2*(n+s)],o=this.coords[2*(n+s)+1];t(c,o)}s+=h}}clone(t){return t?(t.set(this.coords),new r(this.lengths.slice(),t,this.hasIndeterminateRingOrder)):new r(this.lengths.slice(),this.coords.slice(),this.hasIndeterminateRingOrder)}}export{r as O,a,u as b,d as h};
