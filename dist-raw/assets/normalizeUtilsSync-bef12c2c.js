import{O as z,bP as k,df as N,cp as R,cq as V,cn as W,cd as F,cm as E,cj as J,dg as B}from"./index-468a9268.js";import{c as w,u as Y,o as p}from"./normalizeUtilsCommon-6cabd780.js";function X(n){return L(n,!0)}function H(n){return L(n,!1)}function L(n,s){if(n==null)return null;const i=n.spatialReference,t=k(i),e="toJSON"in n?n.toJSON():n;if(!t)return e;const h=N(i)?102100:4326,a=w[h].maxX,l=w[h].minX;if(R(e))return y(e,a,l);if(V(e))return e.points=e.points.map(o=>y(o,a,l)),e;if(W(e))return j(e,t);if(F(e)||E(e)){const o=J(A,e),u={xmin:o[0],ymin:o[1],xmax:o[2],ymax:o[3]},c=p(u.xmin,l)*(2*a),_=c===0?e:Y(e,c);return u.xmin+=c,u.xmax+=c,u.xmax>a?T(_,a,s):u.xmin<l?T(_,l,s):_}return e}function j(n,s){if(!s)return n;const i=q(n,s).map(t=>t.extent);return i.length<2?i[0]||n:i.length>2?(n.xmin=s.valid[0],n.xmax=s.valid[1],n):{rings:i.map(t=>[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]])}}function y(n,s,i){if(Array.isArray(n)){const t=n[0];if(t>s){const e=p(t,s);n[0]=t+e*(-2*s)}else if(t<i){const e=p(t,i);n[0]=t+e*(-2*i)}}else{const t=n.x;if(t>s){const e=p(t,s);n.x+=e*(-2*s)}else if(t<i){const e=p(t,i);n.x+=e*(-2*i)}}return n}function q(n,s){const i=[],{ymin:t,ymax:e,xmin:r,xmax:h}=n,a=n.xmax-n.xmin,[l,o]=s.valid,{x:u,frameId:f}=M(n.xmin,s),{x:c,frameId:_}=M(n.xmax,s),b=u===c&&a>0;if(a>2*o){const v={xmin:r<h?u:c,ymin:t,xmax:o,ymax:e},C={xmin:l,ymin:t,xmax:r<h?c:u,ymax:e},S={xmin:0,ymin:t,xmax:o,ymax:e},g={xmin:l,ymin:t,xmax:0,ymax:e},x=[],d=[];O(v,S)&&x.push(f),O(v,g)&&d.push(f),O(C,S)&&x.push(_),O(C,g)&&d.push(_);for(let P=f+1;P<_;P++)x.push(P),d.push(P);i.push(new m(v,[f]),new m(C,[_]),new m(S,x),new m(g,d))}else u>c||b?i.push(new m({xmin:u,ymin:t,xmax:o,ymax:e},[f]),new m({xmin:l,ymin:t,xmax:c,ymax:e},[_])):i.push(new m({xmin:u,ymin:t,xmax:c,ymax:e},[f]));return i}function M(n,s){const[i,t]=s.valid,e=2*t;let r=0,h;return n>t?(h=Math.ceil(Math.abs(n-t)/e),n-=h*e,r=h):n<i&&(h=Math.ceil(Math.abs(n-i)/e),n+=h*e,r=-h),{x:n,frameId:r}}function O(n,s){const{xmin:i,ymin:t,xmax:e,ymax:r}=s;return I(n,i,t)&&I(n,i,r)&&I(n,e,r)&&I(n,e,t)}function I(n,s,i){return s>=n.xmin&&s<=n.xmax&&i>=n.ymin&&i<=n.ymax}function T(n,s,i=!0){const t=!E(n);if(t&&B(n),i)return new D().cut(n,s);const e=t?n.rings:n.paths,r=t?4:2,h=e.length,a=-2*s;for(let l=0;l<h;l++){const o=e[l];if(o&&o.length>=r){const u=[];for(const f of o)u.push([f[0]+a,f[1]]);e.push(u)}}return t?n.rings=e:n.paths=e,n}class m{constructor(s,i){this.extent=s,this.frameIds=i}}const A=z();class D{constructor(){this._linesIn=[],this._linesOut=[]}cut(s,i){this._xCut=i;let t;if(s.rings)this._closed=!0,t=s.rings,this._minPts=4;else if(s.paths)this._closed=!1,t=s.paths,this._minPts=2;else return null;for(const r of t){if(!r||r.length<this._minPts)continue;let h=!0;for(const a of r)h?(this.moveTo(a),h=!1):this.lineTo(a);this._closed&&this.close()}this._pushLineIn(),this._pushLineOut(),t=[];for(const r of this._linesIn)r&&r.length>=this._minPts&&t.push(r);const e=-2*this._xCut;for(const r of this._linesOut)if(r&&r.length>=this._minPts){for(const h of r)h[0]+=e;t.push(r)}return this._closed?s.rings=t:s.paths=t,s}moveTo(s){this._pushLineIn(),this._pushLineOut(),this._prevSide=this._side(s[0]),this._moveTo(s[0],s[1],this._prevSide),this._prevPt=s,this._firstPt=s}lineTo(s){const i=this._side(s[0]);if(i*this._prevSide===-1){const t=this._intersect(this._prevPt,s);this._lineTo(this._xCut,t,0),this._prevSide=0,this._lineTo(s[0],s[1],i)}else this._lineTo(s[0],s[1],i);this._prevSide=i,this._prevPt=s}close(){const s=this._firstPt,i=this._prevPt;(s[0]!==i[0]||s[1]!==i[1])&&this.lineTo(s),this._checkClosingPt(this._lineIn),this._checkClosingPt(this._lineOut)}_moveTo(s,i,t){this._closed?(this._lineIn.push([t<=0?s:this._xCut,i]),this._lineOut.push([t>=0?s:this._xCut,i])):(t<=0&&this._lineIn.push([s,i]),t>=0&&this._lineOut.push([s,i]))}_lineTo(s,i,t){this._closed?(this._addPolyVertex(this._lineIn,t<=0?s:this._xCut,i),this._addPolyVertex(this._lineOut,t>=0?s:this._xCut,i)):t<0?(this._prevSide===0&&this._pushLineOut(),this._lineIn.push([s,i])):t>0?(this._prevSide===0&&this._pushLineIn(),this._lineOut.push([s,i])):this._prevSide<0?(this._lineIn.push([s,i]),this._lineOut.push([s,i])):this._prevSide>0&&(this._lineOut.push([s,i]),this._lineIn.push([s,i]))}_addPolyVertex(s,i,t){const e=s.length;if(e>1&&s[e-1][0]===i&&s[e-2][0]===i){s[e-1][1]=t;return}s.push([i,t])}_checkClosingPt(s){const i=s.length;i>3&&s[0][0]===this._xCut&&s[i-2][0]===this._xCut&&s[1][0]===this._xCut&&(s[0][1]=s[i-2][1],s.pop())}_side(s){return s<this._xCut?-1:s>this._xCut?1:0}_intersect(s,i){const t=(this._xCut-s[0])/(i[0]-s[0]);return s[1]+t*(i[1]-s[1])}_pushLineIn(){this._lineIn&&this._lineIn.length>=this._minPts&&this._linesIn.push(this._lineIn),this._lineIn=[]}_pushLineOut(){this._lineOut&&this._lineOut.length>=this._minPts&&this._linesOut.push(this._lineOut),this._lineOut=[]}}export{X as a,H as n};
