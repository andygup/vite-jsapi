import{L as le,m as K,bo as q,E as m,cF as te,p as se,aB as Se}from"./index-0cbe37a0.js";import{s as xe}from"./sql-e009a7de.js";import{d as Te}from"./diffUtils-6d46a8ba.js";import{v as ne}from"./labelingInfo-e7968113.js";import{w as B,a as E,b,x as Ve}from"./color-1b66ad26.js";import{g as Fe}from"./utils-c4b4ba96.js";import{g as we}from"./visualVariablesUtils-fff56d02.js";import{c as z,i as oe,h as Ee}from"./MaterialKey-e90d5ee5.js";import"./ExpandedCIM-757539da.js";import"./featureFlags-986067cc.js";import{i as ze,b as ve}from"./clusterUtils-ffb33f67.js";import{t as ue}from"./util-340d902b.js";function ce(e){if(!e)return B.NONE;let t=0;for(const r of e)if(r.type==="size"){const s=we(r);t|=s,r.target==="outline"&&(t|=s<<4)}else r.type==="color"?t|=B.COLOR:r.type==="opacity"?t|=B.OPACITY:r.type==="rotation"&&(t|=B.ROTATION);return t}function v(e){var t;switch(e.type){case"line-marker":return{type:"line-marker",color:(t=e.color)==null?void 0:t.toJSON(),placement:e.placement,style:e.style};default:return e.constructor.fromJSON(e.toJSON()).toJSON()}}function I(e){return Ee(e)}function h(e,t,r=!1){if(!e)return null;switch(e.type){case"simple-fill":case"picture-fill":return Me(e,t,r);case"simple-marker":case"picture-marker":return Oe(e,t,r);case"simple-line":return Le(e,t,r);case"text":return Ne(e,t,r);case"label":return Ie(e,t,r);case"cim":return{type:"cim",rendererKey:t.vvFlags,data:e.data,maxVVSize:t.maxVVSize};case"CIMSymbolReference":return{type:"cim",rendererKey:t.vvFlags,data:e,maxVVSize:t.maxVVSize};case"web-style":return{...v(e),type:"web-style",hash:e.hash(),rendererKey:t.vvFlags,maxVVSize:t.maxVVSize};default:throw new Error(`symbol not supported ${e.type}`)}}function Ie(e,t,r){const s=e.toJSON(),a=z(E.LABEL,{...t,placement:s.labelPlacement});return{materialKey:r?I(a):a,hash:e.hash(),...s,labelPlacement:s.labelPlacement}}function Me(e,t,r){const s=z(E.FILL,t),a=r?I(s):s,i=e.clone(),l=i.outline,u=oe(t.symbologyType);u||(i.outline=null);const o={materialKey:a,hash:i.hash(),...v(i)};if(u)return o;const n=[];if(n.push(o),l){const c=z(E.LINE,{...t,isOutline:!0}),f={materialKey:r?I(c):c,hash:l.hash(),...v(l)};n.push(f)}return{type:"composite-symbol",layers:n,hash:n.reduce((c,p)=>p.hash+c,"")}}function Le(e,t,r){const s=oe(t.symbologyType)?b.DEFAULT:t.symbologyType,a=z(E.LINE,{...t,symbologyType:s}),i=r?I(a):a,l=e.clone(),u=l.marker;l.marker=null;const o=[];if(o.push({materialKey:i,hash:l.hash(),...v(l)}),u){const n=z(E.MARKER,t),c=r?I(n):n;u.color=u.color??l.color,o.push({materialKey:c,hash:u.hash(),lineWidth:l.width,...v(u)})}return{type:"composite-symbol",layers:o,hash:o.reduce((n,c)=>c.hash+n,"")}}function Oe(e,t,r){const s=z(E.MARKER,t),a=r?I(s):s,i=v(e);return{materialKey:a,hash:e.hash(),...i,angle:e.angle,maxVVSize:t.maxVVSize}}function Ne(e,t,r){const s=z(E.TEXT,t),a=r?I(s):s,i=v(e);return{materialKey:a,hash:e.hash(),...i,angle:e.angle,maxVVSize:t.maxVVSize}}const yt=Object.freeze(Object.defineProperty({__proto__:null,createSymbolSchema:h},Symbol.toStringTag,{value:"Module"}));function Re(e,t){if(!("visualVariables"in e)||!e.hasVisualVariables("size"))return 0;const r=e.getVisualVariablesForType("size");if(!r[0])return 0;const s=r[0];if(t&&s.field==="cluster_count"&&t.type==="cluster")return t.clusterMaxSize;if(s.target==="outline")return 0;if(s.transformationType==="stops")return s.stops.map(a=>a.size).reduce(J,0);if(s.transformationType==="clamped-linear"){let a=-1/0,i=-1/0;return typeof s.maxSize=="number"?a=s.maxSize:a=s.maxSize.stops.map(l=>l.size).reduce(J,0),typeof s.minSize=="number"?i=s.minSize:i=s.minSize.stops.map(l=>l.size).reduce(J,0),Math.max(a,i)}if(s.transformationType==="real-world-size")return 30}function J(e,t){return Math.max(e,t)}const C=8,fe=C-2,D=le.getLogger("esri.views.2d.layers.features.support.rendererUtils"),mt=e=>{if(!("visualVariables"in e)||!e.visualVariables||!e.visualVariables.length)return e;const t=e.clone(),r=t.visualVariables.map(s=>pe(s)?ye(s):s);return t.visualVariables=r,t};function _e(e){return e.map(t=>pe(t)?ye(t.clone()):t)}function pe(e){return(e.type==="size"||e.type==="color"||e.type==="opacity")&&e.stops!=null}function ye(e){return e.stops=Pe(e.type,e.stops??[]),e}function N(e,t,r){return(1-r)*e+r*t}function ke(e,t){const[r,...s]=t,a=s.pop(),i=s[0].value,l=s[s.length-1].value,u=(l-i)/fe,o=[];for(let n=i;n<l;n+=u){let c=0;for(;n>=s[c].value;)c++;const p=s[c],f=t[c-1],F=n-f.value,V=p.value===f.value?1:F/(p.value-f.value);if(e==="color"){const g=s[c],S=t[c-1],y=g.color.clone();y.r=N(S.color.r,y.r,V),y.g=N(S.color.g,y.g,V),y.b=N(S.color.b,y.b,V),y.a=N(S.color.a,y.a,V),o.push({value:n,color:y,label:g.label})}else if(e==="size"){const g=s[c],S=t[c-1],y=te(g.size),x=te(S.size),L=N(x,y,V);o.push({value:n,size:L,label:g.label})}else{const g=s[c],S=t[c-1],y=N(S.opacity,g.opacity,V);o.push({value:n,opacity:y,label:g.label})}}return[r,...o,a]}function Ae(e){const[t,...r]=e,s=r.pop();for(;r.length>fe;){let a=0,i=0;for(let l=1;l<r.length;l++){const u=r[l-1],o=r[l],n=Math.abs(o.value-u.value);n>i&&(i=n,a=l)}r.splice(a,1)}return[t,...r,s]}function Pe(e,t){return t.length<=C?t:(D.warn(`Found ${t.length} Visual Variable stops, but MapView only supports ${C}. Displayed stops will be simplified.`),t.length>C*2?ke(e,t):Ae(t))}function j(){if(K("heatmap-force-raster"))return"raster";const{supportsTextureFloat:e,supportsTextureHalfFloat:t,supportsColorBufferFloat:r,supportsColorBufferFloatBlend:s,supportsColorBufferHalfFloat:a}=q("2d");return e&&r&&s||t&&a?"symbol":K("heatmap-allow-raster-fallback")?"raster":"none"}function dt(e){if(!e)return!0;switch(e.type){case"dot-density":if(!q("2d").supportsTextureFloat)return D.error(new m("webgl-missing-extension","Missing WebGL extension OES_Texture_Float which is required for DotDensity")),!1;break;case"heatmap":{const t=j();if(t==="none"||t==="raster"&&!K("heatmap-force-raster")){const r=q("2d"),a=["supportsTextureFloat","supportsTextureHalfFloat","supportsColorBufferFloat","supportsColorBufferFloatBlend","supportsColorBufferHalfFloat"].filter(i=>!r[i]).join(", ");if(t==="none")return D.errorOnce(new m("webgl-missing-extension",`Missing WebGL${r.type} requirements for Heatmap: ${a}`)),!1;t==="raster"&&D.warnOnce(`Missing WebGL${r.type} requirements for accelerated Heatmap: ${a}. Feature support may be limited.`)}break}}return!0}const M=le.getLogger("esri.views.2d.layers.features.schemaUtils"),d="ValidationError";function W(e,t){let r=0,s=0,a=b.DEFAULT;if(e!=null){if(s=Re(e,t),"visualVariables"in e&&(r=ce(e.visualVariables||[]),e.type==="dot-density"&&(a=b.DOT_DENSITY)),e.type==="heatmap"&&(a=b.HEATMAP),e.type==="dictionary")return{maxVVSize:s,vvFlags:r,symbologyType:b.DEFAULT};if(e.type==="pie-chart")return{maxVVSize:s,vvFlags:r,symbologyType:b.PIE_CHART};if(a!==b.DOT_DENSITY&&a!==b.HEATMAP){const i=e.getSymbols();"backgroundFillSymbol"in e&&e.backgroundFillSymbol&&i.push(e.backgroundFillSymbol);let l=!0,u=!0;for(const o of i)if(o.type==="cim"&&(u=!1),o.type==="simple-fill"||o.type==="picture-fill"){const n=o.outline,c=n&&n.style!=="none"&&n.style!=="solid",p=o.type==="simple-fill"&&o.style!=="none"&&o.style!=="solid",f=o.type==="picture-fill"||p||c;c&&(l=!1),f&&(u=!1)}l?a=u?b.OUTLINE_FILL_SIMPLE:b.OUTLINE_FILL:u&&(a=b.SIMPLE)}}return{vvFlags:r,maxVVSize:s,symbologyType:a}}let re=null;function bt(e){if(K("esri-2d-update-debug")){const t=ae(e,!0);console.debug("Created new schema",t),console.debug("Schema diff",Te(re,t)),re=t}return ae(e)}function ae(e,t=!1){var r,s;try{const a=Ke(e,t),i=He(e),l={};a.map(c=>Be(l,e,c));const u=e.subtypeCode!=null?`${e.subtypeField} = ${e.subtypeCode}`:null;return{source:{definitionExpression:xe(e.definitionExpression,u),fields:e.fields.map(c=>c.toJSON()),gdbVersion:e.gdbVersion,historicMoment:(r=e.historicMoment)==null?void 0:r.getTime(),outFields:e.availableFields,pixelBuffer:e.pixelBuffer,spatialReference:e.spatialReference.toJSON(),timeExtent:(s=e.timeExtent)==null?void 0:s.toJSON(),customParameters:e.customParameters},attributes:{fields:{},indexCount:0},processors:a,tileRenderer:i,targets:l}}catch(a){if(a.fieldName===d)return M.error(a),null;throw a}}function Be(e,t,r){switch(r.target){case"feature":H(e,G(t),r);return;case"aggregate":{if(!("featureReduction"in t))return;const s=t.featureReduction;switch(s==null?void 0:s.type){case"selection":throw new m(d,"Mapview does not support `selection` reduction type",s);case"binning":H(e,G(t),r),Ce(e,s,t.fields.map(a=>a.toJSON()),r);return;case"cluster":H(e,G(t),r),De(e,s,t.fields.map(a=>a.toJSON()),r);return}}}}function X(e,t){var r,s;for(const a in t){const i=t[a];if(i.target!==e.name)continue;const l=e.attributes[a];if(l!=null&&l.context){const u=l.context;u.mesh=u.mesh||((r=i.context)==null?void 0:r.mesh),u.storage=u.storage||((s=i.context)==null?void 0:s.storage)}else e.attributes[a]=i}return e}function G(e){var t,r,s;return[((t=e.filter)==null?void 0:t.toJSON())??null,((s=(r=e.featureEffect)==null?void 0:r.filter)==null?void 0:s.toJSON())??null]}function H(e,t,r){return e.feature||(e.feature={name:"feature",input:"source",filters:t,attributes:{}}),X(e.feature,r.attributes.fields),e}function me(e,t){const{onStatisticExpression:r,onStatisticField:s,statisticType:a}=e;switch(a){case"min":case"max":case"avg":case"avg_angle":case"sum":case"count":return"esriFieldTypeDouble";case"mode":{if(r){const{returnType:l}=r;return l?l==="string"?"esriFieldTypeString":"esriFieldTypeDouble":(M.error(new m(d,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}const i=t.find(l=>l.name===s);return i?i.type:(M.error(new m(d,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}}}function Ce(e,t,r,s){return e.aggregate||(e.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:t.fixedBinLevel,fields:(t.fields??[]).map(a=>({...a.toJSON(),type:me(a,r)}))},attributes:{}}),X(e.aggregate,s.attributes.fields),e}function De(e,t,r,s){var a;return e.aggregate||(e.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:se(t.clusterRadius/2),clusterPixelBuffer:Math.ceil(se(t.clusterMaxSize)/64)*64,fields:(a=t.fields??[])==null?void 0:a.map(i=>({...i.toJSON(),type:me(i,r)}))}}),X(e.aggregate,s.attributes.fields),e}function T(e,t){return t.field?w(e,{...t,type:"field",field:t.field}):t.valueExpression?w(e,{...t,type:"expression",valueExpression:t.valueExpression}):{field:void 0,fieldIndex:void 0}}function w(e,t){switch(t.type){case"expression":{const r=t.valueExpression;if(!e.fields[r]){const a=e.indexCount++;e.fields[r]={...t,name:r,fieldIndex:a}}return{fieldIndex:e.fields[r].fieldIndex}}case"label-expression":{const r=JSON.stringify(t.label),s=r;if(!e.fields[s]){const i=e.indexCount++;e.fields[s]={...t,name:s,fieldIndex:i}}return{fieldIndex:e.fields[s].fieldIndex}}case"field":{const r=t.field;return t.target==="aggregate"&&e.fields[r]?{field:r}:(e.fields[r]={...t,name:r},{field:r})}case"statistic":return e.fields[t.name]={...t},{field:t.name}}}function Ke(e,t=!1){const r=new Array;let s=0;return r.push(Ge(e,s++,t)),r}function $(e,t,r,s,a,i=!1){const u=w(e,{type:"label-expression",target:r,context:{mesh:!0},resultType:"string",label:{labelExpression:t.labelExpression,labelExpressionInfo:t.labelExpressionInfo?{expression:t.labelExpressionInfo.expression}:null,symbol:!!t.symbol,where:t.where}}),{fieldIndex:o}=u;return{...h(t,a,i),fieldIndex:o,target:r,index:s}}function Je(e,t,r){var p;const s="featureReduction"in t&&t.featureReduction;if(!s)return{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};const a="aggregate",i=[];let l=null,u=ue(t.geometryType),o=[],n=null;if(s)switch(s.type){case"selection":return M.error(new m(d,"Mapview does not support `selection` reduction type",s)),{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};case"cluster":case"binning":if(i.push(...s.fields??[]),s.type==="cluster"?u="esriGeometryPoint":s.type==="binning"&&(u="esriGeometryPolygon"),s.renderer&&!((p=s.renderer.authoringInfo)!=null&&p.isAutoGenerated)){if(s.type==="cluster"){const{renderer:F}=ze(s.renderer,s,null);n=F}else n=s.renderer;const f=W(s.renderer,s);l=U(e,a,s.renderer,f,r),o=s&&s.labelsVisible&&s.labelingInfo||[]}else if(s.type==="cluster"){if(n=ve(i,t.renderer,s,null,!0),s.symbol){const f=W(n,s);l={type:"simple",symbol:h(s.symbol,f,r),symbologyType:f.symbologyType}}o=s&&s.labelsVisible&&s.labelingInfo||[]}break}return qe(e,i),{labels:ne(o,s.type==="binning"?"esriGeometryPolygon":u),matcher:l,fields:i,rendererOverride:n}}function Ge(e,t,r=!1){var y;const s={indexCount:0,fields:{}},a="featureReduction"in e?e.featureReduction??void 0:void 0,i=a?"aggregate":"feature";if("sublayers"in e){const x={type:"subtype",subtypeField:e.subtypeField,renderers:{},symbologyType:b.DEFAULT},L={type:"subtype",mapping:{},target:"feature",subtypeField:e.subtypeField},P={type:"subtype",classes:{}},de={type:"symbol",target:"feature",aggregateFields:[],attributes:s,storage:L,mesh:{matcher:x,aggregateMatcher:null,labels:P,sortKey:null}},Y=new Set;let be=0;for(const{renderer:O,subtypeCode:R,labelingInfo:he,labelsVisible:ge}of e.sublayers){let Q=0;"visualVariables"in O&&O.visualVariables&&(O.visualVariables.some(A=>A.type!=="rotation")&&M.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."),Q=ce(O.visualVariables.filter(A=>A.type!=="size")));const Z={symbologyType:b.DEFAULT,vvFlags:Q,maxVVSize:0},_=U(s,i,O,Z,r),k=ie(s,i,O),ee=ge&&he;if(_.type==="dictionary")throw new m(d,"Dictionary renderer is not supported in subtype layers");if(_.type==="subtype")throw new m(d,"Nested subtype renderers is not supported");if(k!=null&&k.type==="subtype")throw new m(d,"Nested subtype storage is not supported");if(k!=null&&k.attributeMapping!=null)throw new m(d,"Non-visual-variable attributes are not supported in subtype layers");if(_.type==="heatmap")throw new m(d,"Heatmaps are not supported in subtype layers");if(_.type==="pie-chart")throw new m(d,"Pie-charts are not supported in subtype layers");if(Y.has(R))throw new m(d,"Subtype codes for sublayers must be unique");Y.add(R),x.renderers[R]=_,L.mapping[R]=k,ee&&(P.classes[R]=ee.map(A=>$(s,A,"feature",be++,Z,r)))}return de}if(((y=e.renderer)==null?void 0:y.type)==="heatmap"&&j()==="raster"){const{radius:x,fieldOffset:L,field:P}=e.renderer;return{type:"heatmap",aggregateFields:[],attributes:s,target:i,storage:null,mesh:{radius:x,fieldOffset:L,field:T(s,{target:i,field:P,resultType:"numeric"}).field}}}const l=Je(s,e,r),u=ue(e.geometryType),o=l.rendererOverride??e.renderer,n=W(o,a),c=U(s,i,o,n,r),p=ie(s,i,o),f=$e(s,e.orderBy,e.renderer,a),F=e.labelsVisible&&e.labelingInfo||[],V=ne(F,u);let g=0;const S=[...V.map(x=>$(s,x,"feature",g++,n,r)),...l.labels.map(x=>$(s,x,"aggregate",g++,n,r))];return{type:"symbol",target:i,attributes:s,aggregateFields:l.fields,storage:p,mesh:{matcher:c,labels:{type:"simple",classes:S},aggregateMatcher:l.matcher,sortKey:f}}}function He(e){var t;return((t=e.renderer)==null?void 0:t.type)==="heatmap"&&j()==="raster"?{type:"heatmap"}:{type:"symbol"}}function $e(e,t,r,s){if(s!=null)return null;if(t!=null&&t.length){t.length>1&&M.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${t.length}. All but the first will be discarded`);const a=t[0],i=a.order==="ascending"?"asc":"desc";if(a.field)return{field:a.field,order:i};if(a.valueExpression){const l=a.valueExpression;return{fieldIndex:w(e,{type:"expression",target:"feature",valueExpression:l,resultType:"numeric"}).fieldIndex,order:i}}return M.error(new m(d,"Expected to find a field or valueExpression for OrderByInfo",a)),null}return r!=null&&r.type==="unique-value"&&r.orderByClassesEnabled?{byRenderer:!0,order:"asc"}:null}function qe(e,t){const r={mesh:!0,storage:!0};for(const s of t){const{name:a,onStatisticField:i,onStatisticExpression:l,statisticType:u}=s;let o,n;const c="numeric",p="feature";if(l){const f=l.expression;n=w(e,{type:"expression",target:p,valueExpression:f,resultType:c}).fieldIndex}else o=w(e,{type:"field",target:p,field:i,resultType:c}).field;w(e,{type:"statistic",target:"aggregate",name:a,context:r,inField:o,inFieldIndex:n,statisticType:u})}}function ie(e,t,r){let s;switch(r.type){case"simple":case"class-breaks":case"unique-value":case"dictionary":s={visualVariables:!0,attributes:null};break;default:s=Fe(r).getStorageSpec(r);break}return We(e,t,s,r)}function We(e,t,r,s){if(r==null)return null;const{visualVariables:a,attributes:i}=r;let l=null;a&&"visualVariables"in s&&(l=Ue(e,t,s.visualVariables));const u=l!=null?4:0;let o=null;return i!=null&&(o=i.map((n,c)=>{const{field:p,fieldIndex:f}=T(e,{valueExpression:n.valueExpression,field:n.field,resultType:"numeric",target:t});return{binding:c+u,field:p,fieldIndex:f}})),{type:"simple",target:t,attributeMapping:o,vvMapping:l}}function Ue(e,t,r){if(!r||!r.length)return[];const s={storage:!0},a="numeric";return _e(r).map(l=>{const u=Ve(l.type),{field:o,fieldIndex:n}=T(e,{target:t,valueExpression:l.valueExpression,field:l.field,context:s,resultType:a});switch(l.type){case"size":return l.valueExpression==="$view.scale"?null:{type:"size",binding:u,field:o,fieldIndex:n,normalizationField:T(e,{target:t,field:l.normalizationField,context:s,resultType:a}).field,valueRepresentation:l.valueRepresentation??null};case"color":return{type:"color",binding:u,field:o,fieldIndex:n,normalizationField:T(e,{target:t,field:l.normalizationField,context:s,resultType:a}).field};case"opacity":return{type:"opacity",binding:u,field:o,fieldIndex:n,normalizationField:T(e,{target:t,field:l.normalizationField,context:s,resultType:a}).field};case"rotation":return{type:"rotation",binding:u,field:o,fieldIndex:n}}}).filter(Se)}function U(e,t,r,s,a=!1){const i=e??{indexCount:0,fields:{}};switch(r.type){case"simple":case"dot-density":return je(i,r,s,a);case"class-breaks":return Ye(i,t,r,s,a);case"unique-value":return Qe(i,t,r,s,a);case"dictionary":return Ze(i,r,s,a);case"heatmap":return et(i,r,s,a);case"pie-chart":return Xe(i,r,s,a)}}function je(e,t,r,s=!1){const a=t.getSymbols(),i=a.length?a[0]:null;return{type:"simple",symbol:h(i,r,s),symbologyType:r.symbologyType}}function Xe(e,t,r,s=!1){const a=t.getSymbols(),i=a[0],l=a.length>1?a[1]:null;return{type:"pie-chart",markerSymbol:h(i,r,s),fillSymbol:h(l,r,s),symbologyType:r.symbologyType}}function Ye(e,t,r,s,a=!1){const i={mesh:!0,use:"renderer.field"},l=r.backgroundFillSymbol,{field:u,fieldIndex:o}=T(e,{target:t,field:r.field,valueExpression:r.valueExpression,resultType:"numeric",context:i}),n=r.normalizationType,c=n==="log"?"esriNormalizeByLog":n==="percent-of-total"?"esriNormalizeByPercentOfTotal":n==="field"?"esriNormalizeByField":null,p=r.classBreakInfos.map(f=>({symbol:h(f.symbol,s,a),min:f.minValue,max:f.maxValue})).sort((f,F)=>f.min-F.min);return{type:"interval",attributes:e.fields,field:u,fieldIndex:o,backgroundFillSymbol:h(l,s,a),defaultSymbol:h(r.defaultSymbol,s,a),intervals:p,normalizationField:r.normalizationField,normalizationTotal:r.normalizationTotal,normalizationType:c,isMaxInclusive:r.isMaxInclusive,symbologyType:s.symbologyType}}function Qe(e,t,r,s,a=!1){const i=[],l=r.backgroundFillSymbol,n={target:t,context:{mesh:!0},resultType:"string"};if(r.field&&typeof r.field!="string")throw new m(d,"Expected renderer.field to be a string",r);const{field:c,fieldIndex:p}=T(e,{...n,field:r.field,valueExpression:r.valueExpression});for(const f of r.uniqueValueInfos??[])i.push({value:""+f.value,symbol:h(f.symbol,s,a)});return{type:"map",attributes:e.fields,field:c,fieldIndex:p,field2:T(e,{...n,field:r.field2}).field,field3:T(e,{...n,field:r.field3}).field,fieldDelimiter:r.fieldDelimiter??void 0,backgroundFillSymbol:h(l,s),defaultSymbol:h(r.defaultSymbol,s),map:i,symbologyType:s.symbologyType}}function Ze(e,t,r,s=!1){return{type:"dictionary",config:t.config,fieldMap:t.fieldMap,scaleExpression:t.scaleExpression,url:t.url,symbolOptions:r,symbologyType:r.symbologyType}}function et(e,t,r,s=!1){const a=t.getSymbols(),i=a.length?a[0]:null;return{type:"heatmap",symbol:h(i,r,s),symbologyType:r.symbologyType}}export{U as a,h as b,W as c,bt as d,yt as e,dt as i,mt as s};
