const d={convertToGEGeometry:u,exportPoint:r,exportPolygon:l,exportPolyline:e,exportMultipoint:P,exportExtent:m};function u(n,s){return s==null?null:n.convertJSONToGeometry(s)}class a{constructor(s,i,t){this.x=s,this.y=i,this.spatialReference=t,this.z=void 0,this.m=void 0}}function r(n,s,i){const t=new a(n.getPointX(s),n.getPointY(s),i),h=n.hasZ(s),c=n.hasM(s);return h&&(t.z=n.getPointZ(s)),c&&(t.m=n.getPointM(s)),t}class o{constructor(s,i,t,h){this.rings=s,this.spatialReference=i,this.hasZ=void 0,this.hasM=void 0,t&&(this.hasZ=t),h&&(this.hasM=h)}}function l(n,s,i){return new o(n.exportPaths(s),i,n.hasZ(s),n.hasM(s))}class x{constructor(s,i,t,h){this.paths=s,this.spatialReference=i,this.hasZ=void 0,this.hasM=void 0,t&&(this.hasZ=t),h&&(this.hasM=h)}}function e(n,s,i){return new x(n.exportPaths(s),i,n.hasZ(s),n.hasM(s))}class M{constructor(s,i,t,h){this.points=s,this.spatialReference=i,this.hasZ=void 0,this.hasM=void 0,t&&(this.hasZ=t),h&&(this.hasM=h)}}function P(n,s,i){return new M(n.exportPoints(s),i,n.hasZ(s),n.hasM(s))}class Z{constructor(s,i,t,h,c){this.xmin=s,this.ymin=i,this.xmax=t,this.ymax=h,this.spatialReference=c,this.zmin=void 0,this.zmax=void 0,this.mmin=void 0,this.mmax=void 0}}function m(n,s,i){const t=n.hasZ(s),h=n.hasM(s),c=new Z(n.getXMin(s),n.getYMin(s),n.getXMax(s),n.getYMax(s),i);if(t){const f=n.getZExtent(s);c.zmin=f.vmin,c.zmax=f.vmax}if(h){const f=n.getMExtent(s);c.mmin=f.vmin,c.mmax=f.vmax}return c}export{d as j};
