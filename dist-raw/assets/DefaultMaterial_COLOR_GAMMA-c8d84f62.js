import{m as X}from"./vec32-2995a0b7.js";import{gy as W,jd as Q,je as Z,jf as ee,dK as H,t as te,jg as $,r as re,a0 as ne,Z as oe,E as c,dZ as se,jh as ae,dL as ie,az as ue,gE as fe,ja as ce,ji as le,gR as de,f_ as pe,h5 as v,L as C,j4 as he}from"./index-6dc9db96.js";import{c as z,b as V}from"./mat4f64-06a72c15.js";import{a as I,T as R,D as d,P as b}from"./enums-08489827.js";import{V as q}from"./Version-bb3aca60.js";import{g as me}from"./quat-ea995b63.js";import{c as Te}from"./quatf64-5b0101cd.js";import{t as we,p as ye,l as ge,b as F,c as G,a as Y,o as xe,s as _e,n as be,r as Se,u as Ae,q as Ee,D as Ne,m as Oe,y as Be}from"./BufferView-0206cb6b.js";import{j as Me,E as Ce,a as Ie,i as Re}from"./resourceUtils-4053cd3b.js";import{g as Le,n as Fe}from"./Indices-d360054d.js";function gt(r,e,n){Ue(r.typedBuffer,e.typedBuffer,n,r.typedBufferStride,e.typedBufferStride)}function Ue(r,e,n,t=4,o=t){if(r.length/t!==e.length/o){X.error("source and destination buffers need to have the same number of elements");return}const s=r.length/t,a=n[0],i=n[1],u=n[2],l=n[3],f=n[4],h=n[5],m=n[6],w=n[7],y=n[8];let p=0,T=0;for(let A=0;A<s;A++){const S=e[p],x=e[p+1],_=e[p+2],E=e[p+3];r[T]=a*S+l*x+m*_,r[T+1]=i*S+f*x+w*_,r[T+2]=u*S+h*x+y*_,r[T+3]=E,p+=o,T+=t}}function xt(r,e){const n=Math.min(r.count,e.count),t=r.typedBuffer,o=r.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride;for(let i=0;i<n;i++){const u=i*o,l=i*a,f=s[l],h=s[l+1],m=s[l+2],w=f*f+h*h+m*m;if(w>0){const y=1/Math.sqrt(w);t[u]=y*f,t[u+1]=y*h,t[u+2]=y*m}}}function _t(r,e,n){Ve(r.typedBuffer,e,n,r.typedBufferStride)}function Ve(r,e,n,t=4){const o=Math.min(r.length/t,e.count),s=e.typedBuffer,a=e.typedBufferStride;let i=0,u=0;for(let l=0;l<o;l++)r[u]=n*s[i],r[u+1]=n*s[i+1],r[u+2]=n*s[i+2],r[u+3]=n*s[i+3],i+=a,u+=t}function bt(r,e){Pe(r.typedBuffer,e.typedBuffer,r.typedBufferStride,e.typedBufferStride)}function Pe(r,e,n=2,t=n){const o=e.length/2;let s=0,a=0;if(W(e)||Q(e)){for(let u=0;u<o;++u)r[s]=e[a],r[s+1]=e[a+1],s+=n,a+=t;return}const i=Z(e);if(ee(e))for(let u=0;u<o;++u)r[s]=Math.max(e[a]/i,-1),r[s+1]=Math.max(e[a+1]/i,-1),s+=n,a+=t;else for(let u=0;u<o;++u)r[s]=e[a]/i,r[s+1]=e[a+1]/i,s+=n,a+=t}function St(r,e,n,t){const o=r.typedBuffer,s=r.typedBufferStride,a=(t==null?void 0:t.count)??r.count;let i=((t==null?void 0:t.dstIndex)??0)*s;for(let u=0;u<a;++u)o[i]=e,o[i+1]=n,i+=s}function At(r,e){ve(r.typedBuffer,e.typedBuffer,r.typedBufferStride,e.typedBufferStride)}function ve(r,e,n=3,t=n){const o=e.length/t;let s=0,a=0;for(let i=0;i<o;++i)r[s]=e[a],r[s+1]=e[a+1],r[s+2]=e[a+2],s+=n,a+=t}function Et(r,e,n,t,o){const s=r.typedBuffer,a=r.typedBufferStride,i=(o==null?void 0:o.count)??r.count;let u=((o==null?void 0:o.dstIndex)??0)*a;for(let l=0;l<i;++l)s[u]=e,s[u+1]=n,s[u+2]=t,u+=a}function Nt(r,e){Ge(r.typedBuffer,e,r.typedBufferStride)}function Ge(r,e,n=4){const t=e.typedBuffer,o=e.typedBufferStride,s=e.count;let a=0,i=0;for(let u=0;u<s;++u)r[a]=t[i],r[a+1]=t[i+1],r[a+2]=t[i+2],r[a+3]=t[i+3],a+=n,i+=o}function Ot(r,e,n,t,o,s){const a=r.typedBuffer,i=r.typedBufferStride,u=(s==null?void 0:s.count)??r.count;let l=((s==null?void 0:s.dstIndex)??0)*i;for(let f=0;f<u;++f)a[l]=e,a[l+1]=n,a[l+2]=t,a[l+3]=o,l+=i}class Bt{constructor(e){this._streamDataRequester=e}async loadJSON(e,n){return this._load("json",e,n)}async loadBinary(e,n){return H(e)?(te(n),$(e)):this._load("binary",e,n)}async loadImage(e,n){return this._load("image",e,n)}async _load(e,n,t){if(this._streamDataRequester==null)return(await re(n,{responseType:De[e]})).data;const o=await ne(this._streamDataRequester.request(n,e,t));if(o.ok===!0)return o.value;throw oe(o.error),new c("",`Request for resource failed: ${o.error}`)}}const De={image:"image",binary:"array-buffer",json:"json","image+type":void 0};function je(r={}){return{color:[1,1,1],opacity:1,alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1,castShadows:!0,receiveShadows:!0,receiveAmbientOcclustion:!0,textureColor:null,textureNormal:null,textureOcclusion:null,textureEmissive:null,textureMetallicRoughness:null,colorTextureTransform:null,normalTextureTransform:null,occlusionTextureTransform:null,emissiveTextureTransform:null,metallicRoughnessTextureTransform:null,emissiveFactor:[0,0,0],metallicFactor:1,roughnessFactor:1,colorMixMode:"multiply",...r}}function ke(r,e={}){return{data:r,parameters:{wrap:{s:I.REPEAT,t:I.REPEAT,...e.wrap},noUnpackFlip:!0,mipmap:!1,...e}}}function U(r,e){const n=r.count;e||(e=new r.TypedArrayConstructor(n));for(let t=0;t<n;t++)e[t]=r.get(t);return e}class D{constructor(e){this._data=e,this._offset4=0,this._dataUint32=new Uint32Array(this._data,0,Math.floor(this._data.byteLength/4))}readUint32(){const e=this._offset4;return this._offset4+=1,this._dataUint32[e]}readUint8Array(e){const n=this._offset4*4;return this._offset4+=e/4,new Uint8Array(this._data,n,e)}remainingBytes(){return this._data.byteLength-this._offset4*4}}var N;(function(r){r.SCALAR="SCALAR",r.VEC2="VEC2",r.VEC3="VEC3",r.VEC4="VEC4",r.MAT2="MAT2",r.MAT3="MAT3",r.MAT4="MAT4"})(N||(N={}));var j;(function(r){r[r.ARRAY_BUFFER=34962]="ARRAY_BUFFER",r[r.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER"})(j||(j={}));const K={baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1},He={pbrMetallicRoughness:K,emissiveFactor:[0,0,0],alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1},$e={ESRI_externalColorMixMode:"tint"},k=(r={})=>{const e={...K,...r.pbrMetallicRoughness},n=ze({...$e,...r.extras});return{...He,...r,pbrMetallicRoughness:e,extras:n}};function ze(r){switch(r.ESRI_externalColorMixMode){case"multiply":case"tint":case"ignore":case"replace":break;default:se(r.ESRI_externalColorMixMode),r.ESRI_externalColorMixMode="tint"}return r}const qe={magFilter:R.LINEAR,minFilter:R.LINEAR_MIPMAP_LINEAR,wrapS:I.REPEAT,wrapT:I.REPEAT},Ye=r=>({...qe,...r});function Ke(r){let e,n;return r.replace(/^(.*\/)?([^/]*)$/,(t,o,s)=>(e=o||"",n=s||"","")),{dirPart:e,filePart:n}}const B={MAGIC:1179937895,CHUNK_TYPE_JSON:1313821514,CHUNK_TYPE_BIN:5130562,MIN_HEADER_LENGTH:20};class g{constructor(e,n,t,o){if(this._context=e,this.uri=n,this.json=t,this._glbBuffer=o,this._bufferLoaders=new Map,this._textureLoaders=new Map,this._textureCache=new Map,this._materialCache=new Map,this._nodeParentMap=new Map,this._nodeTransformCache=new Map,this._supportedExtensions=["KHR_texture_basisu"],this._baseUri=Ke(this.uri).dirPart,this._checkVersionSupported(),this._checkRequiredExtensionsSupported(),t.scenes==null)throw new c("gltf-loader-unsupported-feature","Scenes must be defined.");if(t.meshes==null)throw new c("gltf-loader-unsupported-feature","Meshes must be defined");if(t.nodes==null)throw new c("gltf-loader-unsupported-feature","Nodes must be defined.");this._computeNodeParents()}static async load(e,n,t){if(H(n)){const a=ie(n);if(a&&a.mediaType!=="model/gltf-binary")try{const u=JSON.parse(a.isBase64?atob(a.data):a.data);return new g(e,n,u)}catch{}const i=$(n);if(g._isGLBData(i))return this._fromGLBData(e,n,i)}if(n.endsWith(".gltf")){const a=await e.loadJSON(n,t);return new g(e,n,a)}const o=await e.loadBinary(n,t);if(g._isGLBData(o))return this._fromGLBData(e,n,o);const s=await e.loadJSON(n,t);return new g(e,n,s)}static _isGLBData(e){if(e==null)return!1;const n=new D(e);return n.remainingBytes()>=4&&n.readUint32()===B.MAGIC}static async _fromGLBData(e,n,t){const o=await g._parseGLBData(t);return new g(e,n,o.json,o.binaryData)}static async _parseGLBData(e){const n=new D(e);if(n.remainingBytes()<12)throw new c("gltf-loader-error","GLB binary data is insufficiently large.");const t=n.readUint32(),o=n.readUint32(),s=n.readUint32();if(t!==B.MAGIC)throw new c("gltf-loader-error","Magic first 4 bytes do not fit to expected GLB value.");if(e.byteLength<s)throw new c("gltf-loader-error","GLB binary data is smaller than header specifies.");if(o!==2)throw new c("gltf-loader-unsupported-feature","An unsupported GLB container version was detected. Only version 2 is supported.");let a=0,i,u;for(;n.remainingBytes()>=8;){const l=n.readUint32(),f=n.readUint32();if(a===0){if(f!==B.CHUNK_TYPE_JSON)throw new c("gltf-loader-error","First GLB chunk must be JSON.");if(l<0)throw new c("gltf-loader-error","No JSON data found.");i=await Me(n.readUint8Array(l))}else if(a===1){if(f!==B.CHUNK_TYPE_BIN)throw new c("gltf-loader-unsupported-feature","Second GLB chunk expected to be BIN.");u=n.readUint8Array(l)}else C.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] More than 2 GLB chunks detected. Skipping.");a+=1}if(!i)throw new c("gltf-loader-error","No GLB JSON chunk detected.");return{json:i,binaryData:u}}async getBuffer(e,n){const t=this.json.buffers[e];if(t.uri==null){if(this._glbBuffer==null)throw new c("gltf-loader-error","GLB buffer not present");return this._glbBuffer}const o=await this._getBufferLoader(e,n);if(o.byteLength!==t.byteLength)throw new c("gltf-loader-error","Buffer byte lengths should match.");return o}async _getBufferLoader(e,n){const t=this._bufferLoaders.get(e);if(t)return t;const o=this.json.buffers[e].uri,s=this._context.loadBinary(this._resolveUri(o),n).then(a=>new Uint8Array(a));return this._bufferLoaders.set(e,s),s}async getAccessor(e,n){if(!this.json.accessors)throw new c("gltf-loader-unsupported-feature","Accessors missing.");const t=this.json.accessors[e];if((t==null?void 0:t.bufferView)==null)throw new c("gltf-loader-unsupported-feature","Some accessor does not specify a bufferView.");if(t.type in[N.MAT2,N.MAT3,N.MAT4])throw new c("gltf-loader-unsupported-feature",`AttributeType ${t.type} is not supported`);const o=this.json.bufferViews[t.bufferView],s=await this.getBuffer(o.buffer,n),a=We[t.type],i=Qe[t.componentType],u=a*i,l=o.byteStride||u;return{raw:s.buffer,byteStride:l,byteOffset:s.byteOffset+(o.byteOffset||0)+(t.byteOffset||0),entryCount:t.count,isDenselyPacked:l===u,componentCount:a,componentByteSize:i,componentType:t.componentType,min:t.min,max:t.max,normalized:!!t.normalized}}async getIndexData(e,n){if(e.indices==null)return;const t=await this.getAccessor(e.indices,n);if(t.isDenselyPacked)switch(t.componentType){case d.UNSIGNED_BYTE:return new Uint8Array(t.raw,t.byteOffset,t.entryCount);case d.UNSIGNED_SHORT:return new Uint16Array(t.raw,t.byteOffset,t.entryCount);case d.UNSIGNED_INT:return new Uint32Array(t.raw,t.byteOffset,t.entryCount)}else switch(t.componentType){case d.UNSIGNED_BYTE:return U(this._wrapAccessor(ge,t));case d.UNSIGNED_SHORT:return U(this._wrapAccessor(ye,t));case d.UNSIGNED_INT:return U(this._wrapAccessor(we,t))}}async getPositionData(e,n){if(e.attributes.POSITION==null)throw new c("gltf-loader-unsupported-feature","No POSITION vertex data found.");const t=await this.getAccessor(e.attributes.POSITION,n);if(t.componentType!==d.FLOAT)throw new c("gltf-loader-unsupported-feature","Expected type FLOAT for POSITION vertex attribute, but found "+d[t.componentType]);if(t.componentCount!==3)throw new c("gltf-loader-unsupported-feature","POSITION vertex attribute must have 3 components, but found "+t.componentCount.toFixed());return this._wrapAccessor(F,t)}async getNormalData(e,n){if(e.attributes.NORMAL==null)throw new c("gltf-loader-error","No NORMAL vertex data found.");const t=await this.getAccessor(e.attributes.NORMAL,n);if(t.componentType!==d.FLOAT)throw new c("gltf-loader-unsupported-feature","Expected type FLOAT for NORMAL vertex attribute, but found "+d[t.componentType]);if(t.componentCount!==3)throw new c("gltf-loader-unsupported-feature","NORMAL vertex attribute must have 3 components, but found "+t.componentCount.toFixed());return this._wrapAccessor(F,t)}async getTangentData(e,n){if(e.attributes.TANGENT==null)throw new c("gltf-loader-error","No TANGENT vertex data found.");const t=await this.getAccessor(e.attributes.TANGENT,n);if(t.componentType!==d.FLOAT)throw new c("gltf-loader-unsupported-feature","Expected type FLOAT for TANGENT vertex attribute, but found "+d[t.componentType]);if(t.componentCount!==4)throw new c("gltf-loader-unsupported-feature","TANGENT vertex attribute must have 4 components, but found "+t.componentCount.toFixed());return new G(t.raw,t.byteOffset,t.byteStride,t.byteOffset+t.byteStride*t.entryCount)}async getTextureCoordinates(e,n){if(e.attributes.TEXCOORD_0==null)throw new c("gltf-loader-error","No TEXCOORD_0 vertex data found.");const t=await this.getAccessor(e.attributes.TEXCOORD_0,n);if(t.componentCount!==2)throw new c("gltf-loader-unsupported-feature","TEXCOORD_0 vertex attribute must have 2 components, but found "+t.componentCount.toFixed());if(t.componentType===d.FLOAT)return this._wrapAccessor(Y,t);if(!t.normalized)throw new c("gltf-loader-unsupported-feature","Integer component types are only supported for a normalized accessor for TEXCOORD_0.");return Ze(t)}async getVertexColors(e,n){if(e.attributes.COLOR_0==null)throw new c("gltf-loader-error","No COLOR_0 vertex data found.");const t=await this.getAccessor(e.attributes.COLOR_0,n);if(t.componentCount!==4&&t.componentCount!==3)throw new c("gltf-loader-unsupported-feature","COLOR_0 attribute must have 3 or 4 components, but found "+t.componentCount.toFixed());if(t.componentCount===4){if(t.componentType===d.FLOAT)return this._wrapAccessor(G,t);if(t.componentType===d.UNSIGNED_BYTE)return this._wrapAccessor(xe,t);if(t.componentType===d.UNSIGNED_SHORT)return this._wrapAccessor(_e,t)}else if(t.componentCount===3){if(t.componentType===d.FLOAT)return this._wrapAccessor(F,t);if(t.componentType===d.UNSIGNED_BYTE)return this._wrapAccessor(be,t);if(t.componentType===d.UNSIGNED_SHORT)return this._wrapAccessor(Se,t)}throw new c("gltf-loader-unsupported-feature","Unsupported component type for COLOR_0 attribute: "+d[t.componentType])}hasPositions(e){return e.attributes.POSITION!==void 0}hasNormals(e){return e.attributes.NORMAL!==void 0}hasVertexColors(e){return e.attributes.COLOR_0!==void 0}hasTextureCoordinates(e){return e.attributes.TEXCOORD_0!==void 0}hasTangents(e){return e.attributes.TANGENT!==void 0}async getMaterial(e,n,t){var s,a,i,u,l,f,h,m,w,y;let o=e.material?this._materialCache.get(e.material):void 0;if(!o){const p=e.material!=null?k(this.json.materials[e.material]):k(),T=p.pbrMetallicRoughness,A=this.hasVertexColors(e),S=this.getTexture(T.baseColorTexture,n),x=this.getTexture(p.normalTexture,n),_=t?this.getTexture(p.occlusionTexture,n):void 0,E=t?this.getTexture(p.emissiveTexture,n):void 0,O=t?this.getTexture(T.metallicRoughnessTexture,n):void 0,L=e.material!=null?e.material:-1;o={alphaMode:p.alphaMode,alphaCutoff:p.alphaCutoff,color:T.baseColorFactor,doubleSided:!!p.doubleSided,colorTexture:await S,normalTexture:await x,name:p.name,id:L,occlusionTexture:await _,emissiveTexture:await E,emissiveFactor:p.emissiveFactor,metallicFactor:T.metallicFactor,roughnessFactor:T.roughnessFactor,metallicRoughnessTexture:await O,hasVertexColors:A,ESRI_externalColorMixMode:p.extras.ESRI_externalColorMixMode,colorTextureTransform:(a=(s=T==null?void 0:T.baseColorTexture)==null?void 0:s.extensions)==null?void 0:a.KHR_texture_transform,normalTextureTransform:(u=(i=p.normalTexture)==null?void 0:i.extensions)==null?void 0:u.KHR_texture_transform,occlusionTextureTransform:(f=(l=p.occlusionTexture)==null?void 0:l.extensions)==null?void 0:f.KHR_texture_transform,emissiveTextureTransform:(m=(h=p.emissiveTexture)==null?void 0:h.extensions)==null?void 0:m.KHR_texture_transform,metallicRoughnessTextureTransform:(y=(w=T==null?void 0:T.metallicRoughnessTexture)==null?void 0:w.extensions)==null?void 0:y.KHR_texture_transform}}return o}async getTexture(e,n){if(!e)return;if((e.texCoord||0)!==0)throw new c("gltf-loader-unsupported-feature","Only TEXCOORD with index 0 is supported.");const t=e.index,o=this.json.textures[t],s=Ye(o.sampler!=null?this.json.samplers[o.sampler]:{}),a=this._getTextureSourceId(o),i=this.json.images[a],u=await this._loadTextureImageData(t,o,n);return ue(this._textureCache,t,()=>{const l=h=>h===33071||h===33648||h===10497,f=h=>{throw new c("gltf-loader-error",`Unexpected TextureSampler WrapMode: ${h}`)};return{data:u,wrapS:l(s.wrapS)?s.wrapS:f(s.wrapS),wrapT:l(s.wrapT)?s.wrapT:f(s.wrapT),minFilter:s.minFilter,name:i.name,id:t}})}getNodeTransform(e){if(e===void 0)return Je;let n=this._nodeTransformCache.get(e);if(!n){const t=this.getNodeTransform(this._getNodeParent(e)),o=this.json.nodes[e];o.matrix?n=fe(z(),t,o.matrix):o.translation||o.rotation||o.scale?(n=V(t),o.translation&&ce(n,n,o.translation),o.rotation&&(M[3]=me(M,o.rotation),le(n,n,M[3],M)),o.scale&&de(n,n,o.scale)):n=V(t),this._nodeTransformCache.set(e,n)}return n}_wrapAccessor(e,n){return new e(n.raw,n.byteOffset,n.byteStride,n.byteOffset+n.byteStride*(n.entryCount-1)+n.componentByteSize*n.componentCount)}_resolveUri(e){return pe(e,this._baseUri)}_getNodeParent(e){return this._nodeParentMap.get(e)}_checkVersionSupported(){const e=q.parse(this.json.asset.version,"glTF");Xe.validate(e)}_checkRequiredExtensionsSupported(){const e=this.json;if(e.extensionsRequired&&!e.extensionsRequired.every(t=>this._supportedExtensions.includes(t)))throw new c("gltf-loader-unsupported-feature","gltf loader was not able to load unsupported feature. Required extensions: "+e.extensionsRequired.join(", "))}_computeNodeParents(){this.json.nodes.forEach((e,n)=>{e.children&&e.children.forEach(t=>{this._nodeParentMap.set(t,n)})})}async _loadTextureImageData(e,n,t){const o=this._textureLoaders.get(e);if(o)return o;const s=this._createTextureLoader(n,t);return this._textureLoaders.set(e,s),s}_getTextureSourceId(e){if(e.extensions!==void 0&&e.extensions.KHR_texture_basisu!==null)return e.extensions.KHR_texture_basisu.source;if(e.source!==null)return e.source;throw new c("gltf-loader-unsupported-feature","Source is expected to be defined for a texture. It can also be omitted in favour of an KHR_texture_basisu extension tag.")}async _createTextureLoader(e,n){const t=this._getTextureSourceId(e),o=this.json.images[t];if(o.uri){if(o.uri.endsWith(".ktx2")){const u=await this._context.loadBinary(this._resolveUri(o.uri),n);return new Ce(new Uint8Array(u))}return this._context.loadImage(this._resolveUri(o.uri),n)}if(o.bufferView==null)throw new c("gltf-loader-unsupported-feature","Image bufferView must be defined.");if(o.mimeType==null)throw new c("gltf-loader-unsupported-feature","Image mimeType must be defined.");const s=this.json.bufferViews[o.bufferView],a=await this.getBuffer(s.buffer,n);if(s.byteStride!=null)throw new c("gltf-loader-unsupported-feature","byteStride not supported for image buffer");const i=a.byteOffset+(s.byteOffset||0);return Ie(new Uint8Array(a.buffer,i,s.byteLength),o.mimeType)}async getLoadedBuffersSize(){if(this._glbBuffer)return this._glbBuffer.byteLength;const e=await v(Array.from(this._bufferLoaders.values())),n=await v(Array.from(this._textureLoaders.values()));return e.reduce((t,o)=>t+((o==null?void 0:o.byteLength)??0),0)+n.reduce((t,o)=>t+(o?Re(o)?o.data.byteLength:o.width*o.height*4:0),0)}}const Je=ae(z(),Math.PI/2),Xe=new q(2,0,"glTF"),M=Te(),We={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Qe={[d.BYTE]:1,[d.UNSIGNED_BYTE]:1,[d.SHORT]:2,[d.UNSIGNED_SHORT]:2,[d.FLOAT]:4,[d.INT]:4,[d.UNSIGNED_INT]:4};function Ze(r){switch(r.componentType){case d.BYTE:return new Be(r.raw,r.byteOffset,r.byteStride,r.byteOffset+r.byteStride*r.entryCount);case d.UNSIGNED_BYTE:return new Oe(r.raw,r.byteOffset,r.byteStride,r.byteOffset+r.byteStride*r.entryCount);case d.SHORT:return new Ne(r.raw,r.byteOffset,r.byteStride,r.byteOffset+r.byteStride*r.entryCount);case d.UNSIGNED_SHORT:return new Ee(r.raw,r.byteOffset,r.byteStride,r.byteOffset+r.byteStride*r.entryCount);case d.UNSIGNED_INT:return new Ae(r.raw,r.byteOffset,r.byteStride,r.byteOffset+r.byteStride*r.entryCount);case d.FLOAT:return new Y(r.raw,r.byteOffset,r.byteStride,r.byteOffset+r.byteStride*r.entryCount)}}let et=0;async function Mt(r,e,n={},t=!0){const o=await g.load(r,e,n),s=`gltf_${et++}`,a={lods:[],materials:new Map,textures:new Map,meta:tt(o)},i=!!(o.json.asset.extras&&o.json.asset.extras.ESRI_type==="symbolResource"),u=new Map;await rt(o,async(f,h,m,w)=>{const y=u.get(m)??0;u.set(m,y+1);const p=f.mode!==void 0?f.mode:b.TRIANGLES,T=p===b.TRIANGLES||p===b.TRIANGLE_STRIP||p===b.TRIANGLE_FAN?p:null;if(T==null){C.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Unsupported primitive mode ("+b[p]+"). Skipping primitive.");return}if(!o.hasPositions(f)){C.getLogger("esri.views.3d.glTF").warn("Skipping primitive without POSITION vertex attribute.");return}const A=o.getPositionData(f,n),S=o.getMaterial(f,n,t),x=o.hasNormals(f)?o.getNormalData(f,n):null,_=o.hasTangents(f)?o.getTangentData(f,n):null,E=o.hasTextureCoordinates(f)?o.getTextureCoordinates(f,n):null,O=o.hasVertexColors(f)?o.getVertexColors(f,n):null,L=o.getIndexData(f,n),J={transform:V(h),attributes:{position:await A,normal:x?await x:null,texCoord0:E?await E:null,color:O?await O:null,tangent:_?await _:null},indices:await L,primitiveType:T,material:ot(a,await S,s)};let P=null;a.meta!=null&&a.meta.ESRI_lod!=null&&a.meta.ESRI_lod.metric==="screenSpaceRadius"&&(P=a.meta.ESRI_lod.thresholds[m]),a.lods[m]=a.lods[m]||{parts:[],name:w,lodThreshold:P},a.lods[m].parts[y]=J});for(const f of a.lods)f.parts=f.parts.filter(h=>!!h);const l=await o.getLoadedBuffersSize();return{model:a,meta:{isEsriSymbolResource:i,uri:o.uri},customMeta:{},size:l}}function tt(r){const e=r.json;let n=null;return e.nodes.forEach(t=>{const o=t.extras;o!=null&&(o.ESRI_proxyEllipsoid||o.ESRI_lod)&&(n=o)}),n}async function rt(r,e){const n=r.json,o=n.scenes[n.scene||0].nodes,s=o.length>1,a=[];for(const u of o){const l=n.nodes[u];a.push(i(u,0)),nt(l)&&!s&&l.extensions.MSFT_lod.ids.forEach((h,m)=>i(h,m+1))}async function i(u,l){const f=n.nodes[u],h=r.getNodeTransform(u);if(f.weights!=null&&C.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Morph targets are not supported."),f.mesh!=null){const m=n.meshes[f.mesh];for(const w of m.primitives)a.push(e(w,h,l,m.name))}for(const m of f.children||[])a.push(i(m,l))}await Promise.all(a)}function nt(r){return r.extensions&&r.extensions.MSFT_lod&&Array.isArray(r.extensions.MSFT_lod.ids)}function ot(r,e,n){const t=s=>{const a=`${n}_tex_${s&&s.id}${s&&s.name?"_"+s.name:""}`;if(s&&!r.textures.has(a)){const i=ke(s.data,{wrap:{s:s.wrapS,t:s.wrapT},mipmap:st.includes(s.minFilter),noUnpackFlip:!0});r.textures.set(a,i)}return a},o=`${n}_mat_${e.id}_${e.name}`;if(!r.materials.has(o)){const s=je({color:[e.color[0],e.color[1],e.color[2]],opacity:e.color[3],alphaMode:e.alphaMode,alphaCutoff:e.alphaCutoff,doubleSided:e.doubleSided,colorMixMode:e.ESRI_externalColorMixMode,textureColor:e.colorTexture?t(e.colorTexture):void 0,textureNormal:e.normalTexture?t(e.normalTexture):void 0,textureOcclusion:e.occlusionTexture?t(e.occlusionTexture):void 0,textureEmissive:e.emissiveTexture?t(e.emissiveTexture):void 0,textureMetallicRoughness:e.metallicRoughnessTexture?t(e.metallicRoughnessTexture):void 0,emissiveFactor:[e.emissiveFactor[0],e.emissiveFactor[1],e.emissiveFactor[2]],colorTextureTransform:e.colorTextureTransform,normalTextureTransform:e.normalTextureTransform,occlusionTextureTransform:e.occlusionTextureTransform,emissiveTextureTransform:e.emissiveTextureTransform,metallicRoughnessTextureTransform:e.metallicRoughnessTextureTransform,metallicFactor:e.metallicFactor,roughnessFactor:e.roughnessFactor});r.materials.set(o,s)}return o}const st=[R.LINEAR_MIPMAP_LINEAR,R.LINEAR_MIPMAP_NEAREST];function Ct(r,e){switch(e){case b.TRIANGLES:return at(r);case b.TRIANGLE_STRIP:return it(r);case b.TRIANGLE_FAN:return ut(r)}}function at(r){return typeof r=="number"?Le(r):he(r)?new Uint16Array(r):r}function it(r){const e=typeof r=="number"?r:r.length;if(e<3)return[];const n=e-2,t=Fe(n*3);if(typeof r=="number"){let o=0;for(let s=0;s<n;s+=1)s%2===0?(t[o++]=s,t[o++]=s+1,t[o++]=s+2):(t[o++]=s+1,t[o++]=s,t[o++]=s+2)}else{let o=0;for(let s=0;s<n;s+=1)s%2===0?(t[o++]=r[s],t[o++]=r[s+1],t[o++]=r[s+2]):(t[o++]=r[s+1],t[o++]=r[s],t[o++]=r[s+2])}return t}function ut(r){const e=typeof r=="number"?r:r.length;if(e<3)return new Uint16Array(0);const n=e-2,t=n<=65536?new Uint16Array(n*3):new Uint32Array(n*3);if(typeof r=="number"){let i=0;for(let u=0;u<n;++u)t[i++]=0,t[i++]=u+1,t[i++]=u+2;return t}const o=r[0];let s=r[1],a=0;for(let i=0;i<n;++i){const u=r[i+2];t[a++]=o,t[a++]=s,t[a++]=u,s=u}return t}const It=2.1;export{It as C,Bt as D,Ge as a,ve as b,Ct as c,gt as d,xt as e,Et as f,Ot as g,bt as h,St as i,_t as j,Nt as k,Mt as l,At as m,Pe as n,Ve as s,Ue as t};
