import{r as fe,a as ce,b as pe,c as we,d as he,p as me,i as A,e as _,N as H,f as ge,A as ye,g as ee,R as y,I as T,v as w,h as b,j as q,k as v,l as m,D as C,m as K,n as k,o as L,q as ve,s as M,t as h,u as d,w as N,x as O,y as Se,z as be,F as re,B as Fe,S as V,C as Q,E as Ie}from"./arcadeUtils-80816d64.js";import{A as n,E as u,e as Re}from"./executionError-e2eca390.js";import{registerFunctions as Ae}from"./geomasync-4facb469.js";import{bt as ae,cJ as X}from"./index-0cbe37a0.js";import"./arcadeTimeUtils-e5ed1ad1.js";import"./FieldsIndex-91c8dad2.js";import"./number-48cbe170.js";import"./Field-a5856a62.js";import"./fieldType-7585de06.js";import"./featureConversionUtils-f0b03e2b.js";import"./OptimizedGeometry-af84d2ad.js";import"./OptimizedFeatureSet-5c82fe5a.js";import"./sizeVariableUtils-2914222a.js";import"./geometryEngineAsync-9b4c376b.js";import"./portalUtils-03ea3307.js";function Z(r){return r&&typeof r.then=="function"}const G=100;async function J(r,e){const a=[];for(let t=0;t<e.arguments.length;t++)a.push(await o(r,e.arguments[t]));return a}async function I(r,e,a){if(e.preparsed===!0)return a(r,null,e.arguments);const t=await J(r,e);return a(r,e,t)}class Ce extends Fe{constructor(e,a){super(),this.definition=null,this.context=null,this.definition=e,this.context=a}createFunction(e){return(...t)=>{const i={spatialReference:this.context.spatialReference,console:this.context.console,lrucache:this.context.lrucache,timeReference:this.context.timeReference??null,exports:this.context.exports,libraryResolver:this.context.libraryResolver,interceptor:this.context.interceptor,localScope:{},depthCounter:{depth:e.depthCounter+1},globalScope:this.context.globalScope};if(i.depthCounter.depth>64)throw new n(e,u.MaximumCallDepth,null);return U(this.definition,i,t,null)}}call(e,a){return B(e,a,(t,i,s)=>{const l={spatialReference:e.spatialReference,services:e.services,console:e.console,libraryResolver:e.libraryResolver,exports:e.exports,lrucache:e.lrucache,timeReference:e.timeReference??null,interceptor:e.interceptor,localScope:{},abortSignal:e.abortSignal,globalScope:e.globalScope,depthCounter:{depth:e.depthCounter.depth+1}};if(l.depthCounter.depth>64)throw new n(e,u.MaximumCallDepth,a);return U(this.definition,l,s,a)})}marshalledCall(e,a,t,i){return i(e,a,async(s,l,f)=>{const c={spatialReference:e.spatialReference,globalScope:t.globalScope,depthCounter:{depth:e.depthCounter.depth+1},libraryResolver:e.libraryResolver,exports:e.exports,console:e.console,abortSignal:e.abortSignal,lrucache:e.lrucache,timeReference:e.timeReference??null,interceptor:e.interceptor,localScope:{}};return f=f.map(p=>v(p)&&!(p instanceof V)?Q(p,e,i):p),Q(await U(this.definition,c,f,a),t,i)})}}class E extends Ie{constructor(e){super(e)}async global(e){const a=this.executingContext.globalScope[e.toLowerCase()];if(a.valueset||(a.value=await o(this.executingContext,a.node),a.valueset=!0),v(a.value)&&!(a.value instanceof V)){const t=new V;t.fn=a.value,t.parameterEvaluator=B,t.context=this.executingContext,a.value=t}return a.value}setGlobal(e,a){if(v(a))throw new n(null,u.AssignModuleFunction,null);this.executingContext.globalScope[e.toLowerCase()]={value:a,valueset:!0,node:null}}hasGlobal(e){return this.executingContext.exports[e]===void 0&&(e=e.toLowerCase()),this.executingContext.exports[e]!==void 0}async loadModule(e){let a=e.spatialReference;a==null&&(a=new ae({wkid:102100})),this.moduleScope=ne({},e.customfunctions,e.timeReference),this.executingContext={spatialReference:a,services:e.services,libraryResolver:new ee(e.libraryResolver._moduleSingletons,this.source.syntax.loadedModules),exports:{},abortSignal:e.abortSignal===void 0||e.abortSignal===null?{aborted:!1}:e.abortSignal,globalScope:this.moduleScope,console:e.console??ue,lrucache:e.lrucache,timeReference:e.timeReference??null,interceptor:e.interceptor,localScope:null,depthCounter:{depth:1}},await o(this.executingContext,this.source.syntax)}}async function B(r,e,a){if(e.preparsed===!0){const s=a(r,null,e.arguments);return Z(s),s}const t=await J(r,e),i=a(r,e,t);return Z(i),i}async function o(r,e,a){if(e.breakpoint&&a!==!0)return await e.breakpoint(),o(r,e,!0);try{switch(e==null?void 0:e.type){case"VariableDeclarator":return await ze(r,e);case"ImportDeclaration":return await Ve(r,e);case"ExportNamedDeclaration":return await We(r,e);case"VariableDeclaration":return await ie(r,e,0);case"BlockStatement":case"Program":return await Ge(r,e);case"FunctionDeclaration":return await _e(r,e);case"ReturnStatement":return await Ue(r,e);case"IfStatement":return await ke(r,e);case"ExpressionStatement":return await Ke(r,e);case"UpdateExpression":return await Pe(r,e);case"AssignmentExpression":return await qe(r,e);case"ForStatement":return await Be(r,e);case"WhileStatement":return await Le(r,e);case"ForInStatement":return await Te(r,e);case"BreakStatement":return b;case"EmptyStatement":return w;case"ContinueStatement":return q;case"TemplateElement":return await Qe(r,e);case"TemplateLiteral":return await Ze(r,e);case"Identifier":return await Y(r,e);case"MemberExpression":return await $e(r,e);case"Literal":return e.value;case"CallExpression":return await de(r,e);case"UnaryExpression":return await je(r,e);case"BinaryExpression":return await Je(r,e);case"LogicalExpression":return await Ye(r,e);case"ArrayExpression":return await He(r,e);case"ObjectExpression":return await Ee(r,e);case"Property":return await Me(r,e);default:throw new n(r,u.Unrecognised,e)}}catch(t){throw Re(r,e,t)}}async function Ee(r,e){const a=[];for(let l=0;l<e.properties.length;l++)a[l]=await o(r,e.properties[l]);const t={},i=new Map;for(let l=0;l<a.length;l++){const f=a[l];if(v(f.value))throw new n(r,u.NoFunctionInDictionary,e);if(m(f.key)===!1)throw new n(r,u.KeyMustBeString,e);let c=f.key.toString();const p=c.toLowerCase();i.has(p)?c=i.get(p):i.set(p,c),f.value===w?t[c]=null:t[c]=f.value}const s=new C(t);return s.immutable=!1,s}async function Me(r,e){const a=await o(r,e.value);return e.key.type==="Identifier"?{key:e.key.name,value:a}:{key:await o(r,e.key),value:a}}async function Le(r,e){const a={testResult:!0,lastAction:w};if(a.testResult=await o(r,e.test),a.testResult===!1)return w;if(a.testResult!==!0)throw new n(r,u.BooleanConditionRequired,e);for(;a.testResult===!0&&(a.lastAction=await o(r,e.body),!(a.lastAction===b||a.lastAction instanceof y));)if(a.testResult=await o(r,e.test),a.testResult!==!0&&a.testResult!==!1)throw new n(r,u.BooleanConditionRequired,e);return a.lastAction instanceof y?a.lastAction:w}async function x(r,e,a){const t=await o(r,e.body);return a.lastAction=t,a.lastAction===b||a.lastAction instanceof y?(a.testResult=!1,a):(e.update!==null&&await o(r,e.update),a)}async function Ne(r,e,a){var t;if(e.test!==null){const i=await o(r,e.test);if(((t=r.abortSignal)==null?void 0:t.aborted)===!0)throw new n(r,u.Cancelled,e);if(a.testResult=i,a.testResult===!1)return a;if(a.testResult!==!0)throw new n(r,u.BooleanConditionRequired,e);return x(r,e,a)}return x(r,e,a)}function P(r,e,a,t,i,s){try{Ne(r,e,a).then(()=>{try{a.testResult===!0?(s++,s>G?(s=0,setTimeout(()=>{P(r,e,a,t,i,s)},0)):P(r,e,a,t,i,s)):a.lastAction instanceof y?t(a.lastAction):t(w)}catch(l){i(l)}},l=>{i(l)})}catch(l){i(l)}}function Be(r,e){try{return e.init!==null?o(r,e.init).then(()=>new Promise((a,t)=>{P(r,e,{testResult:!0,lastAction:w},s=>{a(s)},s=>{t(s)},0)})):new Promise((a,t)=>{P(r,e,{testResult:!0,lastAction:w},s=>{a(s)},s=>{t(s)},0)})}catch(a){return Promise.reject(a)}}function W(r,e,a,t,i,s,l,f,c,p){try{if(t<=s){f(w);return}l==="k"?i.value=a[s]:i.value=s,o(r,e.body).then(F=>{try{F instanceof y?f(F):F===b?f(w):(p++,p>G?(p=0,setTimeout(()=>{W(r,e,a,t,i,s+1,l,f,c,p)},0)):W(r,e,a,t,i,s+1,l,f,c,p))}catch(R){c(R)}},F=>{c(F)})}catch(F){c(F)}}function z(r,e,a,t,i,s,l,f,c){try{if(a.length()<=i){l(w);return}s==="k"?t.value=a.get(i):t.value=i,o(r,e.body).then(p=>{p instanceof y?l(p):p===b?l(w):(c++,c>G?(c=0,setTimeout(()=>{z(r,e,a,t,i+1,s,l,f,c)},0)):z(r,e,a,t,i+1,s,l,f,c))},p=>{f(p)})}catch(p){f(p)}}function $(r,e,a,t,i,s){try{if(s===void 0&&(s="i"),a.length===0){t.resolve(w);return}W(r,e,a,a.length,i,0,s,l=>{t.resolve(l)},l=>{t.reject(l)},0)}catch(l){t.reject(l)}}function De(r,e,a,t,i,s){try{if(s===void 0&&(s="i"),a.length===0){t.resolve(w);return}z(r,e,a,i,0,s,l=>{t.resolve(l)},l=>{t.reject(l)},0)}catch(l){t.reject(l)}}function Oe(r,e,a,t,i){try{const s=a.keys();$(r,e,s,t,i,"k")}catch(s){t.reject(s)}}function j(r,e,a,t,i,s,l,f){try{r.next().then(c=>{try{if(c===null)s(w);else{const p=re.createFromGraphicLikeObject(c.geometry,c.attributes,t,e.timeReference);p._underlyingGraphic=c,i.value=p,o(e,a.body).then(R=>{try{R===b?s(w):R instanceof y?s(R):(f++,f>G?(f=0,setTimeout(()=>{j(r,e,a,t,i,s,l,f)},0)):j(r,e,a,t,i,s,l,f))}catch(oe){l(oe)}},R=>{l(R)})}}catch(p){l(p)}},c=>{l(c)})}catch(c){l(c)}}async function Te(r,e){return new Promise((a,t)=>{o(r,e.right).then(i=>{try{let s=null;e.left.type==="VariableDeclaration"?s=o(r,e.left):s=Promise.resolve(),s.then(()=>{try{let l="";if(e.left.type==="VariableDeclaration"){const c=e.left.declarations[0].id;c.type==="Identifier"&&(l=c.name)}else e.left.type==="Identifier"&&(l=e.left.name);if(!l)throw new n(r,u.InvalidIdentifier,e);l=l.toLowerCase();let f=null;if(r.localScope!=null&&r.localScope[l]!==void 0&&(f=r.localScope[l]),f===null&&r.globalScope[l]!==void 0&&(f=r.globalScope[l]),f===null){t(new n(r,u.InvalidIdentifier,e));return}K(i)||m(i)?$(r,e,i,{reject:t,resolve:a},f):k(i)?De(r,e,i,{reject:t,resolve:a},f):i instanceof C||L(i)?Oe(r,e,i,{reject:t,resolve:a},f):ve(i)?j(i.iterator(r.abortSignal),r,e,i,f,c=>{a(c)},c=>{t(c)},0):$(r,e,[],{reject:t,resolve:a},f)}catch(l){t(l)}},t)}catch(s){t(s)}},t)})}async function Pe(r,e){const a=e.argument;if(a.type==="MemberExpression"){const s={t:null},l=await o(r,a.object);let f=null;s.t=l,a.computed===!0?f=await o(r,a.property):a.property.type==="Identifier"&&(f=a.property.name);const c=s.t;let p;if(K(c))if(M(f)){if(f<0&&(f=c.length+f),f<0||f>=c.length)throw new n(r,u.OutOfBounds,e);p=h(c[f]),c[f]=e.operator==="++"?p+1:p-1}else throw new n(r,u.ArrayAccessorMustBeNumber,e);else if(c instanceof C){if(m(f)===!1)throw new n(r,u.KeyAccessorMustBeString,e);if(c.hasField(f)===!0)p=h(c.field(f)),c.setField(f,e.operator==="++"?p+1:p-1);else throw new n(r,u.FieldNotFound,e,{key:f})}else if(c instanceof E){if(m(f)===!1)throw new n(r,u.ModuleAccessorMustBeString,e);if(c.hasGlobal(f)===!0)p=h(await c.global(f)),c.setGlobal(f,e.operator==="++"?p+1:p-1);else throw new n(r,u.ModuleExportNotFound,e)}else if(L(c)){if(m(f)===!1)throw new n(r,u.KeyAccessorMustBeString,e);if(c.hasField(f)===!0)p=h(c.field(f)),c.setField(f,e.operator==="++"?p+1:p-1);else throw new n(r,u.FieldNotFound,e,{key:f})}else throw k(c)?new n(r,u.Immutable,e):new n(r,u.InvalidParameter,e);return e.prefix===!1?p:e.operator==="++"?p+1:p-1}const t=e.argument.type==="Identifier"?e.argument.name.toLowerCase():"";if(!t)throw new n(r,u.InvalidIdentifier,e);let i;if(r.localScope!=null&&r.localScope[t]!==void 0)return i=h(r.localScope[t].value),r.localScope[t]={value:e.operator==="++"?i+1:i-1,valueset:!0,node:e},e.prefix===!1?i:e.operator==="++"?i+1:i-1;if(r.globalScope[t]!==void 0)return i=h(r.globalScope[t].value),r.globalScope[t]={value:e.operator==="++"?i+1:i-1,valueset:!0,node:e},e.prefix===!1?i:e.operator==="++"?i+1:i-1;throw new n(r,u.InvalidIdentifier,e)}function S(r,e,a,t,i){switch(e){case"=":return r===w?null:r;case"/=":return h(a)/h(r);case"*=":return h(a)*h(r);case"-=":return h(a)-h(r);case"+=":return m(a)||m(r)?N(a)+N(r):h(a)+h(r);case"%=":return h(a)%h(r);default:throw new n(i,u.UnsupportedOperator,t)}}async function qe(r,e){const a=e.left;if(a.type==="MemberExpression"){const i=await o(r,a.object);let s=null;if(a.computed===!0)s=await o(r,a.property);else if(a.property.type==="Identifier")s=a.property.name;else throw new n(r,u.InvalidIdentifier,e);const l=await o(r,e.right);if(K(i))if(M(s)){if(s<0&&(s=i.length+s),s<0||s>i.length)throw new n(r,u.OutOfBounds,e);if(s===i.length){if(e.operator!=="=")throw new n(r,u.OutOfBounds,e);i[s]=S(l,e.operator,i[s],e,r)}else i[s]=S(l,e.operator,i[s],e,r)}else throw new n(r,u.ArrayAccessorMustBeNumber,e);else if(i instanceof C){if(m(s)===!1)throw new n(r,u.KeyAccessorMustBeString,e);if(i.hasField(s)===!0)i.setField(s,S(l,e.operator,i.field(s),e,r));else{if(e.operator!=="=")throw new n(r,u.FieldNotFound,e,{key:s});i.setField(s,S(l,e.operator,null,e,r))}}else if(i instanceof E){if(m(s)===!1)throw new n(r,u.KeyAccessorMustBeString,e);if(i.hasGlobal(s)===!0)i.setGlobal(s,S(l,e.operator,await i.global(s),e,r));else throw new n(r,u.ModuleExportNotFound,e)}else if(L(i)){if(m(s)===!1)throw new n(r,u.KeyAccessorMustBeString,e);if(i.hasField(s)===!0)i.setField(s,S(l,e.operator,i.field(s),e,r));else{if(e.operator!=="=")throw new n(r,u.FieldNotFound,e,{key:s});i.setField(s,S(l,e.operator,null,e,r))}}else throw k(i)?new n(r,u.Immutable,e):new n(r,u.InvalidParameter,e);return w}const t=a.name.toLowerCase();if(r.localScope!=null&&r.localScope[t]!==void 0){const i=await o(r,e.right);return r.localScope[t]={value:S(i,e.operator,r.localScope[t].value,e,r),valueset:!0,node:e.right},w}if(r.globalScope[t]!==void 0){const i=await o(r,e.right);return r.globalScope[t]={value:S(i,e.operator,r.globalScope[t].value,e,r),valueset:!0,node:e.right},w}throw new n(r,u.InvalidIdentifier,e)}async function Ke(r,e){if(e.expression.type==="AssignmentExpression")return o(r,e.expression);if(e.expression.type==="CallExpression"){const t=await o(r,e.expression);return t===w?w:new T(t)}const a=await o(r,e.expression);return a===w?w:new T(a)}async function ke(r,e){const a=await o(r,e.test);if(a===!0)return o(r,e.consequent);if(a===!1)return e.alternate!==null?o(r,e.alternate):w;throw new n(r,u.BooleanConditionRequired,e)}async function Ge(r,e){return te(r,e,0)}async function te(r,e,a){if(a>=e.body.length)return w;const t=await o(r,e.body[a]);return t instanceof y||t===b||t===q||a===e.body.length-1?t:te(r,e,a+1)}async function Ue(r,e){if(e.argument===null)return new y(w);const a=await o(r,e.argument);return new y(a)}async function _e(r,e){const a=e.id.name.toLowerCase();return r.globalScope[a]={valueset:!0,node:null,value:new Ce(e,r)},w}async function Ve(r,e){var s,l;const a=e.specifiers[0].local.name.toLowerCase(),t=r.libraryResolver.loadLibrary(a);let i=null;return(s=r.libraryResolver._moduleSingletons)!=null&&s.has(t.uri)?i=r.libraryResolver._moduleSingletons.get(t.uri):(i=new E(t),await i.loadModule(r),(l=r.libraryResolver._moduleSingletons)==null||l.set(t.uri,i)),r.globalScope[a]={value:i,valueset:!0,node:e},w}async function We(r,e){if(await o(r,e.declaration),e.declaration.type==="FunctionDeclaration")r.exports[e.declaration.id.name.toLowerCase()]="function";else if(e.declaration.type==="VariableDeclaration")for(const a of e.declaration.declarations)r.exports[a.id.name.toLowerCase()]="variable";return w}async function ie(r,e,a){return a>=e.declarations.length?w:(await o(r,e.declarations[a]),a===e.declarations.length-1?w:(await ie(r,e,a+1),w))}async function ze(r,e){let a=null;if(e.init===null?a=null:a=await o(r,e.init),r.localScope!==null){if(a===w&&(a=null),e.id.type!=="Identifier")throw new n(r,u.InvalidIdentifier,e);const i=e.id.name.toLowerCase();return r.localScope!=null&&(r.localScope[i]={value:a,valueset:!0,node:e.init}),w}if(e.id.type!=="Identifier")throw new n(r,u.InvalidIdentifier,e);const t=e.id.name.toLowerCase();return a===w&&(a=null),r.globalScope[t]={value:a,valueset:!0,node:e.init},w}async function $e(r,e){const a=await o(r,e.object);if(a===null)throw new n(r,u.MemberOfNull,e);if(e.computed===!1){if(e.property.type==="Identifier"){if(a instanceof C||L(a))return a.field(e.property.name);if(a instanceof X)return d(a,e.property.name,r,e);if(a instanceof E){if(!a.hasGlobal(e.property.name))throw new n(r,u.InvalidIdentifier,e);return a.global(e.property.name)}throw new n(r,u.InvalidMemberAccessKey,e)}throw new n(r,u.InvalidMemberAccessKey,e)}let t=await o(r,e.property);if(a instanceof C||L(a)){if(m(t))return a.field(t);throw new n(r,u.InvalidMemberAccessKey,e)}else if(a instanceof E){if(m(t))return a.global(t);throw new n(r,u.InvalidMemberAccessKey,e)}else if(a instanceof X){if(m(t))return d(a,t,r,e);throw new n(r,u.InvalidMemberAccessKey,e)}else if(K(a)){if(M(t)&&isFinite(t)&&Math.floor(t)===t){if(t<0&&(t=a.length+t),t>=a.length||t<0)throw new n(r,u.OutOfBounds,e);return a[t]}throw new n(r,u.InvalidMemberAccessKey,e)}else if(k(a)){if(M(t)&&isFinite(t)&&Math.floor(t)===t){if(t<0&&(t=a.length()+t),t>=a.length()||t<0)throw new n(r,u.OutOfBounds,e);return a.get(t)}throw new n(r,u.InvalidMemberAccessKey,e)}else if(m(a)){if(M(t)&&isFinite(t)&&Math.floor(t)===t){if(t<0&&(t=a.length+t),t>=a.length||t<0)throw new n(r,u.OutOfBounds,e);return a[t]}throw new n(r,u.InvalidMemberAccessKey,e)}else throw new n(r,u.InvalidMemberAccessKey,e)}async function je(r,e){const a=await o(r,e.argument);if(A(a)){if(e.operator==="!")return!a;if(e.operator==="-")return-1*h(a);if(e.operator==="+")return 1*h(a);if(e.operator==="~")return~h(a);throw new n(r,u.UnsupportedUnaryOperator,e)}else{if(e.operator==="-")return-1*h(a);if(e.operator==="+")return 1*h(a);if(e.operator==="~")return~h(a);throw new n(r,u.UnsupportedUnaryOperator,e)}}async function He(r,e){const a=[];for(let t=0;t<e.elements.length;t++)a.push(await o(r,e.elements[t]));for(let t=0;t<a.length;t++){if(v(a[t]))throw new n(r,u.NoFunctionInArray,e);a[t]===w&&(a[t]=null)}return a}async function Je(r,e){const a=[];a[0]=await o(r,e.left),a[1]=await o(r,e.right);const t=a[0],i=a[1];switch(e.operator){case"|":case"<<":case">>":case">>>":case"^":case"&":return Se(h(t),h(i),e.operator);case"==":return _(t,i);case"!=":return!_(t,i);case"<":return O(t,i,e.operator);case">":return O(t,i,e.operator);case"<=":return O(t,i,e.operator);case">=":return O(t,i,e.operator);case"+":return m(t)||m(i)?N(t)+N(i):h(t)+h(i);case"-":return h(t)-h(i);case"*":return h(t)*h(i);case"/":return h(t)/h(i);case"%":return h(t)%h(i);default:throw new n(r,u.UnsupportedOperator,e)}}async function Ye(r,e){const a=await o(r,e.left);let t=null;if(A(a))switch(e.operator){case"||":if(a===!0)return a;if(t=await o(r,e.right),A(t))return t;throw new n(r,u.LogicExpressionOrAnd,e);case"&&":if(a===!1)return a;if(t=await o(r,e.right),A(t))return t;throw new n(r,u.LogicExpressionOrAnd,e);default:throw new n(r,u.LogicExpressionOrAnd,e)}else throw new n(r,u.LogicalExpressionOnlyBoolean,e)}async function Y(r,e){const a=e.name.toLowerCase();if(r.localScope!=null&&r.localScope[a]!==void 0){const t=r.localScope[a];if(t.valueset===!0)return t.value;if(t.d!==null)return t.d;t.d=o(r,t.node);const i=await t.d;return t.value=i,t.valueset=!0,i}if(r.globalScope[a]!==void 0){const t=r.globalScope[a];if(t.valueset===!0)return t.value;if(t.d!==null)return t.d;t.d=o(r,t.node);const i=await t.d;return t.value=i,t.valueset=!0,i}throw new n(r,u.InvalidIdentifier,e)}async function de(r,e){if(e.callee.type==="MemberExpression"){const a=await o(r,e.callee.object);if(!(a instanceof E))throw new n(r,u.FuncionNotFound,e);const t=e.callee.computed===!1?e.callee.property.name:await o(r,e.callee.property);if(!a.hasGlobal(t))throw new n(r,u.FuncionNotFound,e);const i=await a.global(t);if(!v(i))throw new n(r,u.CallNonFunction,e);return i.call(r,e)}if(e.callee.type!=="Identifier")throw new n(r,u.FuncionNotFound,e);if(r.localScope!=null&&r.localScope[e.callee.name.toLowerCase()]!==void 0){const a=r.localScope[e.callee.name.toLowerCase()];if(v(a.value))return a.value.call(r,e);throw new n(r,u.CallNonFunction,e)}if(r.globalScope[e.callee.name.toLowerCase()]!==void 0){const a=r.globalScope[e.callee.name.toLowerCase()];if(v(a.value))return a.value.call(r,e);throw new n(r,u.CallNonFunction,e)}throw new n(r,u.FuncionNotFound,e)}async function Qe(r,e){return e.value?e.value.cooked:""}function Xe(r,e,a){if(v(r))throw new n(e,u.NoFunctionInTemplateLiteral,a);return r}async function Ze(r,e){const a=[];for(let s=0;s<e.expressions.length;s++){const l=await o(r,e.expressions[s]);a[s]=N(l)}let t="",i=0;for(const s of e.quasis)if(t+=s.value?s.value.cooked:"",s.tail===!1){const l=a[i]?Xe(a[i],r,e):"";t+=l,i++}return t}const g={};fe(g,I);ce(g,I);pe(g,I);we(g,I);he(g,I);Ae({functions:g,compiled:!1,signatures:null,evaluateIdentifier:null,mode:"async",standardFunction:I,standardFunctionAsync:B});g.iif=async function(r,e){me(e.arguments===null?[]:e.arguments,3,3,r,e);const a=await o(r,e.arguments[0]);if(A(a)===!1)throw new n(r,u.BooleanConditionRequired,e);return a?o(r,e.arguments[1]):o(r,e.arguments[2])};g.decode=async function(r,e){if(e.arguments.length<2)throw new n(r,u.WrongNumberOfParameters,e);if(e.arguments.length===2)return o(r,e.arguments[1]);if((e.arguments.length-1)%2===0)throw new n(r,u.WrongNumberOfParameters,e);const a=await o(r,e.arguments[0]);return se(r,e,1,a)};async function se(r,e,a,t){const i=await o(r,e.arguments[a]);if(_(i,t))return o(r,e.arguments[a+1]);const s=e.arguments.length-a;return s===1?o(r,e.arguments[a]):s===2?null:s===3?o(r,e.arguments[a+2]):se(r,e,a+2,t)}g.when=async function(r,e){if(e.arguments.length<3)throw new n(r,u.WrongNumberOfParameters,e);if(e.arguments.length%2===0)throw new n(r,u.WrongNumberOfParameters,e);const a=await o(r,e.arguments[0]);if(A(a)===!1)throw new n(r,u.BooleanConditionRequired,e.arguments[0]);return le(r,e,0,a)};async function le(r,e,a,t){if(t===!0)return o(r,e.arguments[a+1]);if(e.arguments.length-a===3)return o(r,e.arguments[a+2]);const s=await o(r,e.arguments[a+2]);if(A(s)===!1)throw new n(r,u.ModuleExportNotFound,e.arguments[a+2]);return le(r,e,a+2,s)}async function U(r,e,a,t){const i=r.body;if(a.length!==r.params.length)throw new n(e,u.WrongNumberOfParameters,null);for(let l=0;l<a.length;l++){const f=r.params[l];f.type==="Identifier"&&e.localScope!=null&&(e.localScope[f.name.toLowerCase()]={d:null,value:a[l],valueset:!0,node:null})}const s=await o(e,i);if(s instanceof y)return s.value;if(s===b)throw new n(e,u.UnexpectedToken,t);if(s===q)throw new n(e,u.UnexpectedToken,t);return s instanceof T?s.value:s}const xe={fixSpatialReference:be,parseArguments:J,standardFunction:I,standardFunctionAsync:B,evaluateIdentifier:Y};for(const r in g)g[r]={value:new H(g[r]),valueset:!0,node:null};const D=function(){};D.prototype=g;D.prototype.infinity={value:Number.POSITIVE_INFINITY,valueset:!0,node:null};D.prototype.pi={value:Math.PI,valueset:!0,node:null};function ne(r,e,a){const t=new D;r==null&&(r={}),e==null&&(e={});const i=new C({newline:`
`,tab:"	",singlequote:"'",doublequote:'"',forwardslash:"/",backwardslash:"\\"});i.immutable=!1,t.textformatting={value:i,valueset:!0,node:null};for(const s in e)t[s]={value:new H(e[s]),native:!0,valueset:!0,node:null};for(const s in r)r[s]&&r[s].declaredClass==="esri.Graphic"?t[s]={value:re.createFromGraphic(r[s],a),valueset:!0,node:null}:t[s]={value:r[s],valueset:!0,node:null};return t}function ue(r){console.log(r)}const gr=xe;function er(r){const e={mode:"async",compiled:!1,functions:{},signatures:[],standardFunction:I,standardFunctionAsync:B,evaluateIdentifier:Y};for(let a=0;a<r.length;a++)r[a].registerFunctions(e);for(const a in e.functions)g[a]={value:new H(e.functions[a]),valueset:!0,node:null},D.prototype[a]=g[a];for(let a=0;a<e.signatures.length;a++)ge(e.signatures[a],"async")}er([ye]);async function yr(r,e){let a=e.spatialReference;a==null&&(a=new ae({wkid:102100}));let t=null;r.usesModules&&(t=new ee(new Map,r.loadedModules));const i=ne(e.vars,e.customfunctions,e.timeReference),s={spatialReference:a,services:e.services,exports:{},libraryResolver:t,abortSignal:e.abortSignal===void 0||e.abortSignal===null?{aborted:!1}:e.abortSignal,globalScope:i,console:e.console??ue,timeReference:e.timeReference??null,lrucache:e.lrucache,interceptor:e.interceptor,localScope:null,depthCounter:{depth:1}};let l=await o(s,r);if(l instanceof y&&(l=l.value),l instanceof T&&(l=l.value),l===w&&(l=null),l===b)throw new n(s,u.IllegalResult,null);if(l===q)throw new n(s,u.IllegalResult,null);if(v(l))throw new n(s,u.IllegalResult,null);return l}export{yr as executeScript,er as extend,gr as functionHelper};
