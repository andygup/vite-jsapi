import{da as Tt,dW as j,b_ as k,gw as x,hb as Q,gp as Y,hc as Ot,b as A,by as p,hd as tt,go as K,ae as bt,ai as gt,t as Et,gJ as w}from"./index-0cbe37a0.js";import{c as P,g as q,a as N,i as et,b as y,d as Rt,f as St,p as At,e as nt}from"./sphere-590baeaf.js";import{S as st}from"./QueryEngineResult-7b3900b2.js";import{O as lt,c as it,w as ot}from"./ray-505391b0.js";import"./plane-1d4e229f.js";import{r as rt}from"./InterleavedLayout-ca0609dc.js";import{d as Nt}from"./edgeProcessing-eea52a20.js";import"./vec4-3dd523e8.js";import"./vec4f64-efdcb593.js";import"./quantizationUtils-7579f13f.js";import"./ItemCache-6b2cf6d9.js";import"./MemCache-8eec5c08.js";import"./WhereClause-47cc30df.js";import"./executionError-e2eca390.js";import"./_commonjsHelpers-725317a4.js";import"./utils-06a5bb33.js";import"./generateRendererUtils-9abc323d.js";import"./projectionSupport-f22cfeca.js";import"./json-9ae8d6f8.js";import"./utils-46832fb9.js";import"./normalizeUtils-89acfe4c.js";import"./normalizeUtilsCommon-088d2983.js";import"./featureConversionUtils-f0b03e2b.js";import"./OptimizedGeometry-af84d2ad.js";import"./OptimizedFeatureSet-5c82fe5a.js";import"./ByteSizeUnit-c0a244d3.js";import"./mat3f64-c33d428a.js";import"./mat4f64-06a72c15.js";import"./quatf64-5b0101cd.js";import"./BufferView-15a3975b.js";import"./types-c657ebd9.js";import"./deduplicate-2c15084f.js";import"./Indices-facb78dc.js";import"./VertexAttribute-8238ac80.js";import"./enums-08489827.js";import"./VertexElementDescriptor-24e04d97.js";function ft(i){return i?{ray:it(i.ray),c0:i.c0,c1:i.c1}:{ray:it(),c0:0,c1:Number.MAX_VALUE}}new lt(()=>ft());function I(i,t){for(let e=0;e<Ft;e++){const n=i[e];if(n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]>=t[3])return!1}return!0}var at;(function(i){i[i.LEFT=0]="LEFT",i[i.RIGHT=1]="RIGHT",i[i.BOTTOM=2]="BOTTOM",i[i.TOP=3]="TOP",i[i.NEAR=4]="NEAR",i[i.FAR=5]="FAR"})(at||(at={}));var d;(function(i){i[i.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",i[i.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",i[i.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",i[i.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",i[i.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",i[i.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",i[i.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",i[i.FAR_TOP_LEFT=7]="FAR_TOP_LEFT"})(d||(d={}));d.FAR_BOTTOM_RIGHT,d.NEAR_BOTTOM_RIGHT,d.NEAR_BOTTOM_LEFT,d.FAR_BOTTOM_LEFT,d.NEAR_BOTTOM_LEFT,d.NEAR_BOTTOM_RIGHT,d.NEAR_TOP_RIGHT,d.NEAR_TOP_LEFT,d.FAR_BOTTOM_RIGHT,d.FAR_BOTTOM_LEFT,d.FAR_TOP_LEFT,d.FAR_TOP_RIGHT,d.NEAR_BOTTOM_RIGHT,d.FAR_BOTTOM_RIGHT,d.FAR_TOP_RIGHT,d.NEAR_TOP_RIGHT,d.FAR_BOTTOM_LEFT,d.NEAR_BOTTOM_LEFT,d.NEAR_TOP_LEFT,d.FAR_TOP_LEFT,d.FAR_TOP_LEFT,d.NEAR_TOP_LEFT,d.NEAR_TOP_RIGHT,d.FAR_TOP_RIGHT;const Ft=6;new lt(ft);class D{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,e){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new u,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}destroy(){this._degenerateObjects.clear(),u.clearPool(),U[0]=null,F.prune(),M.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const n=u.acquire();for(let s=0;s<e;s++){const o=t[s];this._isDegenerate(o)?this._degenerateObjects.add(o):(n.init(this._root),this._add(o,n))}u.release(n)}remove(t,e=null){this._objectCount-=t.length;const n=u.acquire();for(const s of t){const o=e??P(this.objectToBoundingSphere(s),xt);z(o[3])?(n.init(this._root),this._remove(s,o,n)):this._degenerateObjects.delete(s)}u.release(n),this._shrink()}update(t,e){if(!z(e[3])&&this._isDegenerate(t))return;const n=Bt(t);this.remove(n,e),this.add(n)}forEachAlongRay(t,e,n){const s=ot(t,e);this._forEachNode(this._root,o=>{if(!this._intersectsNode(s,o))return!1;const a=o.node;return a.terminals.forAll(c=>{this._intersectsObject(s,c)&&n(c)}),a.residents!==null&&a.residents.forAll(c=>{this._intersectsObject(s,c)&&n(c)}),!0})}forEachAlongRayWithVerticalOffset(t,e,n,s){const o=ot(t,e);this._forEachNode(this._root,a=>{if(!this._intersectsNodeWithOffset(o,a,s))return!1;const c=a.node;return c.terminals.forAll(r=>{this._intersectsObjectWithOffset(o,r,s)&&n(r)}),c.residents!==null&&c.residents.forAll(r=>{this._intersectsObjectWithOffset(o,r,s)&&n(r)}),!0})}forEach(t){this._forEachNode(this._root,e=>{const n=e.node;return n.terminals.forAll(t),n.residents!==null&&n.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,n,s=()=>!0,o=1/0){let a=1/0,c=1/0,r=null;const h=W(t,e),f=l=>{if(--o,!s(l))return;const _=this.objectToBoundingSphere(l);if(!I(n,_))return;const g=S(t,e,N(_)),E=g-_[3],m=g+_[3];E<a&&(a=E,c=m,r=l)};return this._forEachNodeDepthOrdered(this._root,l=>{if(o<=0||!I(n,l.bounds)||(k(b,h,l.halfSize),x(b,b,l.bounds),S(t,e,b)>c))return!1;const g=l.node;return g.terminals.forAll(E=>f(E)),g.residents!==null&&g.residents.forAll(E=>f(E)),!0},t,e),r}forEachInDepthRange(t,e,n,s,o,a,c){let r=-1/0,h=1/0;const f={setRange:m=>{n===D.DepthOrder.FRONT_TO_BACK?(r=Math.max(r,m.near),h=Math.min(h,m.far)):(r=Math.max(r,-m.far),h=Math.min(h,-m.near))}};f.setRange(s);const l=S(e,n,t),_=W(e,n),g=W(e,-n),E=m=>{if(!c(m))return;const L=this.objectToBoundingSphere(m),Z=N(L),B=S(e,n,Z)-l,C=B-L[3],pt=B+L[3];C>h||pt<r||!I(a,L)||o(m,f)};this._forEachNodeDepthOrdered(this._root,m=>{if(!I(a,m.bounds)||(k(b,_,m.halfSize),x(b,b,m.bounds),S(e,n,b)-l>h)||(k(b,g,m.halfSize),x(b,b,m.bounds),S(e,n,b)-l<r))return!1;const B=m.node;return B.terminals.forAll(C=>E(C)),B.residents!==null&&B.residents.forAll(C=>E(C)),!0},e,n)}forEachNode(t){this._forEachNode(this._root,e=>t(e.node,e.bounds,e.halfSize,e.depth))}forEachNeighbor(t,e){const n=q(e),s=N(e),o=r=>{const h=this.objectToBoundingSphere(r),f=q(h),l=n+f;return Q(N(h),s)-l*l<=0?t(r):!0};let a=!0;const c=r=>{a&&(a=o(r))};this._forEachNode(this._root,r=>{const h=q(r.bounds),f=n+h;if(Q(N(r.bounds),s)-f*f>0)return!1;const _=r.node;return _.terminals.forAll(c),a&&_.residents!==null&&_.residents.forAll(c),a}),a&&this.forEachDegenerateObject(c)}_intersectsNode(t,e){return H(e.bounds,-e.halfSize*2,T),H(e.bounds,e.halfSize*2,O),rt(t.origin,t.direction,T,O)}_intersectsNodeWithOffset(t,e,n){return H(e.bounds,-e.halfSize*2,T),H(e.bounds,e.halfSize*2,O),n.applyToMinMax(T,O),rt(t.origin,t.direction,T,O)}_intersectsObject(t,e){const n=this.objectToBoundingSphere(e);return n[3]>0?et(n,t):!0}_intersectsObjectWithOffset(t,e,n){const s=this.objectToBoundingSphere(e);return s[3]>0?et(n.applyToBoundingSphere(s),t):!0}_forEachNode(t,e){let n=u.acquire().init(t);const s=[n];for(;s.length!==0;){if(n=s.pop(),e(n)&&!n.isLeaf())for(let o=0;o<n.node.children.length;o++)n.node.children[o]&&s.push(u.acquire().init(n).advance(o));u.release(n)}}_forEachNodeDepthOrdered(t,e,n,s=D.DepthOrder.FRONT_TO_BACK){let o=u.acquire().init(t);const a=[o];for(yt(n,s,dt);a.length!==0;){if(o=a.pop(),e(o)&&!o.isLeaf())for(let c=7;c>=0;--c){const r=dt[c];o.node.children[r]&&a.push(u.acquire().init(o).advance(r))}u.release(o)}}_remove(t,e,n){F.clear();const o=n.advanceTo(e,(a,c)=>{F.push(a.node),F.push(c)})?n.node.terminals:n.node.residents;if(o.removeUnordered(t),o.length===0)for(let a=F.length-2;a>=0;a-=2){const c=F.data[a],r=F.data[a+1];if(!this._purge(c,r))break}}_nodeIsEmpty(t){if(t.terminals.length!==0)return!1;if(t.residents!==null)return t.residents.length===0;for(let e=0;e<t.children.length;e++)if(t.children[e])return!1;return!0}_purge(t,e){return e>=0&&(t.children[e]=null),this._nodeIsEmpty(t)?(t.residents===null&&(t.residents=new j({shrink:!0})),!0):!1}_add(t,e){e.advanceTo(this.objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let n=0;n<e.length;n++){const s=u.acquire().init(t);this._add(e.getItemAt(n),s),u.release(s)}}_grow(t,e){if(e!==0&&(ct(t,e,n=>this.objectToBoundingSphere(n),R),!(!z(R[3])||this._fitsInsideTree(R))))if(this._nodeIsEmpty(this._root.node))P(R,this._root.bounds),this._root.halfSize=this._root.bounds[3]*1.25,this._root.updateBoundsRadiusFromHalfSize();else{const n=this._rootBoundsForRootAsSubNode(R);this._placingRootViolatesMaxDepth(n)?this._rebuildTree(R,n):this._growRootAsSubNode(n),u.release(n)}}_rebuildTree(t,e){Y($,e.bounds),$[3]=e.halfSize,ct([t,$],2,s=>s,J);const n=u.acquire().init(this._root);this._root.initFrom(null,J,J[3]),this._root.increaseHalfSize(1.25),this._forEachNode(n,s=>(this.add(s.node.terminals.data,s.node.terminals.length),s.node.residents!==null&&this.add(s.node.residents.data,s.node.residents.length),!0)),u.release(n)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,s=>(n=Math.max(n,s.depth),n+e<=this._maximumDepth)),n+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],n=t;let s=-1/0;const o=this._root.bounds,a=this._root.halfSize;for(let r=0;r<3;r++){const h=o[r]-a-(n[r]-e),f=n[r]+e-(o[r]+a),l=Math.max(0,Math.ceil(h/(a*2))),_=Math.max(0,Math.ceil(f/(a*2)))+1,g=2**Math.ceil(Math.log(l+_)*Math.LOG2E);s=Math.max(s,g),G[r].min=l,G[r].max=_}for(let r=0;r<3;r++){let h=G[r].min,f=G[r].max;const l=(s-(h+f))/2;h+=Math.ceil(l),f+=Math.floor(l);const _=o[r]-a-h*a*2;v[r]=_+(f+h)*a}const c=s*a;return v[3]=c*mt,u.acquire().initFrom(null,v,c,0)}_growRootAsSubNode(t){const e=this._root.node;Y(R,this._root.bounds),R[3]=this._root.halfSize,this._root.init(t),t.advanceTo(R,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let n=0,s=0;for(;s<e.length&&t==null;)n=s++,t=e[n];for(;s<e.length;)if(e[s++])return-1;return n}_isDegenerate(t){const e=this.objectToBoundingSphere(t)[3];return!z(e)}_fitsInsideTree(t){const e=this._root.bounds,n=this._root.halfSize;return t[3]<=n&&t[0]>=e[0]-n&&t[0]<=e[0]+n&&t[1]>=e[1]-n&&t[1]<=e[1]+n&&t[2]>=e[2]-n&&t[2]<=e[2]+n}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:e,_objectCount:n}=this,s=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:e,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:s}}}_nodeToJSON(t){var o,a;const e=t.children.map(c=>c?this._nodeToJSON(c):null),n=(o=t.residents)==null?void 0:o.map(c=>this.objectToBoundingSphere(c)),s=(a=t.terminals)==null?void 0:a.map(c=>this.objectToBoundingSphere(c));return{children:e,residents:n,terminals:s}}static fromJSON(t){const e=new D(n=>n,{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return e._objectCount=t.objectCount,e._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),e}}class u{constructor(){this.bounds=y(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,n,s=this.depth){return this.node=t??u.createEmptyNode(),e!=null&&P(e,this.bounds),this.halfSize=n,this.depth=s,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*mt}advance(t){let e=this.node.children[t];e||(e=u.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const n=_t[t];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,e,n=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!n)return e&&e(this,-1),!1;this.node.residents=null}const s=this._childIndex(t);e&&e(this,s),this.advance(s)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new j({shrink:!0}),residents:new j({shrink:!0})}}static acquire(){return u._pool.acquire()}static release(t){u._pool.release(t)}static clearPool(){u._pool.prune()}}u._pool=new Tt(u);(function(i){(function(t){t[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"})(i.DepthOrder||(i.DepthOrder={}))})(D||(D={}));function Mt(i,t){i[0]=Math.min(i[0],t[0]-t[3]),i[1]=Math.min(i[1],t[1]-t[3]),i[2]=Math.min(i[2],t[2]-t[3])}function Dt(i,t){i[0]=Math.max(i[0],t[0]+t[3]),i[1]=Math.max(i[1],t[1]+t[3]),i[2]=Math.max(i[2],t[2]+t[3])}function H(i,t,e){e[0]=i[0]+t,e[1]=i[1]+t,e[2]=i[2]+t}function ct(i,t,e,n){if(t===1){const s=e(i[0]);P(s,n)}else{T[0]=1/0,T[1]=1/0,T[2]=1/0,O[0]=-1/0,O[1]=-1/0,O[2]=-1/0;for(let s=0;s<t;s++){const o=e(i[s]);z(o[3])&&(Mt(T,o),Dt(O,o))}Ot(n,T,O,.5),n[3]=Math.max(O[0]-T[0],O[1]-T[1],O[2]-T[2])/2}}function yt(i,t,e){if(!M.length)for(let n=0;n<8;++n)M.push({index:0,distance:0});for(let n=0;n<8;++n){const s=_t[n];M.data[n].index=n,M.data[n].distance=S(i,t,s)}M.sort((n,s)=>n.distance-s.distance);for(let n=0;n<8;++n)e[n]=M.data[n].index}function W(i,t){let e=1/0,n;for(let s=0;s<8;++s){const o=S(i,t,ht[s]);o<e&&(e=o,n=ht[s])}return n}function S(i,t,e){return t*(i[0]*e[0]+i[1]*e[1]+i[2]*e[2])}function z(i){return!isNaN(i)&&i!==-1/0&&i!==1/0&&i>0}const _t=[p(-1,-1,-1),p(1,-1,-1),p(-1,1,-1),p(1,1,-1),p(-1,-1,1),p(1,-1,1),p(-1,1,1),p(1,1,1)],ht=[p(-1,-1,-1),p(-1,-1,1),p(-1,1,-1),p(-1,1,1),p(1,-1,-1),p(1,-1,1),p(1,1,-1),p(1,1,1)],mt=Math.sqrt(3),U=[null];function Bt(i){return U[0]=i,U}const v=y(),b=A(),T=A(),O=A(),F=new j,xt=y(),R=y(),$=y(),J=y(),G=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],M=new j,dt=[0,0,0,0,0,0,0,0],ut=D,Lt=1e3;function Ct(i,t,e){const n=y(),s=N(n);return tt(s,s,i,.5),tt(s,s,t,.5),n[3]=K(s,i),x(s,s,e),n}let X=class{constructor(){this._idToComponent=new Map,this._components=new ut(t=>t.bounds),this._edges=new ut(t=>t.bounds),this._tmpLineSegment=Rt(),this._tmpP1=A(),this._tmpP2=A(),this._tmpP3=A(),this.remoteClient=null}async fetchCandidates(t,e){await Promise.resolve(),Et(e),await this._ensureEdgeLocations(t,e);const n=[];return this._edges.forEachNeighbor(s=>(this._addCandidates(t,s,n),n.length<Lt),t.bounds),{result:{candidates:n}}}async _ensureEdgeLocations(t,e){const n=[];if(this._components.forEachNeighbor(a=>{if(a.info==null){const{id:c,uid:r}=a;n.push({id:c,uid:r})}return!0},t.bounds),!n.length)return;const s={components:n},o=await this.remoteClient.invoke("fetchAllEdgeLocations",s,e??{});for(const a of o.components)this._setFetchEdgeLocations(a)}async add(t){const e=new V(t.id,t.bounds);return this._idToComponent.set(e.id,e),this._components.add([e]),{result:{}}}async remove(t){const e=this._idToComponent.get(t.id);if(e){const n=[];this._edges.forEachNeighbor(s=>(s.component===e&&n.push(s),!0),e.bounds),this._edges.remove(n),this._components.remove([e]),this._idToComponent.delete(e.id)}return{result:{}}}_setFetchEdgeLocations(t){const e=this._idToComponent.get(t.id);if(e==null||t.uid!==e.uid)return;const n=Nt.createView(t.locations),s=new Array(n.count),o=A(),a=A();for(let h=0;h<n.count;h++){n.position0.getVec(h,o),n.position1.getVec(h,a);const f=Ct(o,a,t.origin),l=new zt(e,h,f);s[h]=l}this._edges.add(s);const{objectIds:c,origin:r}=t;e.info={locations:n,objectIds:c,origin:r}}_addCandidates(t,e,n){const{info:s}=e.component,{origin:o,objectIds:a}=s,c=s.locations,r=c.position0.getVec(e.index,this._tmpP1),h=c.position1.getVec(e.index,this._tmpP2);x(r,r,o),x(h,h,o);const f=a[c.componentIndex.get(e.index)];this._addEdgeCandidate(t,f,r,h,n),this._addVertexCandidate(t,f,r,n),this._addVertexCandidate(t,f,h,n)}_addEdgeCandidate(t,e,n,s,o){if(!(t.types&st.EDGE))return;const a=N(t.bounds),c=St(n,s,this._tmpLineSegment),r=At(c,a,this._tmpP3);nt(t.bounds,r)&&o.push({type:"edge",objectId:e,target:w(r),distance:K(a,r),start:w(n),end:w(s)})}_addVertexCandidate(t,e,n,s){if(!(t.types&st.VERTEX))return;const o=N(t.bounds);nt(t.bounds,n)&&s.push({type:"vertex",objectId:e,target:w(n),distance:K(o,n)})}};X=bt([gt("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],X);const Oe=X;class V{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++V.uid}}V.uid=0;class zt{constructor(t,e,n){this.component=t,this.index=e,this.bounds=n}}export{Oe as default};
